@using System.Collections.Concurrent
@using System.Collections.ObjectModel
@using System.Diagnostics
@using System.Threading
@using Namotion.Reflection
@using Razor_Components.Inputs

@inject ProcessContext ProcessContext
@inject NavigationManager NavigationManager
    <div>
        <h2>
            @Method?.Name
        </h2>
        <text>@XmlComment</text>
        <br />

        @if (MethodMetadata != null)
        {
            <input @bind="@MethodMetadata.Notes"  /> //TODO this won't be updated unless you actually call the method
            <br />
        }

        @* ReSharper disable once Html.Obsolete *@
        @if (ParameterInputs != null)
        {
            <table sortable="True" cols="3" border="1">
                @foreach (var param in ParameterInputs)
                {
                    var metadata = ParameterMetadataDictionary != null
                                   && ParameterMetadataDictionary.TryGetValue(param.ParameterName, out var pm) ?
                        pm : null;

                    <ParameterBox ParameterInput="@param" ParameterDictionary="@ParameterDictionary" ParameterMetadata="@metadata" />
                }
            </table>
            <br />
            <button name="Go" @onclick="Invoke">Go</button>
            <br />
        }

        @if (!string.IsNullOrWhiteSpace(ResultText))
        {
            <h3>@ResultText</h3>
        }
        <br />
        <br />
    </div>

@code {

    /// <summary>
    /// The method to run
    /// </summary>
    [Parameter]
    public System.Reflection.MethodInfo? Method { get; set; }

    /// <summary>
    /// The instance of the object to run the method on. If the method is static, this can be null
    /// </summary>
    [Parameter]
    public object? ObjectInstance { get; set; }


    /// <summary>
    /// The relative path to the processes page
    /// </summary>
    [Parameter]
    public string? ProcessesPagePath { get; set; }

    /// <summary>
    /// Datastore containing user metadata about methods
    /// </summary>
    [Parameter]
    public IDatastore? Datastore { get; set; }

    internal IReadOnlyCollection<IParameterInput>? ParameterInputs { get; set; }

    internal string? XmlComment { get; set; }

    internal ConcurrentDictionary<string, object?>? ParameterDictionary { get; set; }

    internal string? ResultText { get; set; }

    internal CancellationTokenSource CancellationTokenSource { get; set; } = new CancellationTokenSource();

    private IDictionary<string, ParameterMetadata>? ParameterMetadataDictionary { get; set; }

    private MethodMetadata? MethodMetadata { get; set; }

    /// <summary>
    /// Is run after the parameters have been set
    /// </summary>
    protected override async void OnParametersSet()
    {
        ParameterDictionary = new ConcurrentDictionary<string, object?>();

        Debug.Assert(Method != null, nameof(Method) + " != null");

        if (Datastore == null || Method.DeclaringType == null)
        {
            MethodMetadata = null;
            ParameterMetadataDictionary = null;
        }
        else
        {
            var (method, parameters) = await Datastore.GetMetadata(Method.DeclaringType.Name + Method.Name);
            ParameterMetadataDictionary = parameters?.ToDictionary(x => x.Key, x => x.Value)
                                          ?? new Dictionary<string, ParameterMetadata>();
            MethodMetadata = method;
        }

        var parameterInputsTemp = new List<IParameterInput>();

        foreach (var param in Method.GetParameters())
        {
            var parameterInfo = ParameterExtensions.GetParameterInfo(param);

            parameterInputsTemp.Add(parameterInfo);

            if (param.Name != null)
            {
                if (param.ParameterType == typeof(CancellationToken))
                {//TODO other special cases
                    ParameterDictionary.TryAdd(param.Name, CancellationTokenSource.Token);
                }
                else
                {
                    var defaultValue = param.DefaultValue;
                    if (defaultValue == DBNull.Value)
                    {
                        if (ParameterMetadataDictionary != null &&
                            ParameterMetadataDictionary.TryGetValue(param.Name, out var pm)
                            && pm.MostRecentValueString != null)
                        {
                            var defaultValueString = pm.MostRecentValueString;
                            defaultValue = parameterInfo.ConvertFromString(defaultValueString);
                        }
                        else
                        {
                            defaultValue = param.ParameterType.IsValueType ? Activator.CreateInstance(param.ParameterType) : null;
                        }
                    }

                    ParameterDictionary.TryAdd(param.Name, defaultValue);
                }
            }
        }

        XmlComment = Method.GetXmlDocsSummary();
        ParameterInputs = parameterInputsTemp.ToList();

        this.StateHasChanged();
    }


    internal async void Invoke()
    {
        var dictionary = new ReadOnlyDictionary<string, object?>(
            ParameterDictionary.ToDictionary(x => x.Key, x => x.Value));

        Debug.Assert(Method != null, nameof(Method) + " != null");

        var tasks = new List<Task>();

        if (Datastore != null && Method.DeclaringType != null)// && MethodMetadata != null && ParameterMetadataDictionary != null)
        {
            if (MethodMetadata == null)
            {
                MethodMetadata = new MethodMetadata()
                {
                    ClassAndMethod = Method.DeclaringType.Name + Method.Name
                };
            }
            if(ParameterMetadataDictionary == null)
                ParameterMetadataDictionary = new Dictionary<string, ParameterMetadata>();

            MethodMetadata.LastCalled = DateTime.Now;

            foreach (var (key, value) in dictionary)
            {
                if (!ParameterMetadataDictionary.TryGetValue(key, out var pm))
                {
                    pm = new ParameterMetadata()
                    {
                        PClassAndMethod = Method.DeclaringType.Name + Method.Name,
                        ParameterName = key
                    };
                    ParameterMetadataDictionary.Add(key, pm);
                }

                var newValueString = value?.ToString();

                pm.MostRecentValueString = newValueString;
                if (string.IsNullOrEmpty(pm.PreviousValueStrings))
                {
                    pm.PreviousValueStrings = newValueString;
                }
                else if(!pm.PreviousValueStrings.Split("\r\n").Contains(newValueString))
                    pm.PreviousValueStrings += "\r\n" +  newValueString;
            }

            tasks.Add( Datastore.AddOrUpdate(MethodMetadata, ParameterMetadataDictionary.Values));
        }

        var process = new Process(Method,
            ObjectInstance,
            dictionary,
            CancellationTokenSource);

        //todo log?

        ProcessContext.AddProcess(process);

        process.Run(); //Process will actually run on another thread

        await Task.WhenAll(tasks);

        if(ProcessesPagePath != null)
            NavigationManager.NavigateTo(ProcessesPagePath);
    }
}