//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."

namespace NuixAPI
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface IV1Client
    {
        /// <summary>Retrieves information about Nuix RESTful services</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AboutResponse> AboutAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieves information about Nuix RESTful services</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AboutResponse> AboutAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns asynchronous function statuses</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="activeWindowInSeconds">The time in seconds within which non-queue functions must have been active to be returned. Numbers less than 0 will return all windows.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<AsyncFunctionStatusesResponse> AsyncFunctionsGetAsync(string nuix_auth_token, int? activeWindowInSeconds);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns asynchronous function statuses</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="activeWindowInSeconds">The time in seconds within which non-queue functions must have been active to be returned. Numbers less than 0 will return all windows.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<AsyncFunctionStatusesResponse> AsyncFunctionsGetAsync(string nuix_auth_token, int? activeWindowInSeconds, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the status of an asynchronous function</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="key">Async function key</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionStatusOfobject> AsyncFunctionsGetAsync(string nuix_auth_token, string key);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the status of an asynchronous function</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="key">Async function key</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionStatusOfobject> AsyncFunctionsGetAsync(string nuix_auth_token, string key, System.Threading.CancellationToken cancellationToken);

        /// <summary>Cancels an asynchronous function that is not a processing job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="key">Async function key</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionStatusOfobject> AsyncFunctionsDeleteAsync(string nuix_auth_token, string key);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Cancels an asynchronous function that is not a processing job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="key">Async function key</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionStatusOfobject> AsyncFunctionsDeleteAsync(string nuix_auth_token, string key, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns asynchronous function statuses</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="activeWindowInSeconds">The time in seconds within which non-queue functions must have been active to be returned. Numbers less than 0 will return all windows.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionStatusesResponse> AsyncFunctionsQueueAsync(string nuix_auth_token, int? activeWindowInSeconds);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns asynchronous function statuses</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="activeWindowInSeconds">The time in seconds within which non-queue functions must have been active to be returned. Numbers less than 0 will return all windows.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionStatusesResponse> AsyncFunctionsQueueAsync(string nuix_auth_token, int? activeWindowInSeconds, System.Threading.CancellationToken cancellationToken);

        /// <summary>Log out</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="username">Username associated with the licence</param>
        /// <param name="forceSynchronous">Forces a synchronous logout.  A response code is not returned until logout is complete.</param>
        /// <param name="ignoreCompleted">Ignores functions that have already completed. Defaults to true.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GenericResponse> AuthenticatedUsersAsync(string nuix_auth_token, string username, bool? forceSynchronous, bool? ignoreCompleted);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Log out</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="username">Username associated with the licence</param>
        /// <param name="forceSynchronous">Forces a synchronous logout.  A response code is not returned until logout is complete.</param>
        /// <param name="ignoreCompleted">Ignores functions that have already completed. Defaults to true.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GenericResponse> AuthenticatedUsersAsync(string nuix_auth_token, string username, bool? forceSynchronous, bool? ignoreCompleted, System.Threading.CancellationToken cancellationToken);

        /// <summary>Creates a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="createCaseRequest">Provides options for creating a case</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CaseResponse> CasesPostAsync(string nuix_auth_token, CreateCaseRequest createCaseRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="createCaseRequest">Provides options for creating a case</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CaseResponse> CasesPostAsync(string nuix_auth_token, CreateCaseRequest createCaseRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the top-level information for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="calculateCaseSize">Should size of case on disk be calculated? Defaults to false</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CaseResponse> CasesGetAsync(string nuix_auth_token, string caseId, bool? calculateCaseSize);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the top-level information for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="calculateCaseSize">Should size of case on disk be calculated? Defaults to false</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CaseResponse> CasesGetAsync(string nuix_auth_token, string caseId, bool? calculateCaseSize, System.Threading.CancellationToken cancellationToken);

        /// <summary>Deletes a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="deleteAllDescendants">Delete child cases of a compound case</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CaseDeleteResponse> CasesDeleteAsync(string nuix_auth_token, string caseId, bool? deleteAllDescendants);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="deleteAllDescendants">Delete child cases of a compound case</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CaseDeleteResponse> CasesDeleteAsync(string nuix_auth_token, string caseId, bool? deleteAllDescendants, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the REST cluster with its members</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestCluster> ClusterAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the REST cluster with its members</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestCluster> ClusterAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns all configuration profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ConfigurationProfilesAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all configuration profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ConfigurationProfilesAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns all digest list names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> DigestListsGetAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all digest list names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> DigestListsGetAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Uploads a digest list to a user data directory</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="userDataDir">User data directory</param>
        /// <param name="digestList">digestList</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileUploadResponse> DigestListsPostAsync(string nuix_auth_token, string userDataDir, System.Collections.Generic.IEnumerable<byte[]> digestList);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Uploads a digest list to a user data directory</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="userDataDir">User data directory</param>
        /// <param name="digestList">digestList</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileUploadResponse> DigestListsPostAsync(string nuix_auth_token, string userDataDir, System.Collections.Generic.IEnumerable<byte[]> digestList, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns all fuzzy hash list names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> FuzzyHashListsAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all fuzzy hash list names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> FuzzyHashListsAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns all imaging profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ImagingProfilesGetAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all imaging profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ImagingProfilesGetAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Upload an imaging profile</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="profile">profile</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> ImagingProfilesPostAsync(string nuix_auth_token, FileParameter profile);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Upload an imaging profile</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="profile">profile</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> ImagingProfilesPostAsync(string nuix_auth_token, FileParameter profile, System.Threading.CancellationToken cancellationToken);

        /// <summary>Downloads an imaging profile by name</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="name">name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> ImagingProfilesGetAsync(string nuix_auth_token, string name);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Downloads an imaging profile by name</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="name">name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> ImagingProfilesGetAsync(string nuix_auth_token, string name, System.Threading.CancellationToken cancellationToken);

        /// <summary>Rescans your inventory</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> InventoryPutAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Rescans your inventory</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> InventoryPutAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the digest information for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CaseDigest> InventoryGetAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the digest information for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CaseDigest> InventoryGetAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns all item kinds</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<NuixItemKindResponse>> KindsAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all item kinds</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<NuixItemKindResponse>> KindsAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns a list of available licences</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<LicenseDescription>> LicencesAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns a list of available licences</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<LicenseDescription>> LicencesAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns all metadata profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> MetadataProfilesAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all metadata profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> MetadataProfilesAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns all OCR profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> OcrProfilesGetAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all OCR profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> OcrProfilesGetAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Upload an OCR profile</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="profile">profile</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> OcrProfilesPostAsync(string nuix_auth_token, FileParameter profile);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Upload an OCR profile</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="profile">profile</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> OcrProfilesPostAsync(string nuix_auth_token, FileParameter profile, System.Threading.CancellationToken cancellationToken);

        /// <summary>Downloads an OCR profile by name</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="name">name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> OcrProfilesGetAsync(string nuix_auth_token, string name);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Downloads an OCR profile by name</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="name">name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> OcrProfilesGetAsync(string nuix_auth_token, string name, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns all processing profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ProcessingProfilesGetAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all processing profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ProcessingProfilesGetAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Upload a processing profile</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="profile">profile</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> ProcessingProfilesPostAsync(string nuix_auth_token, FileParameter profile);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Upload a processing profile</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="profile">profile</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> ProcessingProfilesPostAsync(string nuix_auth_token, FileParameter profile, System.Threading.CancellationToken cancellationToken);

        /// <summary>Downloads a processing profile by name</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="name">name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> ProcessingProfilesGetAsync(string nuix_auth_token, string name);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Downloads a processing profile by name</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="name">name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> ProcessingProfilesGetAsync(string nuix_auth_token, string name, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns all production profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ProductionProfilesGetAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all production profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ProductionProfilesGetAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Upload a production profile</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="profile">profile</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> ProductionProfilesPostAsync(string nuix_auth_token, FileParameter profile);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Upload a production profile</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="profile">profile</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> ProductionProfilesPostAsync(string nuix_auth_token, FileParameter profile, System.Threading.CancellationToken cancellationToken);

        /// <summary>Downloads a production profile by name</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="name">name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> ProductionProfilesGetAsync(string nuix_auth_token, string name);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Downloads a production profile by name</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="name">name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> ProductionProfilesGetAsync(string nuix_auth_token, string name, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns all search macros names and expansions</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SearchMacroStructuredResponse> SearchMacrosAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all search macros names and expansions</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SearchMacroStructuredResponse> SearchMacrosAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns all shingle list names and expansions</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ShingleListsAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all shingle list names and expansions</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ShingleListsAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns all item types</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<NuixItemTypeResponse>> TypesAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all item types</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<NuixItemTypeResponse>> TypesAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Retrieves the list of existing user scripts</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> UserScriptsGetAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieves the list of existing user scripts</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> UserScriptsGetAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Executes a user script</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="scriptRequest">The script request body object.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> UserScriptsPutAsync(string nuix_auth_token, UserScriptRequest scriptRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Executes a user script</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="scriptRequest">The script request body object.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> UserScriptsPutAsync(string nuix_auth_token, UserScriptRequest scriptRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns all word list names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> WordListsAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all word list names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> WordListsAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class V1Client : IV1Client
    {
        private string _baseUrl = "localhost:8080/nuix-restful-service/svc";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public V1Client(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>Retrieves information about Nuix RESTful services</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AboutResponse> AboutAsync(string nuix_auth_token)
        {
            return AboutAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieves information about Nuix RESTful services</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AboutResponse> AboutAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/about");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AboutResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AboutResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns asynchronous function statuses</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="activeWindowInSeconds">The time in seconds within which non-queue functions must have been active to be returned. Numbers less than 0 will return all windows.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<AsyncFunctionStatusesResponse> AsyncFunctionsGetAsync(string nuix_auth_token, int? activeWindowInSeconds)
        {
            return AsyncFunctionsGetAsync(nuix_auth_token, activeWindowInSeconds, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns asynchronous function statuses</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="activeWindowInSeconds">The time in seconds within which non-queue functions must have been active to be returned. Numbers less than 0 will return all windows.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<AsyncFunctionStatusesResponse> AsyncFunctionsGetAsync(string nuix_auth_token, int? activeWindowInSeconds, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/asyncFunctions?");
            if (activeWindowInSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("activeWindowInSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(activeWindowInSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionStatusesResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionStatusesResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the status of an asynchronous function</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="key">Async function key</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionStatusOfobject> AsyncFunctionsGetAsync(string nuix_auth_token, string key)
        {
            return AsyncFunctionsGetAsync(nuix_auth_token, key, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the status of an asynchronous function</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="key">Async function key</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionStatusOfobject> AsyncFunctionsGetAsync(string nuix_auth_token, string key, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/asyncFunctions/{key}");
            if (key != null)
                urlBuilder_.Replace("{key}", System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{key}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionStatusOfobject>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionStatusOfobject);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Cancels an asynchronous function that is not a processing job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="key">Async function key</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionStatusOfobject> AsyncFunctionsDeleteAsync(string nuix_auth_token, string key)
        {
            return AsyncFunctionsDeleteAsync(nuix_auth_token, key, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Cancels an asynchronous function that is not a processing job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="key">Async function key</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionStatusOfobject> AsyncFunctionsDeleteAsync(string nuix_auth_token, string key, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/asyncFunctions/{key}");
            if (key != null)
                urlBuilder_.Replace("{key}", System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{key}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionStatusOfobject>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("No Content", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionStatusOfobject);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns asynchronous function statuses</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="activeWindowInSeconds">The time in seconds within which non-queue functions must have been active to be returned. Numbers less than 0 will return all windows.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionStatusesResponse> AsyncFunctionsQueueAsync(string nuix_auth_token, int? activeWindowInSeconds)
        {
            return AsyncFunctionsQueueAsync(nuix_auth_token, activeWindowInSeconds, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns asynchronous function statuses</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="activeWindowInSeconds">The time in seconds within which non-queue functions must have been active to be returned. Numbers less than 0 will return all windows.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionStatusesResponse> AsyncFunctionsQueueAsync(string nuix_auth_token, int? activeWindowInSeconds, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/asyncFunctionsQueue?");
            if (activeWindowInSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("activeWindowInSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(activeWindowInSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionStatusesResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionStatusesResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Log out</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="username">Username associated with the licence</param>
        /// <param name="forceSynchronous">Forces a synchronous logout.  A response code is not returned until logout is complete.</param>
        /// <param name="ignoreCompleted">Ignores functions that have already completed. Defaults to true.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GenericResponse> AuthenticatedUsersAsync(string nuix_auth_token, string username, bool? forceSynchronous, bool? ignoreCompleted)
        {
            return AuthenticatedUsersAsync(nuix_auth_token, username, forceSynchronous, ignoreCompleted, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Log out</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="username">Username associated with the licence</param>
        /// <param name="forceSynchronous">Forces a synchronous logout.  A response code is not returned until logout is complete.</param>
        /// <param name="ignoreCompleted">Ignores functions that have already completed. Defaults to true.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GenericResponse> AuthenticatedUsersAsync(string nuix_auth_token, string username, bool? forceSynchronous, bool? ignoreCompleted, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/authenticatedUsers/{username}?");
            if (username != null)
                urlBuilder_.Replace("{username}", System.Uri.EscapeDataString(ConvertToString(username, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{username}", string.Empty);
            if (forceSynchronous != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("forceSynchronous") + "=").Append(System.Uri.EscapeDataString(ConvertToString(forceSynchronous, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (ignoreCompleted != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("ignoreCompleted") + "=").Append(System.Uri.EscapeDataString(ConvertToString(ignoreCompleted, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GenericResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("No Content", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(GenericResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Creates a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="createCaseRequest">Provides options for creating a case</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CaseResponse> CasesPostAsync(string nuix_auth_token, CreateCaseRequest createCaseRequest)
        {
            return CasesPostAsync(nuix_auth_token, createCaseRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="createCaseRequest">Provides options for creating a case</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CaseResponse> CasesPostAsync(string nuix_auth_token, CreateCaseRequest createCaseRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(createCaseRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CaseResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CaseResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the top-level information for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="calculateCaseSize">Should size of case on disk be calculated? Defaults to false</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CaseResponse> CasesGetAsync(string nuix_auth_token, string caseId, bool? calculateCaseSize)
        {
            return CasesGetAsync(nuix_auth_token, caseId, calculateCaseSize, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the top-level information for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="calculateCaseSize">Should size of case on disk be calculated? Defaults to false</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CaseResponse> CasesGetAsync(string nuix_auth_token, string caseId, bool? calculateCaseSize, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (calculateCaseSize != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("calculateCaseSize") + "=").Append(System.Uri.EscapeDataString(ConvertToString(calculateCaseSize, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CaseResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CaseResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Deletes a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="deleteAllDescendants">Delete child cases of a compound case</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CaseDeleteResponse> CasesDeleteAsync(string nuix_auth_token, string caseId, bool? deleteAllDescendants)
        {
            return CasesDeleteAsync(nuix_auth_token, caseId, deleteAllDescendants, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="deleteAllDescendants">Delete child cases of a compound case</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CaseDeleteResponse> CasesDeleteAsync(string nuix_auth_token, string caseId, bool? deleteAllDescendants, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (deleteAllDescendants != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteAllDescendants") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteAllDescendants, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CaseDeleteResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("No Content", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CaseDeleteResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the REST cluster with its members</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<RestCluster> ClusterAsync(string nuix_auth_token)
        {
            return ClusterAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the REST cluster with its members</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<RestCluster> ClusterAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cluster");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RestCluster>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(RestCluster);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns all configuration profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ConfigurationProfilesAsync(string nuix_auth_token)
        {
            return ConfigurationProfilesAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all configuration profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ConfigurationProfilesAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/configurationProfiles");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns all digest list names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> DigestListsGetAsync(string nuix_auth_token)
        {
            return DigestListsGetAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all digest list names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> DigestListsGetAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/digestLists");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Uploads a digest list to a user data directory</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="userDataDir">User data directory</param>
        /// <param name="digestList">digestList</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileUploadResponse> DigestListsPostAsync(string nuix_auth_token, string userDataDir, System.Collections.Generic.IEnumerable<byte[]> digestList)
        {
            return DigestListsPostAsync(nuix_auth_token, userDataDir, digestList, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Uploads a digest list to a user data directory</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="userDataDir">User data directory</param>
        /// <param name="digestList">digestList</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FileUploadResponse> DigestListsPostAsync(string nuix_auth_token, string userDataDir, System.Collections.Generic.IEnumerable<byte[]> digestList, System.Threading.CancellationToken cancellationToken)
        {
            if (digestList == null)
                throw new System.ArgumentNullException("digestList");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/digestLists?");
            if (userDataDir != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("userDataDir") + "=").Append(System.Uri.EscapeDataString(ConvertToString(userDataDir, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            foreach (var item_ in digestList) { urlBuilder_.Append(System.Uri.EscapeDataString("digestList") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json;charset=utf-8");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FileUploadResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileUploadResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns all fuzzy hash list names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> FuzzyHashListsAsync(string nuix_auth_token)
        {
            return FuzzyHashListsAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all fuzzy hash list names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> FuzzyHashListsAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/fuzzyHashLists");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns all imaging profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ImagingProfilesGetAsync(string nuix_auth_token)
        {
            return ImagingProfilesGetAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all imaging profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ImagingProfilesGetAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/imagingProfiles");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Upload an imaging profile</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="profile">profile</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<object> ImagingProfilesPostAsync(string nuix_auth_token, FileParameter profile)
        {
            return ImagingProfilesPostAsync(nuix_auth_token, profile, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Upload an imaging profile</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="profile">profile</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<object> ImagingProfilesPostAsync(string nuix_auth_token, FileParameter profile, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/imagingProfiles");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (profile == null)
                        throw new System.ArgumentNullException("profile");
                    else
                    {
                        var content_profile_ = new System.Net.Http.StreamContent(profile.Data);
                        if (!string.IsNullOrEmpty(profile.ContentType))
                            content_profile_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(profile.ContentType);
                        content_.Add(content_profile_, "profile", profile.FileName ?? "profile");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<object>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(object);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Downloads an imaging profile by name</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="name">name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<string> ImagingProfilesGetAsync(string nuix_auth_token, string name)
        {
            return ImagingProfilesGetAsync(nuix_auth_token, name, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Downloads an imaging profile by name</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="name">name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> ImagingProfilesGetAsync(string nuix_auth_token, string name, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/imagingProfiles/{name}");
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(string);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Rescans your inventory</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> InventoryPutAsync(string nuix_auth_token)
        {
            return InventoryPutAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Rescans your inventory</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> InventoryPutAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/inventory");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "*/*");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the digest information for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CaseDigest> InventoryGetAsync(string nuix_auth_token, string caseId)
        {
            return InventoryGetAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the digest information for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CaseDigest> InventoryGetAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/inventory/{caseId}");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CaseDigest>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CaseDigest);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns all item kinds</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<NuixItemKindResponse>> KindsAsync(string nuix_auth_token)
        {
            return KindsAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all item kinds</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<NuixItemKindResponse>> KindsAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/kinds");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<NuixItemKindResponse>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<NuixItemKindResponse>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns a list of available licences</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<LicenseDescription>> LicencesAsync(string nuix_auth_token)
        {
            return LicencesAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns a list of available licences</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<LicenseDescription>> LicencesAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/licences");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<LicenseDescription>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<LicenseDescription>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns all metadata profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> MetadataProfilesAsync(string nuix_auth_token)
        {
            return MetadataProfilesAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all metadata profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> MetadataProfilesAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/metadataProfiles");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns all OCR profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> OcrProfilesGetAsync(string nuix_auth_token)
        {
            return OcrProfilesGetAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all OCR profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> OcrProfilesGetAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/ocrProfiles");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Upload an OCR profile</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="profile">profile</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<object> OcrProfilesPostAsync(string nuix_auth_token, FileParameter profile)
        {
            return OcrProfilesPostAsync(nuix_auth_token, profile, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Upload an OCR profile</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="profile">profile</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<object> OcrProfilesPostAsync(string nuix_auth_token, FileParameter profile, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/ocrProfiles");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (profile == null)
                        throw new System.ArgumentNullException("profile");
                    else
                    {
                        var content_profile_ = new System.Net.Http.StreamContent(profile.Data);
                        if (!string.IsNullOrEmpty(profile.ContentType))
                            content_profile_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(profile.ContentType);
                        content_.Add(content_profile_, "profile", profile.FileName ?? "profile");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<object>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(object);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Downloads an OCR profile by name</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="name">name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<string> OcrProfilesGetAsync(string nuix_auth_token, string name)
        {
            return OcrProfilesGetAsync(nuix_auth_token, name, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Downloads an OCR profile by name</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="name">name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> OcrProfilesGetAsync(string nuix_auth_token, string name, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/ocrProfiles/{name}");
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(string);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns all processing profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ProcessingProfilesGetAsync(string nuix_auth_token)
        {
            return ProcessingProfilesGetAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all processing profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ProcessingProfilesGetAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/processingProfiles");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Upload a processing profile</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="profile">profile</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<object> ProcessingProfilesPostAsync(string nuix_auth_token, FileParameter profile)
        {
            return ProcessingProfilesPostAsync(nuix_auth_token, profile, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Upload a processing profile</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="profile">profile</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<object> ProcessingProfilesPostAsync(string nuix_auth_token, FileParameter profile, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/processingProfiles");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (profile == null)
                        throw new System.ArgumentNullException("profile");
                    else
                    {
                        var content_profile_ = new System.Net.Http.StreamContent(profile.Data);
                        if (!string.IsNullOrEmpty(profile.ContentType))
                            content_profile_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(profile.ContentType);
                        content_.Add(content_profile_, "profile", profile.FileName ?? "profile");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<object>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(object);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Downloads a processing profile by name</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="name">name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<string> ProcessingProfilesGetAsync(string nuix_auth_token, string name)
        {
            return ProcessingProfilesGetAsync(nuix_auth_token, name, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Downloads a processing profile by name</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="name">name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> ProcessingProfilesGetAsync(string nuix_auth_token, string name, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/processingProfiles/{name}");
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(string);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns all production profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ProductionProfilesGetAsync(string nuix_auth_token)
        {
            return ProductionProfilesGetAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all production profile names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ProductionProfilesGetAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/productionProfiles");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Upload a production profile</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="profile">profile</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<object> ProductionProfilesPostAsync(string nuix_auth_token, FileParameter profile)
        {
            return ProductionProfilesPostAsync(nuix_auth_token, profile, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Upload a production profile</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="profile">profile</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<object> ProductionProfilesPostAsync(string nuix_auth_token, FileParameter profile, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/productionProfiles");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (profile == null)
                        throw new System.ArgumentNullException("profile");
                    else
                    {
                        var content_profile_ = new System.Net.Http.StreamContent(profile.Data);
                        if (!string.IsNullOrEmpty(profile.ContentType))
                            content_profile_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(profile.ContentType);
                        content_.Add(content_profile_, "profile", profile.FileName ?? "profile");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<object>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(object);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Downloads a production profile by name</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="name">name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<string> ProductionProfilesGetAsync(string nuix_auth_token, string name)
        {
            return ProductionProfilesGetAsync(nuix_auth_token, name, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Downloads a production profile by name</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="name">name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> ProductionProfilesGetAsync(string nuix_auth_token, string name, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/productionProfiles/{name}");
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(string);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns all search macros names and expansions</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SearchMacroStructuredResponse> SearchMacrosAsync(string nuix_auth_token)
        {
            return SearchMacrosAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all search macros names and expansions</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SearchMacroStructuredResponse> SearchMacrosAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/searchMacros");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SearchMacroStructuredResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SearchMacroStructuredResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns all shingle list names and expansions</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ShingleListsAsync(string nuix_auth_token)
        {
            return ShingleListsAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all shingle list names and expansions</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ShingleListsAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/shingleLists");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns all item types</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<NuixItemTypeResponse>> TypesAsync(string nuix_auth_token)
        {
            return TypesAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all item types</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<NuixItemTypeResponse>> TypesAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/types");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<NuixItemTypeResponse>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<NuixItemTypeResponse>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Retrieves the list of existing user scripts</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> UserScriptsGetAsync(string nuix_auth_token)
        {
            return UserScriptsGetAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Retrieves the list of existing user scripts</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> UserScriptsGetAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/userScripts");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Executes a user script</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="scriptRequest">The script request body object.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<object> UserScriptsPutAsync(string nuix_auth_token, UserScriptRequest scriptRequest)
        {
            return UserScriptsPutAsync(nuix_auth_token, scriptRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Executes a user script</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="scriptRequest">The script request body object.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<object> UserScriptsPutAsync(string nuix_auth_token, UserScriptRequest scriptRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/userScripts");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(scriptRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<object>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(object);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns all word list names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> WordListsAsync(string nuix_auth_token)
        {
            return WordListsAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all word list names</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> WordListsAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/wordLists");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface IAsyncFunctionSingleItemQueueClient
    {
        /// <summary>Set a new order for the single operation AsyncFunction queue</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="reorderRequest">reorderRequest</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task OrderAsync(string nuix_auth_token, AsyncFunctionSingleItemQueueReorderRequest reorderRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Set a new order for the single operation AsyncFunction queue</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="reorderRequest">reorderRequest</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task OrderAsync(string nuix_auth_token, AsyncFunctionSingleItemQueueReorderRequest reorderRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Handles pause and resume operations on the single operation AsyncFunction queue</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="asyncFunctionSinqleItemQueueStatus">asyncFunctionSinqleItemQueueStatus</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PauseStatusAsync(string nuix_auth_token, AsyncFunctionSingleItemQueueStatus asyncFunctionSinqleItemQueueStatus);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Handles pause and resume operations on the single operation AsyncFunction queue</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="asyncFunctionSinqleItemQueueStatus">asyncFunctionSinqleItemQueueStatus</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PauseStatusAsync(string nuix_auth_token, AsyncFunctionSingleItemQueueStatus asyncFunctionSinqleItemQueueStatus, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class AsyncFunctionSingleItemQueueClient : IAsyncFunctionSingleItemQueueClient
    {
        private string _baseUrl = "localhost:8080/nuix-restful-service/svc";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public AsyncFunctionSingleItemQueueClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>Set a new order for the single operation AsyncFunction queue</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="reorderRequest">reorderRequest</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task OrderAsync(string nuix_auth_token, AsyncFunctionSingleItemQueueReorderRequest reorderRequest)
        {
            return OrderAsync(nuix_auth_token, reorderRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Set a new order for the single operation AsyncFunction queue</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="reorderRequest">reorderRequest</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task OrderAsync(string nuix_auth_token, AsyncFunctionSingleItemQueueReorderRequest reorderRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/asyncFunctionSingleItemQueue/order");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(reorderRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "201")
                        {
                            return;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Handles pause and resume operations on the single operation AsyncFunction queue</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="asyncFunctionSinqleItemQueueStatus">asyncFunctionSinqleItemQueueStatus</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task PauseStatusAsync(string nuix_auth_token, AsyncFunctionSingleItemQueueStatus asyncFunctionSinqleItemQueueStatus)
        {
            return PauseStatusAsync(nuix_auth_token, asyncFunctionSinqleItemQueueStatus, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Handles pause and resume operations on the single operation AsyncFunction queue</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="asyncFunctionSinqleItemQueueStatus">asyncFunctionSinqleItemQueueStatus</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task PauseStatusAsync(string nuix_auth_token, AsyncFunctionSingleItemQueueStatus asyncFunctionSinqleItemQueueStatus, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/asyncFunctionSingleItemQueue/pauseStatus");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(asyncFunctionSinqleItemQueueStatus, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "201")
                        {
                            return;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface IAsyncFunctionsClient
    {
        /// <summary>Cancels a processing job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="key">Async function key</param>
        /// <param name="canResume">Can this processing job be resumed</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionStatusOfobject> ProcessingJobsAsync(string nuix_auth_token, string key, bool? canResume);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Cancels a processing job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="key">Async function key</param>
        /// <param name="canResume">Can this processing job be resumed</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionStatusOfobject> ProcessingJobsAsync(string nuix_auth_token, string key, bool? canResume, System.Threading.CancellationToken cancellationToken);

        /// <summary>Adds remote workers to a distributed function.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="key">Async function key</param>
        /// <param name="addRemoteWorkersRequest">Agent/workers to add</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<AddRemoteWorkersResponse>> RemoteWorkersAsync(string nuix_auth_token, string key, System.Collections.Generic.IEnumerable<AddRemoteWorkersRequest> addRemoteWorkersRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Adds remote workers to a distributed function.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="key">Async function key</param>
        /// <param name="addRemoteWorkersRequest">Agent/workers to add</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<AddRemoteWorkersResponse>> RemoteWorkersAsync(string nuix_auth_token, string key, System.Collections.Generic.IEnumerable<AddRemoteWorkersRequest> addRemoteWorkersRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Asynchronously returns statistics for families of top-level items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">Query list</param>
        /// <param name="caseId">Case id</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> FamilyStatisticsAsync(string nuix_auth_token, DeduplicationQueryListRequest request, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Asynchronously returns statistics for families of top-level items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">Query list</param>
        /// <param name="caseId">Case id</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> FamilyStatisticsAsync(string nuix_auth_token, DeduplicationQueryListRequest request, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>asyncSearchNative</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">caseId</param>
        /// <param name="request">request</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> SearchAsync(string nuix_auth_token, string caseId, SearchNativeRequest request);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>asyncSearchNative</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">caseId</param>
        /// <param name="request">request</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> SearchAsync(string nuix_auth_token, string caseId, SearchNativeRequest request, System.Threading.CancellationToken cancellationToken);

        /// <summary>Asynchronously indicates word usage and frequency in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="wordCountsRequest">Query list</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> WordCountsAsync(string nuix_auth_token, WordCountsRequest wordCountsRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Asynchronously indicates word usage and frequency in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="wordCountsRequest">Query list</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> WordCountsAsync(string nuix_auth_token, WordCountsRequest wordCountsRequest, string caseId, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class AsyncFunctionsClient : IAsyncFunctionsClient
    {
        private string _baseUrl = "localhost:8080/nuix-restful-service/svc";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public AsyncFunctionsClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>Cancels a processing job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="key">Async function key</param>
        /// <param name="canResume">Can this processing job be resumed</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionStatusOfobject> ProcessingJobsAsync(string nuix_auth_token, string key, bool? canResume)
        {
            return ProcessingJobsAsync(nuix_auth_token, key, canResume, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Cancels a processing job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="key">Async function key</param>
        /// <param name="canResume">Can this processing job be resumed</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionStatusOfobject> ProcessingJobsAsync(string nuix_auth_token, string key, bool? canResume, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/asyncFunctions/processingJobs/{key}?");
            if (key != null)
                urlBuilder_.Replace("{key}", System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{key}", string.Empty);
            if (canResume != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("canResume") + "=").Append(System.Uri.EscapeDataString(ConvertToString(canResume, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionStatusOfobject>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("No Content", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionStatusOfobject);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Adds remote workers to a distributed function.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="key">Async function key</param>
        /// <param name="addRemoteWorkersRequest">Agent/workers to add</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<AddRemoteWorkersResponse>> RemoteWorkersAsync(string nuix_auth_token, string key, System.Collections.Generic.IEnumerable<AddRemoteWorkersRequest> addRemoteWorkersRequest)
        {
            return RemoteWorkersAsync(nuix_auth_token, key, addRemoteWorkersRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Adds remote workers to a distributed function.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="key">Async function key</param>
        /// <param name="addRemoteWorkersRequest">Agent/workers to add</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<AddRemoteWorkersResponse>> RemoteWorkersAsync(string nuix_auth_token, string key, System.Collections.Generic.IEnumerable<AddRemoteWorkersRequest> addRemoteWorkersRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/asyncFunctions/{key}/remoteWorkers");
            if (key != null)
                urlBuilder_.Replace("{key}", System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{key}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(addRemoteWorkersRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<AddRemoteWorkersResponse>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<AddRemoteWorkersResponse>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Asynchronously returns statistics for families of top-level items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">Query list</param>
        /// <param name="caseId">Case id</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> FamilyStatisticsAsync(string nuix_auth_token, DeduplicationQueryListRequest request, string caseId)
        {
            return FamilyStatisticsAsync(nuix_auth_token, request, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Asynchronously returns statistics for families of top-level items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">Query list</param>
        /// <param name="caseId">Case id</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> FamilyStatisticsAsync(string nuix_auth_token, DeduplicationQueryListRequest request, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/asyncFunctions/familyStatistics");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>asyncSearchNative</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">caseId</param>
        /// <param name="request">request</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> SearchAsync(string nuix_auth_token, string caseId, SearchNativeRequest request)
        {
            return SearchAsync(nuix_auth_token, caseId, request, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>asyncSearchNative</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">caseId</param>
        /// <param name="request">request</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> SearchAsync(string nuix_auth_token, string caseId, SearchNativeRequest request, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/asyncFunctions/search");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Asynchronously indicates word usage and frequency in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="wordCountsRequest">Query list</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> WordCountsAsync(string nuix_auth_token, WordCountsRequest wordCountsRequest, string caseId)
        {
            return WordCountsAsync(nuix_auth_token, wordCountsRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Asynchronously indicates word usage and frequency in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="wordCountsRequest">Query list</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> WordCountsAsync(string nuix_auth_token, WordCountsRequest wordCountsRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/asyncFunctions/wordCounts");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(wordCountsRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface IAuthenticatedUsersClient
    {
        /// <summary>Log in and acquire a licence</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="authenticationRequest">The authentication request body object</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuthenticationResponse> LoginAsync(string nuix_auth_token, NumAuthenticationRequest authenticationRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Log in and acquire a licence</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="authenticationRequest">The authentication request body object</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuthenticationResponse> LoginAsync(string nuix_auth_token, NumAuthenticationRequest authenticationRequest, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class AuthenticatedUsersClient : IAuthenticatedUsersClient
    {
        private string _baseUrl = "localhost:8080/nuix-restful-service/svc";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public AuthenticatedUsersClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>Log in and acquire a licence</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="authenticationRequest">The authentication request body object</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AuthenticationResponse> LoginAsync(string nuix_auth_token, NumAuthenticationRequest authenticationRequest)
        {
            return LoginAsync(nuix_auth_token, authenticationRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Log in and acquire a licence</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="authenticationRequest">The authentication request body object</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AuthenticationResponse> LoginAsync(string nuix_auth_token, NumAuthenticationRequest authenticationRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/authenticatedUsers/login");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(authenticationRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AuthenticationResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AuthenticationResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface ICasesClient
    {
        /// <summary>Deletes all audit reports and audit verification files for a specified case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task AuditFilesAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes all audit reports and audit verification files for a specified case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task AuditFilesAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns an audit report file</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task AuditReportFileAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns an audit report file</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task AuditReportFileAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns total audit sizes for items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">Query list</param>
        /// <param name="caseId">Case id</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ItemSizeResponse>> AuditSizesAsync(string nuix_auth_token, DeduplicationQueryListRequest request, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns total audit sizes for items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">Query list</param>
        /// <param name="caseId">Case id</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ItemSizeResponse>> AuditSizesAsync(string nuix_auth_token, DeduplicationQueryListRequest request, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the audit status for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuditStatus> AuditStatusAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the audit status for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AuditStatus> AuditStatusAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Uploads an audit verification file</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="uploadFile">uploadFile</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task AuditVerificationFileAsync(string nuix_auth_token, string caseId, FileParameter uploadFile);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Uploads an audit verification file</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="uploadFile">uploadFile</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task AuditVerificationFileAsync(string nuix_auth_token, string caseId, FileParameter uploadFile, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns batches associated with a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<BatchLoadDetailsResponse>> BatchesAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns batches associated with a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<BatchLoadDetailsResponse>> BatchesAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Generate a count report and optionally tag items.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">caseId</param>
        /// <param name="bulkSearcherRequest">bulkSearcherRequest</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> BulkSearchersAsync(string nuix_auth_token, string caseId, BulkSearcherRequest bulkSearcherRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Generate a count report and optionally tag items.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">caseId</param>
        /// <param name="bulkSearcherRequest">bulkSearcherRequest</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> BulkSearchersAsync(string nuix_auth_token, string caseId, BulkSearcherRequest bulkSearcherRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Case functions</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Anonymous>> CaseFunctionsGetAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Case functions</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Anonymous>> CaseFunctionsGetAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Perform a function against a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="caseModification">Case modification request</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> CaseFunctionsPostAsync(string nuix_auth_token, string caseId, CaseModification caseModification);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Perform a function against a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="caseModification">Case modification request</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> CaseFunctionsPostAsync(string nuix_auth_token, string caseId, CaseModification caseModification, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns a list of child cases for a compound case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="calculateCaseSize">Should size of each child case on disk be calculated? Defaults to false</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CaseResponse>> ChildCasesGetAsync(string nuix_auth_token, string caseId, bool? calculateCaseSize);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns a list of child cases for a compound case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="calculateCaseSize">Should size of each child case on disk be calculated? Defaults to false</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CaseResponse>> ChildCasesGetAsync(string nuix_auth_token, string caseId, bool? calculateCaseSize, System.Threading.CancellationToken cancellationToken);

        /// <summary>Adds child cases to a compound case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="childCaseIds">Case IDs for the child cases</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ChildCasesPostAsync(string nuix_auth_token, string caseId, System.Collections.Generic.IEnumerable<string> childCaseIds);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Adds child cases to a compound case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="childCaseIds">Case IDs for the child cases</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ChildCasesPostAsync(string nuix_auth_token, string caseId, System.Collections.Generic.IEnumerable<string> childCaseIds, System.Threading.CancellationToken cancellationToken);

        /// <summary>Adds a child case to a compound case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="childCaseId">Case ID for the child case</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ChildCasesPutAsync(string nuix_auth_token, string caseId, string childCaseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Adds a child case to a compound case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="childCaseId">Case ID for the child case</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ChildCasesPutAsync(string nuix_auth_token, string caseId, string childCaseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Closes a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GenericResponse> CloseAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Closes a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GenericResponse> CloseAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the cluster runs for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ClusterRunResponse>> ClusterRunsGetAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the cluster runs for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ClusterRunResponse>> ClusterRunsGetAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Creates a cluster run based on the query provided</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="clusterRunRequest">Request Body</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ClusterRunsPostAsync(string nuix_auth_token, ClusterRunRequest clusterRunRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates a cluster run based on the query provided</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="clusterRunRequest">Request Body</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ClusterRunsPostAsync(string nuix_auth_token, ClusterRunRequest clusterRunRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Delete a cluster run</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="clusterRunName">Cluster run name</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ClusterRunsDeleteAsync(string nuix_auth_token, string caseId, string clusterRunName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a cluster run</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="clusterRunName">Cluster run name</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ClusterRunsDeleteAsync(string nuix_auth_token, string caseId, string clusterRunName, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the total number of items in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="query">Query items that should be included. If a query is not supplied it defaults to an empty string, which returns everything.</param>
        /// <param name="deduplication">How the deduplication is applied. None returns all items matching the query including duplicates. Other options return deduplicated items based on the deduplication method used.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CountResponse> CountGetAsync(string nuix_auth_token, string caseId, string query, Deduplication? deduplication);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the total number of items in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="query">Query items that should be included. If a query is not supplied it defaults to an empty string, which returns everything.</param>
        /// <param name="deduplication">How the deduplication is applied. None returns all items matching the query including duplicates. Other options return deduplicated items based on the deduplication method used.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CountResponse> CountGetAsync(string nuix_auth_token, string caseId, string query, Deduplication? deduplication, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the number of items associated with a case query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="countRequest">Identifies what items should be returned.  If a query is not supplied it defaults to an empty string, which returns all items.</param>
        /// <param name="deduplication">How the deduplication is applied. None returns all items matching the query including duplicates. Other options return deduplicated items based on the deduplication method used.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CountResponse> CountPostAsync(string nuix_auth_token, string caseId, CountRequest countRequest, Deduplication2? deduplication);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the number of items associated with a case query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="countRequest">Identifies what items should be returned.  If a query is not supplied it defaults to an empty string, which returns all items.</param>
        /// <param name="deduplication">How the deduplication is applied. None returns all items matching the query including duplicates. Other options return deduplicated items based on the deduplication method used.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CountResponse> CountPostAsync(string nuix_auth_token, string caseId, CountRequest countRequest, Deduplication2? deduplication, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the set of custodians for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> CustodiansAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the set of custodians for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> CustodiansAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the set of communication domains in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="addressType">The type of contact address</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> DomainsAsync(string nuix_auth_token, string caseId, AddressType? addressType);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the set of communication domains in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="addressType">The type of contact address</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> DomainsAsync(string nuix_auth_token, string caseId, AddressType? addressType, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the set of entity types for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> EntityTypesAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the set of entity types for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> EntityTypesAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Ingests a new repository and/or supported containers into a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, repository, and container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> EvidenceAsync(string nuix_auth_token, BulkIngestionRequest ingestionRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new repository and/or supported containers into a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, repository, and container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> EvidenceAsync(string nuix_auth_token, BulkIngestionRequest ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Excludes items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="exclusionRequest">The exclusion request body object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ExcludedItemsAsync(string nuix_auth_token, string caseId, BulkExclusionRequest exclusionRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Excludes items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="exclusionRequest">The exclusion request body object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ExcludedItemsAsync(string nuix_auth_token, string caseId, BulkExclusionRequest exclusionRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns exclusions for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ExclusionsAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns exclusions for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ExclusionsAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Exports production sets and items from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="exportRequest">The export request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ExportAsync(string nuix_auth_token, ExportRequest exportRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Exports production sets and items from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="exportRequest">The export request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ExportAsync(string nuix_auth_token, ExportRequest exportRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns statistics for families of top-level items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">Query list</param>
        /// <param name="caseId">Case id</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<FamilyStatisticsResponse>> FamilyStatisticsAsync(string nuix_auth_token, DeduplicationQueryListRequest request, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns statistics for families of top-level items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">Query list</param>
        /// <param name="caseId">Case id</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<FamilyStatisticsResponse>> FamilyStatisticsAsync(string nuix_auth_token, DeduplicationQueryListRequest request, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns total file sizes for items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">Query list</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ItemSizeResponse>> FileSizesAsync(string nuix_auth_token, DeduplicationQueryListRequest request, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns total file sizes for items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">Query list</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ItemSizeResponse>> FileSizesAsync(string nuix_auth_token, DeduplicationQueryListRequest request, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns history events for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="type">Filters the type of history event returned.  If not specified, all events are returned.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CaseHistoryEventResponse>> HistoryAsync(string nuix_auth_token, string caseId, Type? type);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns history events for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="type">Filters the type of history event returned.  If not specified, all events are returned.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CaseHistoryEventResponse>> HistoryAsync(string nuix_auth_token, string caseId, Type? type, System.Threading.CancellationToken cancellationToken);

        /// <summary>Includes items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="inclusionRequest">The inclusion request body object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> IncludedItemsAsync(string nuix_auth_token, string caseId, BulkInclusionRequest inclusionRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Includes items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="inclusionRequest">The inclusion request body object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> IncludedItemsAsync(string nuix_auth_token, string caseId, BulkInclusionRequest inclusionRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the investigation time zone for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<InvestigatorTimeZoneResponse> InvestigatorTimeZoneGetAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the investigation time zone for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<InvestigatorTimeZoneResponse> InvestigatorTimeZoneGetAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Sets the investigation time zone for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="timezoneRequest">The requested time zone</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task InvestigatorTimeZonePutAsync(string nuix_auth_token, string caseId, TimezoneRequest timezoneRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Sets the investigation time zone for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="timezoneRequest">The requested time zone</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task InvestigatorTimeZonePutAsync(string nuix_auth_token, string caseId, TimezoneRequest timezoneRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Streams an item binary from a case if it is available</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ItemBinariesGetAsync(string nuix_auth_token, string caseId, string itemGuid);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Streams an item binary from a case if it is available</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ItemBinariesGetAsync(string nuix_auth_token, string caseId, string itemGuid, System.Threading.CancellationToken cancellationToken);

        /// <summary>Streams an item binary from a case if it is available</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ItemBinariesHeadAsync(string nuix_auth_token, string caseId, string itemGuid);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Streams an item binary from a case if it is available</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ItemBinariesHeadAsync(string nuix_auth_token, string caseId, string itemGuid, System.Threading.CancellationToken cancellationToken);

        /// <summary>Applies custom metadata to items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="bulkItemCustomMetadataRequest">bulkItemCustomMetadataRequest</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ApplyCustomMetadataResponse> ItemCustomMetadataPostAsync(string nuix_auth_token, string caseId, BulkItemCustomMetadataRequest bulkItemCustomMetadataRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Applies custom metadata to items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="bulkItemCustomMetadataRequest">bulkItemCustomMetadataRequest</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ApplyCustomMetadataResponse> ItemCustomMetadataPostAsync(string nuix_auth_token, string caseId, BulkItemCustomMetadataRequest bulkItemCustomMetadataRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Removes custom metadata on items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="bulkRequest">bulkRequest</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ItemCustomMetadataDeleteAsync(string nuix_auth_token, string caseId, BulkItemCustomMetadataDeleteRequest bulkRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Removes custom metadata on items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="bulkRequest">bulkRequest</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ItemCustomMetadataDeleteAsync(string nuix_auth_token, string caseId, BulkItemCustomMetadataDeleteRequest bulkRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns a list of values for the specified property.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="propertyName">Name of the property to retrieve values for</param>
        /// <param name="itemPropertiesRequest">The item property request body</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ItemPropertiesAsync(string nuix_auth_token, string caseId, string propertyName, ItemPropertiesRequest itemPropertiesRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns a list of values for the specified property.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="propertyName">Name of the property to retrieve values for</param>
        /// <param name="itemPropertiesRequest">The item property request body</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ItemPropertiesAsync(string nuix_auth_token, string caseId, string propertyName, ItemPropertiesRequest itemPropertiesRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns item sets associated with a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ItemSetResponse>> ItemSetsGetAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns item sets associated with a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ItemSetResponse>> ItemSetsGetAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Creates an item set within a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetRequest">The item set creation request body</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ItemSetsPostAsync(string nuix_auth_token, string caseId, ItemSetRequest itemSetRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates an item set within a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetRequest">The item set creation request body</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ItemSetsPostAsync(string nuix_auth_token, string caseId, ItemSetRequest itemSetRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns details for an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ItemSetResponse> ItemSetsGetAsync(string nuix_auth_token, string caseId, string itemSetName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns details for an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ItemSetResponse> ItemSetsGetAsync(string nuix_auth_token, string caseId, string itemSetName, System.Threading.CancellationToken cancellationToken);

        /// <summary>Renames an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="itemSetNameChangeRequest">Item set name change request</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ItemSetsPutAsync(string nuix_auth_token, string caseId, string itemSetName, ItemSetNameChangeRequest itemSetNameChangeRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Renames an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="itemSetNameChangeRequest">Item set name change request</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ItemSetsPutAsync(string nuix_auth_token, string caseId, string itemSetName, ItemSetNameChangeRequest itemSetNameChangeRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Deletes an item set from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GenericResponse> ItemSetsDeleteAsync(string nuix_auth_token, string caseId, string itemSetName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes an item set from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GenericResponse> ItemSetsDeleteAsync(string nuix_auth_token, string caseId, string itemSetName, System.Threading.CancellationToken cancellationToken);

        /// <summary>Calculates the number of shingles associated with a case's items</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="shinglesRequest">The items shingles request body</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ItemShinglesAsync(string nuix_auth_token, string caseId, ItemsShinglesRequest shinglesRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Calculates the number of shingles associated with a case's items</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="shinglesRequest">The items shingles request body</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ItemShinglesAsync(string nuix_auth_token, string caseId, ItemsShinglesRequest shinglesRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Compute total sizes for items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="itemSizeRequest">Query list</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ItemSizesAsync(string nuix_auth_token, ItemSizesRequest itemSizeRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Compute total sizes for items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="itemSizeRequest">Query list</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ItemSizesAsync(string nuix_auth_token, ItemSizesRequest itemSizeRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns item kinds and types for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="includeCounts">Include count totals for the types</param>
        /// <param name="query">Query items that should be included. If a query is not supplied it defaults to an empty string, which returns all items.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<KindTypeResponse>> ItemTypesAsync(string nuix_auth_token, string caseId, bool? includeCounts, string query);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns item kinds and types for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="includeCounts">Include count totals for the types</param>
        /// <param name="query">Query items that should be included. If a query is not supplied it defaults to an empty string, which returns all items.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<KindTypeResponse>> ItemTypesAsync(string nuix_auth_token, string caseId, bool? includeCounts, string query, System.Threading.CancellationToken cancellationToken);

        /// <summary>Reloads items from source based on a query in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor settings and query</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ItemsPutAsync(string nuix_auth_token, ReloadItemsIngestionRequest ingestionRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reloads items from source based on a query in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor settings and query</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ItemsPutAsync(string nuix_auth_token, ReloadItemsIngestionRequest ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns information for a specific item in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="field">List of fields associated with this item</param>
        /// <param name="property">List of properties associated with this item</param>
        /// <param name="metadataProfile">Metadata profile name. Needed to get custom metadata.</param>
        /// <param name="entities">List of entity names to include in response (e.g. company,email</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> ItemsGetAsync(string nuix_auth_token, string caseId, string itemGuid, System.Collections.Generic.IEnumerable<string> field, System.Collections.Generic.IEnumerable<string> property, string metadataProfile, System.Collections.Generic.IEnumerable<string> entities);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns information for a specific item in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="field">List of fields associated with this item</param>
        /// <param name="property">List of properties associated with this item</param>
        /// <param name="metadataProfile">Metadata profile name. Needed to get custom metadata.</param>
        /// <param name="entities">List of entity names to include in response (e.g. company,email</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> ItemsGetAsync(string nuix_auth_token, string caseId, string itemGuid, System.Collections.Generic.IEnumerable<string> field, System.Collections.Generic.IEnumerable<string> property, string metadataProfile, System.Collections.Generic.IEnumerable<string> entities, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns a list of keystore files available for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> KeyStoresGetAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns a list of keystore files available for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> KeyStoresGetAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Adds a keystore to a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="keystoreFile">The keystore file being added to the case</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Success> KeyStoresPostAsync(string nuix_auth_token, string caseId, FileParameter keystoreFile);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Adds a keystore to a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="keystoreFile">The keystore file being added to the case</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Success> KeyStoresPostAsync(string nuix_auth_token, string caseId, FileParameter keystoreFile, System.Threading.CancellationToken cancellationToken);

        /// <summary>Deletes the requested keystore from the case's keystore directory</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="fileToDeleteRegex">fileToDeleteRegex</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Success> KeyStoresDeleteAsync(string nuix_auth_token, string caseId, string fileToDeleteRegex);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes the requested keystore from the case's keystore directory</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="fileToDeleteRegex">fileToDeleteRegex</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Success> KeyStoresDeleteAsync(string nuix_auth_token, string caseId, string fileToDeleteRegex, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns all languages found in the case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="includeItemCounts">Include counts for the languages</param>
        /// <param name="countScopingQuery">Scope the counts to a provided query when includeItemCounts=true</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<LanguageResponse>> LanguagesAsync(string nuix_auth_token, string caseId, bool? includeItemCounts, string countScopingQuery);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all languages found in the case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="includeItemCounts">Include counts for the languages</param>
        /// <param name="countScopingQuery">Scope the counts to a provided query when includeItemCounts=true</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<LanguageResponse>> LanguagesAsync(string nuix_auth_token, string caseId, bool? includeItemCounts, string countScopingQuery, System.Threading.CancellationToken cancellationToken);

        /// <summary>Gets all MarkupSets for the given case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<MarkupSet>> MarkupSetGetAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Gets all MarkupSets for the given case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<MarkupSet>> MarkupSetGetAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Creates a markup set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="markupSetName">The name of the markup set</param>
        /// <param name="markupSetRequest">The request body object</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<MarkupSet> MarkupSetPostAsync(string nuix_auth_token, string caseId, string markupSetName, MarkupSetRequest markupSetRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates a markup set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="markupSetName">The name of the markup set</param>
        /// <param name="markupSetRequest">The request body object</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<MarkupSet> MarkupSetPostAsync(string nuix_auth_token, string caseId, string markupSetName, MarkupSetRequest markupSetRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Updates a markup set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="markupSetName">The name of the markup set</param>
        /// <param name="markupSetRequest">The request body object</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<MarkupSet> MarkupSetPutAsync(string nuix_auth_token, string caseId, string markupSetName, MarkupSetRequest markupSetRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Updates a markup set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="markupSetName">The name of the markup set</param>
        /// <param name="markupSetRequest">The request body object</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<MarkupSet> MarkupSetPutAsync(string nuix_auth_token, string caseId, string markupSetName, MarkupSetRequest markupSetRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Deletes a markup set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="markupSetName">The name of the markup set</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<MarkupSetDeleteResponse> MarkupSetDeleteAsync(string nuix_auth_token, string caseId, string markupSetName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes a markup set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="markupSetName">The name of the markup set</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<MarkupSetDeleteResponse> MarkupSetDeleteAsync(string nuix_auth_token, string caseId, string markupSetName, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns metadata fields available for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CaseMetadataField>> MetadataFieldsAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns metadata fields available for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CaseMetadataField>> MetadataFieldsAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the set of original file extensions for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> OriginalExtensionsAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the set of original file extensions for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> OriginalExtensionsAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns all production sets for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ProductionSetResponse>> ProductionSetsGetAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all production sets for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ProductionSetResponse>> ProductionSetsGetAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Creates a production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="productionSetRequest">Request body</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ProductionSetsPostAsync(string nuix_auth_token, ProductionSetRequest productionSetRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates a production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="productionSetRequest">Request body</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ProductionSetsPostAsync(string nuix_auth_token, ProductionSetRequest productionSetRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns details for a specific production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProductionSetResponse> ProductionSetsGetAsync(string nuix_auth_token, string caseId, string productionSetId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns details for a specific production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProductionSetResponse> ProductionSetsGetAsync(string nuix_auth_token, string caseId, string productionSetId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Deletes a production set from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProductionSetResponse> ProductionSetsDeleteAsync(string nuix_auth_token, string caseId, string productionSetId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes a production set from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProductionSetResponse> ProductionSetsDeleteAsync(string nuix_auth_token, string caseId, string productionSetId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns review jobs for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ReviewJobResponse>> ReviewJobsGetAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns review jobs for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ReviewJobResponse>> ReviewJobsGetAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Creates a review job for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobRequest">The create review job request body</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ReviewJobResponse> ReviewJobsPostAsync(string nuix_auth_token, string caseId, CreateReviewJobRequest reviewJobRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates a review job for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobRequest">The create review job request body</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ReviewJobResponse> ReviewJobsPostAsync(string nuix_auth_token, string caseId, CreateReviewJobRequest reviewJobRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns details for a review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ReviewJobResponse> ReviewJobsGetAsync(string nuix_auth_token, string caseId, string reviewJobName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns details for a review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ReviewJobResponse> ReviewJobsGetAsync(string nuix_auth_token, string caseId, string reviewJobName, System.Threading.CancellationToken cancellationToken);

        /// <summary>Deletes a review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ReviewJobsDeleteAsync(string nuix_auth_token, string caseId, string reviewJobName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes a review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ReviewJobsDeleteAsync(string nuix_auth_token, string caseId, string reviewJobName, System.Threading.CancellationToken cancellationToken);

        /// <summary>Generates Slipsheets for items in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="slipsheetsRequest">The slipsheets request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> SlipsheetsAsync(string nuix_auth_token, SlipsheetsRequest slipsheetsRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Generates Slipsheets for items in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="slipsheetsRequest">The slipsheets request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> SlipsheetsAsync(string nuix_auth_token, SlipsheetsRequest slipsheetsRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Creates a case subset</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="createCaseSubsetRequest">Provides options for creating a case</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> SubsetAsync(string nuix_auth_token, string caseId, CreateCaseSubsetRequest createCaseSubsetRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates a case subset</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="createCaseSubsetRequest">Provides options for creating a case</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> SubsetAsync(string nuix_auth_token, string caseId, CreateCaseSubsetRequest createCaseSubsetRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the set of tags for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> TagsGetAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the set of tags for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> TagsGetAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Generates thumbnails for a case.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">request</param>
        /// <param name="caseId">case identifier token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ThumbnailsPostAsync(string nuix_auth_token, ThumbnailUtilityRequest request, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Generates thumbnails for a case.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">request</param>
        /// <param name="caseId">case identifier token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ThumbnailsPostAsync(string nuix_auth_token, ThumbnailUtilityRequest request, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Deletes the case's thumbnails folder, containing all generated media.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Success> ThumbnailsDeleteAsync(string nuix_auth_token, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes the case's thumbnails folder, containing all generated media.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Success> ThumbnailsDeleteAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the top-level items for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="fields">List of fields associated with this item</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<MapOfstringAndobject>> TopLevelItemsAsync(string nuix_auth_token, string caseId, System.Collections.Generic.IEnumerable<string> fields);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the top-level items for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="fields">List of fields associated with this item</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<MapOfstringAndobject>> TopLevelItemsAsync(string nuix_auth_token, string caseId, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken);

        /// <summary>Executes a user script on a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="scriptRequest">scriptRequest</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> UserScriptsAsync(string nuix_auth_token, UserScriptRequest scriptRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Executes a user script on a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="scriptRequest">scriptRequest</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<object> UserScriptsAsync(string nuix_auth_token, UserScriptRequest scriptRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Indicates word usage and frequency in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="wordCountsRequest">The request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<WordCountsResponse>>> WordCountsAsync(string nuix_auth_token, WordCountsRequest wordCountsRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Indicates word usage and frequency in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="wordCountsRequest">The request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<WordCountsResponse>>> WordCountsAsync(string nuix_auth_token, WordCountsRequest wordCountsRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Indicates word usage and frequency in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="wordcountRequest">The request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, long>> WordcountAsync(string nuix_auth_token, WordcountRequest wordcountRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Indicates word usage and frequency in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="wordcountRequest">The request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, long>> WordcountAsync(string nuix_auth_token, WordcountRequest wordcountRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Tags query items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="tagRequest">The tag request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ApplyTagListResponse> ItemTagsPostAsync(string nuix_auth_token, ApplyTagListRequest tagRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Tags query items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="tagRequest">The tag request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ApplyTagListResponse> ItemTagsPostAsync(string nuix_auth_token, ApplyTagListRequest tagRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Removes tags from query items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="tagRequest">The tag request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ApplyTagListResponse> ItemTagsDeleteAsync(string nuix_auth_token, ApplyTagListRequest tagRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Removes tags from query items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="tagRequest">The tag request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ApplyTagListResponse> ItemTagsDeleteAsync(string nuix_auth_token, ApplyTagListRequest tagRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Creates a production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="productionSetRequest">Request body</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ProductionSetsPostAsync(string nuix_auth_token, BulkProductionSetWithProfilesRequest productionSetRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates a production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="productionSetRequest">Request body</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ProductionSetsPostAsync(string nuix_auth_token, BulkProductionSetWithProfilesRequest productionSetRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Performs a search</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="query">Identifies what items should be returned.  If a query is not supplied it defaults to an empty string, which returns all items.</param>
        /// <param name="startIndex">The index of the first record that should be returned. Defaults to 0.</param>
        /// <param name="numberOfRecordsRequested">The number of records that should be returned. Defaults to all records.</param>
        /// <param name="deduplicate">Deduplicate content based on the Value field selection. The default is no deduplication.</param>
        /// <param name="metadataProfile">Defines the metadata profile to be appied to the results. Needed to get custom metadata. Defaults to no metadata profile.</param>
        /// <param name="fieldList">List of fields to be returned for each item in the results.</param>
        /// <param name="propertyList">List of properties to be returned for each item in the results.</param>
        /// <param name="entities">List of entity names to include in response (e.g. company,email)</param>
        /// <param name="useCache">Specifies whether the results should be loaded from and stored in cache.</param>
        /// <param name="forceCacheDelete">Specifies whether the cached results should be deleted before performing the search.</param>
        /// <param name="sortField">Any field in the metadata profile which you want to sort by.</param>
        /// <param name="sortOrder">Sets the sort order for the results.</param>
        /// <param name="relationType">The relation to apply to the found items.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SearchNativeResult> SearchGetAsync(string nuix_auth_token, string caseId, string query, int? startIndex, int? numberOfRecordsRequested, Deduplicate? deduplicate, string metadataProfile, System.Collections.Generic.IEnumerable<string> fieldList, System.Collections.Generic.IEnumerable<string> propertyList, System.Collections.Generic.IEnumerable<string> entities, bool? useCache, bool? forceCacheDelete, string sortField, SortOrder? sortOrder, RelationType? relationType);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Performs a search</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="query">Identifies what items should be returned.  If a query is not supplied it defaults to an empty string, which returns all items.</param>
        /// <param name="startIndex">The index of the first record that should be returned. Defaults to 0.</param>
        /// <param name="numberOfRecordsRequested">The number of records that should be returned. Defaults to all records.</param>
        /// <param name="deduplicate">Deduplicate content based on the Value field selection. The default is no deduplication.</param>
        /// <param name="metadataProfile">Defines the metadata profile to be appied to the results. Needed to get custom metadata. Defaults to no metadata profile.</param>
        /// <param name="fieldList">List of fields to be returned for each item in the results.</param>
        /// <param name="propertyList">List of properties to be returned for each item in the results.</param>
        /// <param name="entities">List of entity names to include in response (e.g. company,email)</param>
        /// <param name="useCache">Specifies whether the results should be loaded from and stored in cache.</param>
        /// <param name="forceCacheDelete">Specifies whether the cached results should be deleted before performing the search.</param>
        /// <param name="sortField">Any field in the metadata profile which you want to sort by.</param>
        /// <param name="sortOrder">Sets the sort order for the results.</param>
        /// <param name="relationType">The relation to apply to the found items.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SearchNativeResult> SearchGetAsync(string nuix_auth_token, string caseId, string query, int? startIndex, int? numberOfRecordsRequested, Deduplicate? deduplicate, string metadataProfile, System.Collections.Generic.IEnumerable<string> fieldList, System.Collections.Generic.IEnumerable<string> propertyList, System.Collections.Generic.IEnumerable<string> entities, bool? useCache, bool? forceCacheDelete, string sortField, SortOrder? sortOrder, RelationType? relationType, System.Threading.CancellationToken cancellationToken);

        /// <summary>Performs a large search</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="request">request</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SearchNativeResult> SearchPostAsync(string nuix_auth_token, string caseId, SearchNativeRequest request);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Performs a large search</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="request">request</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SearchNativeResult> SearchPostAsync(string nuix_auth_token, string caseId, SearchNativeRequest request, System.Threading.CancellationToken cancellationToken);

        /// <summary>Creates new tags for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="tagRequest">The tag request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreateTagListResponse> TagsPostAsync(string nuix_auth_token, TagList tagRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates new tags for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="tagRequest">The tag request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CreateTagListResponse> TagsPostAsync(string nuix_auth_token, TagList tagRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Deletes tags for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="tagRequest">The tag request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteTagListResponse> TagsDeleteAsync(string nuix_auth_token, TagList tagRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes tags for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="tagRequest">The tag request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteTagListResponse> TagsDeleteAsync(string nuix_auth_token, TagList tagRequest, string caseId, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class CasesClient : ICasesClient
    {
        private string _baseUrl = "localhost:8080/nuix-restful-service/svc";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public CasesClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>Deletes all audit reports and audit verification files for a specified case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task AuditFilesAsync(string nuix_auth_token, string caseId)
        {
            return AuditFilesAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes all audit reports and audit verification files for a specified case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task AuditFilesAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/auditFiles");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns an audit report file</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task AuditReportFileAsync(string nuix_auth_token, string caseId)
        {
            return AuditReportFileAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns an audit report file</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task AuditReportFileAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/auditReportFile");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns total audit sizes for items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">Query list</param>
        /// <param name="caseId">Case id</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ItemSizeResponse>> AuditSizesAsync(string nuix_auth_token, DeduplicationQueryListRequest request, string caseId)
        {
            return AuditSizesAsync(nuix_auth_token, request, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns total audit sizes for items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">Query list</param>
        /// <param name="caseId">Case id</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ItemSizeResponse>> AuditSizesAsync(string nuix_auth_token, DeduplicationQueryListRequest request, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/auditSizes");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<ItemSizeResponse>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<ItemSizeResponse>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the audit status for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AuditStatus> AuditStatusAsync(string nuix_auth_token, string caseId)
        {
            return AuditStatusAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the audit status for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AuditStatus> AuditStatusAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/auditStatus");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AuditStatus>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AuditStatus);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Uploads an audit verification file</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="uploadFile">uploadFile</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task AuditVerificationFileAsync(string nuix_auth_token, string caseId, FileParameter uploadFile)
        {
            return AuditVerificationFileAsync(nuix_auth_token, caseId, uploadFile, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Uploads an audit verification file</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="uploadFile">uploadFile</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task AuditVerificationFileAsync(string nuix_auth_token, string caseId, FileParameter uploadFile, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/auditVerificationFile");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (uploadFile == null)
                        throw new System.ArgumentNullException("uploadFile");
                    else
                    {
                        var content_uploadFile_ = new System.Net.Http.StreamContent(uploadFile.Data);
                        if (!string.IsNullOrEmpty(uploadFile.ContentType))
                            content_uploadFile_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(uploadFile.ContentType);
                        content_.Add(content_uploadFile_, "uploadFile", uploadFile.FileName ?? "uploadFile");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "201")
                        {
                            return;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns batches associated with a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<BatchLoadDetailsResponse>> BatchesAsync(string nuix_auth_token, string caseId)
        {
            return BatchesAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns batches associated with a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<BatchLoadDetailsResponse>> BatchesAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/batches");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<BatchLoadDetailsResponse>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<BatchLoadDetailsResponse>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Generate a count report and optionally tag items.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">caseId</param>
        /// <param name="bulkSearcherRequest">bulkSearcherRequest</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> BulkSearchersAsync(string nuix_auth_token, string caseId, BulkSearcherRequest bulkSearcherRequest)
        {
            return BulkSearchersAsync(nuix_auth_token, caseId, bulkSearcherRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Generate a count report and optionally tag items.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">caseId</param>
        /// <param name="bulkSearcherRequest">bulkSearcherRequest</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> BulkSearchersAsync(string nuix_auth_token, string caseId, BulkSearcherRequest bulkSearcherRequest, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/bulkSearchers");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(bulkSearcherRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Case functions</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Anonymous>> CaseFunctionsGetAsync(string nuix_auth_token)
        {
            return CaseFunctionsGetAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Case functions</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Anonymous>> CaseFunctionsGetAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/caseFunctions");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<Anonymous>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<Anonymous>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Perform a function against a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="caseModification">Case modification request</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> CaseFunctionsPostAsync(string nuix_auth_token, string caseId, CaseModification caseModification)
        {
            return CaseFunctionsPostAsync(nuix_auth_token, caseId, caseModification, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Perform a function against a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="caseModification">Case modification request</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> CaseFunctionsPostAsync(string nuix_auth_token, string caseId, CaseModification caseModification, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/caseFunctions");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(caseModification, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns a list of child cases for a compound case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="calculateCaseSize">Should size of each child case on disk be calculated? Defaults to false</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CaseResponse>> ChildCasesGetAsync(string nuix_auth_token, string caseId, bool? calculateCaseSize)
        {
            return ChildCasesGetAsync(nuix_auth_token, caseId, calculateCaseSize, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns a list of child cases for a compound case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="calculateCaseSize">Should size of each child case on disk be calculated? Defaults to false</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CaseResponse>> ChildCasesGetAsync(string nuix_auth_token, string caseId, bool? calculateCaseSize, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/childCases?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (calculateCaseSize != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("calculateCaseSize") + "=").Append(System.Uri.EscapeDataString(ConvertToString(calculateCaseSize, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<CaseResponse>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<CaseResponse>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Adds child cases to a compound case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="childCaseIds">Case IDs for the child cases</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ChildCasesPostAsync(string nuix_auth_token, string caseId, System.Collections.Generic.IEnumerable<string> childCaseIds)
        {
            return ChildCasesPostAsync(nuix_auth_token, caseId, childCaseIds, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Adds child cases to a compound case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="childCaseIds">Case IDs for the child cases</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ChildCasesPostAsync(string nuix_auth_token, string caseId, System.Collections.Generic.IEnumerable<string> childCaseIds, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/childCases");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(childCaseIds, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "201")
                        {
                            return;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Adds a child case to a compound case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="childCaseId">Case ID for the child case</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ChildCasesPutAsync(string nuix_auth_token, string caseId, string childCaseId)
        {
            return ChildCasesPutAsync(nuix_auth_token, caseId, childCaseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Adds a child case to a compound case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="childCaseId">Case ID for the child case</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ChildCasesPutAsync(string nuix_auth_token, string caseId, string childCaseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/childCases/{childCaseId}");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (childCaseId != null)
                urlBuilder_.Replace("{childCaseId}", System.Uri.EscapeDataString(ConvertToString(childCaseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{childCaseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json;charset=utf-8");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "201")
                        {
                            return;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Closes a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GenericResponse> CloseAsync(string nuix_auth_token, string caseId)
        {
            return CloseAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Closes a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GenericResponse> CloseAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/close");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json;charset=utf-8");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GenericResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(GenericResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the cluster runs for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ClusterRunResponse>> ClusterRunsGetAsync(string nuix_auth_token, string caseId)
        {
            return ClusterRunsGetAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the cluster runs for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ClusterRunResponse>> ClusterRunsGetAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/clusterRuns");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<ClusterRunResponse>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<ClusterRunResponse>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Creates a cluster run based on the query provided</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="clusterRunRequest">Request Body</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> ClusterRunsPostAsync(string nuix_auth_token, ClusterRunRequest clusterRunRequest, string caseId)
        {
            return ClusterRunsPostAsync(nuix_auth_token, clusterRunRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates a cluster run based on the query provided</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="clusterRunRequest">Request Body</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> ClusterRunsPostAsync(string nuix_auth_token, ClusterRunRequest clusterRunRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/clusterRuns");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(clusterRunRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Delete a cluster run</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="clusterRunName">Cluster run name</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ClusterRunsDeleteAsync(string nuix_auth_token, string caseId, string clusterRunName)
        {
            return ClusterRunsDeleteAsync(nuix_auth_token, caseId, clusterRunName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Delete a cluster run</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="clusterRunName">Cluster run name</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ClusterRunsDeleteAsync(string nuix_auth_token, string caseId, string clusterRunName, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/clusterRuns/{clusterRunName}");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (clusterRunName != null)
                urlBuilder_.Replace("{clusterRunName}", System.Uri.EscapeDataString(ConvertToString(clusterRunName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{clusterRunName}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the total number of items in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="query">Query items that should be included. If a query is not supplied it defaults to an empty string, which returns everything.</param>
        /// <param name="deduplication">How the deduplication is applied. None returns all items matching the query including duplicates. Other options return deduplicated items based on the deduplication method used.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CountResponse> CountGetAsync(string nuix_auth_token, string caseId, string query, Deduplication? deduplication)
        {
            return CountGetAsync(nuix_auth_token, caseId, query, deduplication, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the total number of items in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="query">Query items that should be included. If a query is not supplied it defaults to an empty string, which returns everything.</param>
        /// <param name="deduplication">How the deduplication is applied. None returns all items matching the query including duplicates. Other options return deduplicated items based on the deduplication method used.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CountResponse> CountGetAsync(string nuix_auth_token, string caseId, string query, Deduplication? deduplication, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/count?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (query != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("query") + "=").Append(System.Uri.EscapeDataString(ConvertToString(query, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deduplication != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deduplication") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deduplication, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CountResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CountResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the number of items associated with a case query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="countRequest">Identifies what items should be returned.  If a query is not supplied it defaults to an empty string, which returns all items.</param>
        /// <param name="deduplication">How the deduplication is applied. None returns all items matching the query including duplicates. Other options return deduplicated items based on the deduplication method used.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CountResponse> CountPostAsync(string nuix_auth_token, string caseId, CountRequest countRequest, Deduplication2? deduplication)
        {
            return CountPostAsync(nuix_auth_token, caseId, countRequest, deduplication, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the number of items associated with a case query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="countRequest">Identifies what items should be returned.  If a query is not supplied it defaults to an empty string, which returns all items.</param>
        /// <param name="deduplication">How the deduplication is applied. None returns all items matching the query including duplicates. Other options return deduplicated items based on the deduplication method used.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CountResponse> CountPostAsync(string nuix_auth_token, string caseId, CountRequest countRequest, Deduplication2? deduplication, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/count?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (deduplication != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deduplication") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deduplication, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(countRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CountResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CountResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the set of custodians for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> CustodiansAsync(string nuix_auth_token, string caseId)
        {
            return CustodiansAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the set of custodians for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> CustodiansAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/custodians");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the set of communication domains in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="addressType">The type of contact address</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> DomainsAsync(string nuix_auth_token, string caseId, AddressType? addressType)
        {
            return DomainsAsync(nuix_auth_token, caseId, addressType, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the set of communication domains in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="addressType">The type of contact address</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> DomainsAsync(string nuix_auth_token, string caseId, AddressType? addressType, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/domains?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (addressType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("addressType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(addressType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the set of entity types for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> EntityTypesAsync(string nuix_auth_token, string caseId)
        {
            return EntityTypesAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the set of entity types for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> EntityTypesAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/entityTypes");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Ingests a new repository and/or supported containers into a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, repository, and container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> EvidenceAsync(string nuix_auth_token, BulkIngestionRequest ingestionRequest, string caseId)
        {
            return EvidenceAsync(nuix_auth_token, ingestionRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new repository and/or supported containers into a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, repository, and container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> EvidenceAsync(string nuix_auth_token, BulkIngestionRequest ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/evidence");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(ingestionRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Excludes items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="exclusionRequest">The exclusion request body object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> ExcludedItemsAsync(string nuix_auth_token, string caseId, BulkExclusionRequest exclusionRequest)
        {
            return ExcludedItemsAsync(nuix_auth_token, caseId, exclusionRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Excludes items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="exclusionRequest">The exclusion request body object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> ExcludedItemsAsync(string nuix_auth_token, string caseId, BulkExclusionRequest exclusionRequest, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/excludedItems");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(exclusionRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns exclusions for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ExclusionsAsync(string nuix_auth_token, string caseId)
        {
            return ExclusionsAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns exclusions for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ExclusionsAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/exclusions");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Exports production sets and items from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="exportRequest">The export request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> ExportAsync(string nuix_auth_token, ExportRequest exportRequest, string caseId)
        {
            return ExportAsync(nuix_auth_token, exportRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Exports production sets and items from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="exportRequest">The export request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> ExportAsync(string nuix_auth_token, ExportRequest exportRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/export");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(exportRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns statistics for families of top-level items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">Query list</param>
        /// <param name="caseId">Case id</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<FamilyStatisticsResponse>> FamilyStatisticsAsync(string nuix_auth_token, DeduplicationQueryListRequest request, string caseId)
        {
            return FamilyStatisticsAsync(nuix_auth_token, request, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns statistics for families of top-level items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">Query list</param>
        /// <param name="caseId">Case id</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<FamilyStatisticsResponse>> FamilyStatisticsAsync(string nuix_auth_token, DeduplicationQueryListRequest request, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/familyStatistics");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<FamilyStatisticsResponse>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<FamilyStatisticsResponse>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns total file sizes for items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">Query list</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ItemSizeResponse>> FileSizesAsync(string nuix_auth_token, DeduplicationQueryListRequest request, string caseId)
        {
            return FileSizesAsync(nuix_auth_token, request, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns total file sizes for items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">Query list</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ItemSizeResponse>> FileSizesAsync(string nuix_auth_token, DeduplicationQueryListRequest request, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/fileSizes");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<ItemSizeResponse>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<ItemSizeResponse>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns history events for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="type">Filters the type of history event returned.  If not specified, all events are returned.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CaseHistoryEventResponse>> HistoryAsync(string nuix_auth_token, string caseId, Type? type)
        {
            return HistoryAsync(nuix_auth_token, caseId, type, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns history events for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="type">Filters the type of history event returned.  If not specified, all events are returned.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CaseHistoryEventResponse>> HistoryAsync(string nuix_auth_token, string caseId, Type? type, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/history?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (type != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("type") + "=").Append(System.Uri.EscapeDataString(ConvertToString(type, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<CaseHistoryEventResponse>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<CaseHistoryEventResponse>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Includes items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="inclusionRequest">The inclusion request body object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> IncludedItemsAsync(string nuix_auth_token, string caseId, BulkInclusionRequest inclusionRequest)
        {
            return IncludedItemsAsync(nuix_auth_token, caseId, inclusionRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Includes items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="inclusionRequest">The inclusion request body object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> IncludedItemsAsync(string nuix_auth_token, string caseId, BulkInclusionRequest inclusionRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/includedItems");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(inclusionRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the investigation time zone for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<InvestigatorTimeZoneResponse> InvestigatorTimeZoneGetAsync(string nuix_auth_token, string caseId)
        {
            return InvestigatorTimeZoneGetAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the investigation time zone for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<InvestigatorTimeZoneResponse> InvestigatorTimeZoneGetAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/investigatorTimeZone");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InvestigatorTimeZoneResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(InvestigatorTimeZoneResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Sets the investigation time zone for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="timezoneRequest">The requested time zone</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task InvestigatorTimeZonePutAsync(string nuix_auth_token, string caseId, TimezoneRequest timezoneRequest)
        {
            return InvestigatorTimeZonePutAsync(nuix_auth_token, caseId, timezoneRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Sets the investigation time zone for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="timezoneRequest">The requested time zone</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task InvestigatorTimeZonePutAsync(string nuix_auth_token, string caseId, TimezoneRequest timezoneRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/investigatorTimeZone");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(timezoneRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "201")
                        {
                            return;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Streams an item binary from a case if it is available</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ItemBinariesGetAsync(string nuix_auth_token, string caseId, string itemGuid)
        {
            return ItemBinariesGetAsync(nuix_auth_token, caseId, itemGuid, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Streams an item binary from a case if it is available</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ItemBinariesGetAsync(string nuix_auth_token, string caseId, string itemGuid, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemBinaries/{itemGuid}");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemGuid != null)
                urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemGuid}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Streams an item binary from a case if it is available</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ItemBinariesHeadAsync(string nuix_auth_token, string caseId, string itemGuid)
        {
            return ItemBinariesHeadAsync(nuix_auth_token, caseId, itemGuid, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Streams an item binary from a case if it is available</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ItemBinariesHeadAsync(string nuix_auth_token, string caseId, string itemGuid, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemBinaries/{itemGuid}");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemGuid != null)
                urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemGuid}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("HEAD");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Applies custom metadata to items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="bulkItemCustomMetadataRequest">bulkItemCustomMetadataRequest</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ApplyCustomMetadataResponse> ItemCustomMetadataPostAsync(string nuix_auth_token, string caseId, BulkItemCustomMetadataRequest bulkItemCustomMetadataRequest)
        {
            return ItemCustomMetadataPostAsync(nuix_auth_token, caseId, bulkItemCustomMetadataRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Applies custom metadata to items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="bulkItemCustomMetadataRequest">bulkItemCustomMetadataRequest</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ApplyCustomMetadataResponse> ItemCustomMetadataPostAsync(string nuix_auth_token, string caseId, BulkItemCustomMetadataRequest bulkItemCustomMetadataRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemCustomMetadata");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(bulkItemCustomMetadataRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ApplyCustomMetadataResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ApplyCustomMetadataResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Removes custom metadata on items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="bulkRequest">bulkRequest</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ItemCustomMetadataDeleteAsync(string nuix_auth_token, string caseId, BulkItemCustomMetadataDeleteRequest bulkRequest)
        {
            return ItemCustomMetadataDeleteAsync(nuix_auth_token, caseId, bulkRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Removes custom metadata on items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="bulkRequest">bulkRequest</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ItemCustomMetadataDeleteAsync(string nuix_auth_token, string caseId, BulkItemCustomMetadataDeleteRequest bulkRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemCustomMetadata");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(bulkRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns a list of values for the specified property.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="propertyName">Name of the property to retrieve values for</param>
        /// <param name="itemPropertiesRequest">The item property request body</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ItemPropertiesAsync(string nuix_auth_token, string caseId, string propertyName, ItemPropertiesRequest itemPropertiesRequest)
        {
            return ItemPropertiesAsync(nuix_auth_token, caseId, propertyName, itemPropertiesRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns a list of values for the specified property.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="propertyName">Name of the property to retrieve values for</param>
        /// <param name="itemPropertiesRequest">The item property request body</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ItemPropertiesAsync(string nuix_auth_token, string caseId, string propertyName, ItemPropertiesRequest itemPropertiesRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemProperties/{propertyName}");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (propertyName != null)
                urlBuilder_.Replace("{propertyName}", System.Uri.EscapeDataString(ConvertToString(propertyName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{propertyName}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(itemPropertiesRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns item sets associated with a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ItemSetResponse>> ItemSetsGetAsync(string nuix_auth_token, string caseId)
        {
            return ItemSetsGetAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns item sets associated with a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ItemSetResponse>> ItemSetsGetAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemSets");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<ItemSetResponse>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<ItemSetResponse>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Creates an item set within a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetRequest">The item set creation request body</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> ItemSetsPostAsync(string nuix_auth_token, string caseId, ItemSetRequest itemSetRequest)
        {
            return ItemSetsPostAsync(nuix_auth_token, caseId, itemSetRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates an item set within a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetRequest">The item set creation request body</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> ItemSetsPostAsync(string nuix_auth_token, string caseId, ItemSetRequest itemSetRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemSets");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(itemSetRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns details for an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ItemSetResponse> ItemSetsGetAsync(string nuix_auth_token, string caseId, string itemSetName)
        {
            return ItemSetsGetAsync(nuix_auth_token, caseId, itemSetName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns details for an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ItemSetResponse> ItemSetsGetAsync(string nuix_auth_token, string caseId, string itemSetName, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemSets/{itemSetName}");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemSetName != null)
                urlBuilder_.Replace("{itemSetName}", System.Uri.EscapeDataString(ConvertToString(itemSetName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemSetName}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ItemSetResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ItemSetResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Renames an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="itemSetNameChangeRequest">Item set name change request</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ItemSetsPutAsync(string nuix_auth_token, string caseId, string itemSetName, ItemSetNameChangeRequest itemSetNameChangeRequest)
        {
            return ItemSetsPutAsync(nuix_auth_token, caseId, itemSetName, itemSetNameChangeRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Renames an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="itemSetNameChangeRequest">Item set name change request</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ItemSetsPutAsync(string nuix_auth_token, string caseId, string itemSetName, ItemSetNameChangeRequest itemSetNameChangeRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemSets/{itemSetName}");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemSetName != null)
                urlBuilder_.Replace("{itemSetName}", System.Uri.EscapeDataString(ConvertToString(itemSetName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemSetName}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(itemSetNameChangeRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            return;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Deletes an item set from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GenericResponse> ItemSetsDeleteAsync(string nuix_auth_token, string caseId, string itemSetName)
        {
            return ItemSetsDeleteAsync(nuix_auth_token, caseId, itemSetName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes an item set from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GenericResponse> ItemSetsDeleteAsync(string nuix_auth_token, string caseId, string itemSetName, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemSets/{itemSetName}");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemSetName != null)
                urlBuilder_.Replace("{itemSetName}", System.Uri.EscapeDataString(ConvertToString(itemSetName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemSetName}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GenericResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("No Content", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(GenericResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Calculates the number of shingles associated with a case's items</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="shinglesRequest">The items shingles request body</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> ItemShinglesAsync(string nuix_auth_token, string caseId, ItemsShinglesRequest shinglesRequest)
        {
            return ItemShinglesAsync(nuix_auth_token, caseId, shinglesRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Calculates the number of shingles associated with a case's items</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="shinglesRequest">The items shingles request body</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> ItemShinglesAsync(string nuix_auth_token, string caseId, ItemsShinglesRequest shinglesRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemShingles");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(shinglesRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Compute total sizes for items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="itemSizeRequest">Query list</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> ItemSizesAsync(string nuix_auth_token, ItemSizesRequest itemSizeRequest, string caseId)
        {
            return ItemSizesAsync(nuix_auth_token, itemSizeRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Compute total sizes for items matching a query</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="itemSizeRequest">Query list</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> ItemSizesAsync(string nuix_auth_token, ItemSizesRequest itemSizeRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemSizes");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(itemSizeRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns item kinds and types for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="includeCounts">Include count totals for the types</param>
        /// <param name="query">Query items that should be included. If a query is not supplied it defaults to an empty string, which returns all items.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<KindTypeResponse>> ItemTypesAsync(string nuix_auth_token, string caseId, bool? includeCounts, string query)
        {
            return ItemTypesAsync(nuix_auth_token, caseId, includeCounts, query, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns item kinds and types for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="includeCounts">Include count totals for the types</param>
        /// <param name="query">Query items that should be included. If a query is not supplied it defaults to an empty string, which returns all items.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<KindTypeResponse>> ItemTypesAsync(string nuix_auth_token, string caseId, bool? includeCounts, string query, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemTypes?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (includeCounts != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("includeCounts") + "=").Append(System.Uri.EscapeDataString(ConvertToString(includeCounts, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (query != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("query") + "=").Append(System.Uri.EscapeDataString(ConvertToString(query, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<KindTypeResponse>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<KindTypeResponse>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Reloads items from source based on a query in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor settings and query</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> ItemsPutAsync(string nuix_auth_token, ReloadItemsIngestionRequest ingestionRequest, string caseId)
        {
            return ItemsPutAsync(nuix_auth_token, ingestionRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Reloads items from source based on a query in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor settings and query</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> ItemsPutAsync(string nuix_auth_token, ReloadItemsIngestionRequest ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/items");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(ingestionRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns information for a specific item in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="field">List of fields associated with this item</param>
        /// <param name="property">List of properties associated with this item</param>
        /// <param name="metadataProfile">Metadata profile name. Needed to get custom metadata.</param>
        /// <param name="entities">List of entity names to include in response (e.g. company,email</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<object> ItemsGetAsync(string nuix_auth_token, string caseId, string itemGuid, System.Collections.Generic.IEnumerable<string> field, System.Collections.Generic.IEnumerable<string> property, string metadataProfile, System.Collections.Generic.IEnumerable<string> entities)
        {
            return ItemsGetAsync(nuix_auth_token, caseId, itemGuid, field, property, metadataProfile, entities, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns information for a specific item in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="field">List of fields associated with this item</param>
        /// <param name="property">List of properties associated with this item</param>
        /// <param name="metadataProfile">Metadata profile name. Needed to get custom metadata.</param>
        /// <param name="entities">List of entity names to include in response (e.g. company,email</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<object> ItemsGetAsync(string nuix_auth_token, string caseId, string itemGuid, System.Collections.Generic.IEnumerable<string> field, System.Collections.Generic.IEnumerable<string> property, string metadataProfile, System.Collections.Generic.IEnumerable<string> entities, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/items/{itemGuid}?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemGuid != null)
                urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemGuid}", string.Empty);
            if (field != null)
            {
                foreach (var item_ in field) { urlBuilder_.Append(System.Uri.EscapeDataString("field") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (property != null)
            {
                foreach (var item_ in property) { urlBuilder_.Append(System.Uri.EscapeDataString("property") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (metadataProfile != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("metadataProfile") + "=").Append(System.Uri.EscapeDataString(ConvertToString(metadataProfile, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (entities != null)
            {
                foreach (var item_ in entities) { urlBuilder_.Append(System.Uri.EscapeDataString("entities") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<object>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(object);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns a list of keystore files available for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> KeyStoresGetAsync(string nuix_auth_token, string caseId)
        {
            return KeyStoresGetAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns a list of keystore files available for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> KeyStoresGetAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/keyStores");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Adds a keystore to a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="keystoreFile">The keystore file being added to the case</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<Success> KeyStoresPostAsync(string nuix_auth_token, string caseId, FileParameter keystoreFile)
        {
            return KeyStoresPostAsync(nuix_auth_token, caseId, keystoreFile, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Adds a keystore to a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="keystoreFile">The keystore file being added to the case</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Success> KeyStoresPostAsync(string nuix_auth_token, string caseId, FileParameter keystoreFile, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/keyStores");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (keystoreFile != null)
                    {
                        var content_keystoreFile_ = new System.Net.Http.StreamContent(keystoreFile.Data);
                        if (!string.IsNullOrEmpty(keystoreFile.ContentType))
                            content_keystoreFile_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(keystoreFile.ContentType);
                        content_.Add(content_keystoreFile_, "keystoreFile", keystoreFile.FileName ?? "keystoreFile");
                    }
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Success>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(Success);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Deletes the requested keystore from the case's keystore directory</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="fileToDeleteRegex">fileToDeleteRegex</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<Success> KeyStoresDeleteAsync(string nuix_auth_token, string caseId, string fileToDeleteRegex)
        {
            return KeyStoresDeleteAsync(nuix_auth_token, caseId, fileToDeleteRegex, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes the requested keystore from the case's keystore directory</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="fileToDeleteRegex">fileToDeleteRegex</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Success> KeyStoresDeleteAsync(string nuix_auth_token, string caseId, string fileToDeleteRegex, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/keyStores?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (fileToDeleteRegex != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fileToDeleteRegex") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fileToDeleteRegex, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Success>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("No Content", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(Success);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns all languages found in the case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="includeItemCounts">Include counts for the languages</param>
        /// <param name="countScopingQuery">Scope the counts to a provided query when includeItemCounts=true</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<LanguageResponse>> LanguagesAsync(string nuix_auth_token, string caseId, bool? includeItemCounts, string countScopingQuery)
        {
            return LanguagesAsync(nuix_auth_token, caseId, includeItemCounts, countScopingQuery, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all languages found in the case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="includeItemCounts">Include counts for the languages</param>
        /// <param name="countScopingQuery">Scope the counts to a provided query when includeItemCounts=true</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<LanguageResponse>> LanguagesAsync(string nuix_auth_token, string caseId, bool? includeItemCounts, string countScopingQuery, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/languages?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (includeItemCounts != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("includeItemCounts") + "=").Append(System.Uri.EscapeDataString(ConvertToString(includeItemCounts, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (countScopingQuery != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("countScopingQuery") + "=").Append(System.Uri.EscapeDataString(ConvertToString(countScopingQuery, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<LanguageResponse>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<LanguageResponse>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Gets all MarkupSets for the given case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<MarkupSet>> MarkupSetGetAsync(string nuix_auth_token, string caseId)
        {
            return MarkupSetGetAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Gets all MarkupSets for the given case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<MarkupSet>> MarkupSetGetAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/markupSet");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<MarkupSet>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<MarkupSet>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Creates a markup set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="markupSetName">The name of the markup set</param>
        /// <param name="markupSetRequest">The request body object</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<MarkupSet> MarkupSetPostAsync(string nuix_auth_token, string caseId, string markupSetName, MarkupSetRequest markupSetRequest)
        {
            return MarkupSetPostAsync(nuix_auth_token, caseId, markupSetName, markupSetRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates a markup set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="markupSetName">The name of the markup set</param>
        /// <param name="markupSetRequest">The request body object</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<MarkupSet> MarkupSetPostAsync(string nuix_auth_token, string caseId, string markupSetName, MarkupSetRequest markupSetRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/markupSet/{markupSetName}");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (markupSetName != null)
                urlBuilder_.Replace("{markupSetName}", System.Uri.EscapeDataString(ConvertToString(markupSetName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{markupSetName}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(markupSetRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<MarkupSet>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(MarkupSet);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Updates a markup set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="markupSetName">The name of the markup set</param>
        /// <param name="markupSetRequest">The request body object</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<MarkupSet> MarkupSetPutAsync(string nuix_auth_token, string caseId, string markupSetName, MarkupSetRequest markupSetRequest)
        {
            return MarkupSetPutAsync(nuix_auth_token, caseId, markupSetName, markupSetRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Updates a markup set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="markupSetName">The name of the markup set</param>
        /// <param name="markupSetRequest">The request body object</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<MarkupSet> MarkupSetPutAsync(string nuix_auth_token, string caseId, string markupSetName, MarkupSetRequest markupSetRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/markupSet/{markupSetName}");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (markupSetName != null)
                urlBuilder_.Replace("{markupSetName}", System.Uri.EscapeDataString(ConvertToString(markupSetName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{markupSetName}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(markupSetRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<MarkupSet>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(MarkupSet);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Deletes a markup set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="markupSetName">The name of the markup set</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<MarkupSetDeleteResponse> MarkupSetDeleteAsync(string nuix_auth_token, string caseId, string markupSetName)
        {
            return MarkupSetDeleteAsync(nuix_auth_token, caseId, markupSetName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes a markup set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="markupSetName">The name of the markup set</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<MarkupSetDeleteResponse> MarkupSetDeleteAsync(string nuix_auth_token, string caseId, string markupSetName, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/markupSet/{markupSetName}");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (markupSetName != null)
                urlBuilder_.Replace("{markupSetName}", System.Uri.EscapeDataString(ConvertToString(markupSetName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{markupSetName}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<MarkupSetDeleteResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("No Content", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(MarkupSetDeleteResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns metadata fields available for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CaseMetadataField>> MetadataFieldsAsync(string nuix_auth_token, string caseId)
        {
            return MetadataFieldsAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns metadata fields available for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CaseMetadataField>> MetadataFieldsAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/metadataFields");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<CaseMetadataField>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<CaseMetadataField>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the set of original file extensions for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> OriginalExtensionsAsync(string nuix_auth_token, string caseId)
        {
            return OriginalExtensionsAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the set of original file extensions for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> OriginalExtensionsAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/originalExtensions");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns all production sets for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ProductionSetResponse>> ProductionSetsGetAsync(string nuix_auth_token, string caseId)
        {
            return ProductionSetsGetAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns all production sets for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ProductionSetResponse>> ProductionSetsGetAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/productionSets");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<ProductionSetResponse>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<ProductionSetResponse>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Creates a production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="productionSetRequest">Request body</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> ProductionSetsPostAsync(string nuix_auth_token, ProductionSetRequest productionSetRequest, string caseId)
        {
            return ProductionSetsPostAsync(nuix_auth_token, productionSetRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates a production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="productionSetRequest">Request body</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> ProductionSetsPostAsync(string nuix_auth_token, ProductionSetRequest productionSetRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/productionSets");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(productionSetRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns details for a specific production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ProductionSetResponse> ProductionSetsGetAsync(string nuix_auth_token, string caseId, string productionSetId)
        {
            return ProductionSetsGetAsync(nuix_auth_token, caseId, productionSetId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns details for a specific production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ProductionSetResponse> ProductionSetsGetAsync(string nuix_auth_token, string caseId, string productionSetId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            if (productionSetId == null)
                throw new System.ArgumentNullException("productionSetId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/productionSets/{productionSetId}");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{productionSetId}", System.Uri.EscapeDataString(ConvertToString(productionSetId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProductionSetResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ProductionSetResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Deletes a production set from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ProductionSetResponse> ProductionSetsDeleteAsync(string nuix_auth_token, string caseId, string productionSetId)
        {
            return ProductionSetsDeleteAsync(nuix_auth_token, caseId, productionSetId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes a production set from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ProductionSetResponse> ProductionSetsDeleteAsync(string nuix_auth_token, string caseId, string productionSetId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            if (productionSetId == null)
                throw new System.ArgumentNullException("productionSetId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/productionSets/{productionSetId}");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{productionSetId}", System.Uri.EscapeDataString(ConvertToString(productionSetId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProductionSetResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("No Content", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ProductionSetResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns review jobs for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ReviewJobResponse>> ReviewJobsGetAsync(string nuix_auth_token, string caseId)
        {
            return ReviewJobsGetAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns review jobs for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ReviewJobResponse>> ReviewJobsGetAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/reviewJobs");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<ReviewJobResponse>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<ReviewJobResponse>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Creates a review job for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobRequest">The create review job request body</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ReviewJobResponse> ReviewJobsPostAsync(string nuix_auth_token, string caseId, CreateReviewJobRequest reviewJobRequest)
        {
            return ReviewJobsPostAsync(nuix_auth_token, caseId, reviewJobRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates a review job for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobRequest">The create review job request body</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ReviewJobResponse> ReviewJobsPostAsync(string nuix_auth_token, string caseId, CreateReviewJobRequest reviewJobRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/reviewJobs");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(reviewJobRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ReviewJobResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ReviewJobResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns details for a review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ReviewJobResponse> ReviewJobsGetAsync(string nuix_auth_token, string caseId, string reviewJobName)
        {
            return ReviewJobsGetAsync(nuix_auth_token, caseId, reviewJobName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns details for a review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ReviewJobResponse> ReviewJobsGetAsync(string nuix_auth_token, string caseId, string reviewJobName, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/reviewJobs/{reviewJobName}");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (reviewJobName != null)
                urlBuilder_.Replace("{reviewJobName}", System.Uri.EscapeDataString(ConvertToString(reviewJobName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{reviewJobName}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ReviewJobResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ReviewJobResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Deletes a review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ReviewJobsDeleteAsync(string nuix_auth_token, string caseId, string reviewJobName)
        {
            return ReviewJobsDeleteAsync(nuix_auth_token, caseId, reviewJobName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes a review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ReviewJobsDeleteAsync(string nuix_auth_token, string caseId, string reviewJobName, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/reviewJobs/{reviewJobName}");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (reviewJobName != null)
                urlBuilder_.Replace("{reviewJobName}", System.Uri.EscapeDataString(ConvertToString(reviewJobName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{reviewJobName}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Generates Slipsheets for items in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="slipsheetsRequest">The slipsheets request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> SlipsheetsAsync(string nuix_auth_token, SlipsheetsRequest slipsheetsRequest, string caseId)
        {
            return SlipsheetsAsync(nuix_auth_token, slipsheetsRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Generates Slipsheets for items in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="slipsheetsRequest">The slipsheets request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> SlipsheetsAsync(string nuix_auth_token, SlipsheetsRequest slipsheetsRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/slipsheets");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(slipsheetsRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Creates a case subset</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="createCaseSubsetRequest">Provides options for creating a case</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> SubsetAsync(string nuix_auth_token, string caseId, CreateCaseSubsetRequest createCaseSubsetRequest)
        {
            return SubsetAsync(nuix_auth_token, caseId, createCaseSubsetRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates a case subset</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="createCaseSubsetRequest">Provides options for creating a case</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> SubsetAsync(string nuix_auth_token, string caseId, CreateCaseSubsetRequest createCaseSubsetRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/subset");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(createCaseSubsetRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the set of tags for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> TagsGetAsync(string nuix_auth_token, string caseId)
        {
            return TagsGetAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the set of tags for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> TagsGetAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/tags");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Generates thumbnails for a case.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">request</param>
        /// <param name="caseId">case identifier token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> ThumbnailsPostAsync(string nuix_auth_token, ThumbnailUtilityRequest request, string caseId)
        {
            return ThumbnailsPostAsync(nuix_auth_token, request, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Generates thumbnails for a case.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="request">request</param>
        /// <param name="caseId">case identifier token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> ThumbnailsPostAsync(string nuix_auth_token, ThumbnailUtilityRequest request, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/thumbnails");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Deletes the case's thumbnails folder, containing all generated media.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<Success> ThumbnailsDeleteAsync(string nuix_auth_token, string caseId)
        {
            return ThumbnailsDeleteAsync(nuix_auth_token, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes the case's thumbnails folder, containing all generated media.</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Success> ThumbnailsDeleteAsync(string nuix_auth_token, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/thumbnails");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Success>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("No Content", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(Success);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the top-level items for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="fields">List of fields associated with this item</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<MapOfstringAndobject>> TopLevelItemsAsync(string nuix_auth_token, string caseId, System.Collections.Generic.IEnumerable<string> fields)
        {
            return TopLevelItemsAsync(nuix_auth_token, caseId, fields, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the top-level items for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="fields">List of fields associated with this item</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<MapOfstringAndobject>> TopLevelItemsAsync(string nuix_auth_token, string caseId, System.Collections.Generic.IEnumerable<string> fields, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/topLevelItems?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (fields != null)
            {
                foreach (var item_ in fields) { urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<MapOfstringAndobject>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<MapOfstringAndobject>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Executes a user script on a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="scriptRequest">scriptRequest</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<object> UserScriptsAsync(string nuix_auth_token, UserScriptRequest scriptRequest, string caseId)
        {
            return UserScriptsAsync(nuix_auth_token, scriptRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Executes a user script on a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="scriptRequest">scriptRequest</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<object> UserScriptsAsync(string nuix_auth_token, UserScriptRequest scriptRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/userScripts");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(scriptRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<object>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(object);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Indicates word usage and frequency in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="wordCountsRequest">The request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<WordCountsResponse>>> WordCountsAsync(string nuix_auth_token, WordCountsRequest wordCountsRequest, string caseId)
        {
            return WordCountsAsync(nuix_auth_token, wordCountsRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Indicates word usage and frequency in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="wordCountsRequest">The request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<WordCountsResponse>>> WordCountsAsync(string nuix_auth_token, WordCountsRequest wordCountsRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/wordCounts");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(wordCountsRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<WordCountsResponse>>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<WordCountsResponse>>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Indicates word usage and frequency in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="wordcountRequest">The request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, long>> WordcountAsync(string nuix_auth_token, WordcountRequest wordcountRequest, string caseId)
        {
            return WordcountAsync(nuix_auth_token, wordcountRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Indicates word usage and frequency in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="wordcountRequest">The request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, long>> WordcountAsync(string nuix_auth_token, WordcountRequest wordcountRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/wordcount");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(wordcountRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.IDictionary<string, long>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.IDictionary<string, long>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Tags query items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="tagRequest">The tag request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ApplyTagListResponse> ItemTagsPostAsync(string nuix_auth_token, ApplyTagListRequest tagRequest, string caseId)
        {
            return ItemTagsPostAsync(nuix_auth_token, tagRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Tags query items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="tagRequest">The tag request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ApplyTagListResponse> ItemTagsPostAsync(string nuix_auth_token, ApplyTagListRequest tagRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v2/cases/{caseId}/itemTags");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(tagRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ApplyTagListResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ApplyTagListResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Removes tags from query items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="tagRequest">The tag request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ApplyTagListResponse> ItemTagsDeleteAsync(string nuix_auth_token, ApplyTagListRequest tagRequest, string caseId)
        {
            return ItemTagsDeleteAsync(nuix_auth_token, tagRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Removes tags from query items in bulk</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="tagRequest">The tag request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ApplyTagListResponse> ItemTagsDeleteAsync(string nuix_auth_token, ApplyTagListRequest tagRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v2/cases/{caseId}/itemTags");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(tagRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ApplyTagListResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("No Content", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ApplyTagListResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Creates a production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="productionSetRequest">Request body</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> ProductionSetsPostAsync(string nuix_auth_token, BulkProductionSetWithProfilesRequest productionSetRequest, string caseId)
        {
            return ProductionSetsPostAsync(nuix_auth_token, productionSetRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates a production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="productionSetRequest">Request body</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> ProductionSetsPostAsync(string nuix_auth_token, BulkProductionSetWithProfilesRequest productionSetRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v2/cases/{caseId}/productionSets");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(productionSetRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Performs a search</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="query">Identifies what items should be returned.  If a query is not supplied it defaults to an empty string, which returns all items.</param>
        /// <param name="startIndex">The index of the first record that should be returned. Defaults to 0.</param>
        /// <param name="numberOfRecordsRequested">The number of records that should be returned. Defaults to all records.</param>
        /// <param name="deduplicate">Deduplicate content based on the Value field selection. The default is no deduplication.</param>
        /// <param name="metadataProfile">Defines the metadata profile to be appied to the results. Needed to get custom metadata. Defaults to no metadata profile.</param>
        /// <param name="fieldList">List of fields to be returned for each item in the results.</param>
        /// <param name="propertyList">List of properties to be returned for each item in the results.</param>
        /// <param name="entities">List of entity names to include in response (e.g. company,email)</param>
        /// <param name="useCache">Specifies whether the results should be loaded from and stored in cache.</param>
        /// <param name="forceCacheDelete">Specifies whether the cached results should be deleted before performing the search.</param>
        /// <param name="sortField">Any field in the metadata profile which you want to sort by.</param>
        /// <param name="sortOrder">Sets the sort order for the results.</param>
        /// <param name="relationType">The relation to apply to the found items.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SearchNativeResult> SearchGetAsync(string nuix_auth_token, string caseId, string query, int? startIndex, int? numberOfRecordsRequested, Deduplicate? deduplicate, string metadataProfile, System.Collections.Generic.IEnumerable<string> fieldList, System.Collections.Generic.IEnumerable<string> propertyList, System.Collections.Generic.IEnumerable<string> entities, bool? useCache, bool? forceCacheDelete, string sortField, SortOrder? sortOrder, RelationType? relationType)
        {
            return SearchGetAsync(nuix_auth_token, caseId, query, startIndex, numberOfRecordsRequested, deduplicate, metadataProfile, fieldList, propertyList, entities, useCache, forceCacheDelete, sortField, sortOrder, relationType, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Performs a search</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="query">Identifies what items should be returned.  If a query is not supplied it defaults to an empty string, which returns all items.</param>
        /// <param name="startIndex">The index of the first record that should be returned. Defaults to 0.</param>
        /// <param name="numberOfRecordsRequested">The number of records that should be returned. Defaults to all records.</param>
        /// <param name="deduplicate">Deduplicate content based on the Value field selection. The default is no deduplication.</param>
        /// <param name="metadataProfile">Defines the metadata profile to be appied to the results. Needed to get custom metadata. Defaults to no metadata profile.</param>
        /// <param name="fieldList">List of fields to be returned for each item in the results.</param>
        /// <param name="propertyList">List of properties to be returned for each item in the results.</param>
        /// <param name="entities">List of entity names to include in response (e.g. company,email)</param>
        /// <param name="useCache">Specifies whether the results should be loaded from and stored in cache.</param>
        /// <param name="forceCacheDelete">Specifies whether the cached results should be deleted before performing the search.</param>
        /// <param name="sortField">Any field in the metadata profile which you want to sort by.</param>
        /// <param name="sortOrder">Sets the sort order for the results.</param>
        /// <param name="relationType">The relation to apply to the found items.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SearchNativeResult> SearchGetAsync(string nuix_auth_token, string caseId, string query, int? startIndex, int? numberOfRecordsRequested, Deduplicate? deduplicate, string metadataProfile, System.Collections.Generic.IEnumerable<string> fieldList, System.Collections.Generic.IEnumerable<string> propertyList, System.Collections.Generic.IEnumerable<string> entities, bool? useCache, bool? forceCacheDelete, string sortField, SortOrder? sortOrder, RelationType? relationType, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v2/cases/{caseId}/search?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (query != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("query") + "=").Append(System.Uri.EscapeDataString(ConvertToString(query, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (startIndex != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("startIndex") + "=").Append(System.Uri.EscapeDataString(ConvertToString(startIndex, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (numberOfRecordsRequested != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("numberOfRecordsRequested") + "=").Append(System.Uri.EscapeDataString(ConvertToString(numberOfRecordsRequested, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deduplicate != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deduplicate") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deduplicate, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (metadataProfile != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("metadataProfile") + "=").Append(System.Uri.EscapeDataString(ConvertToString(metadataProfile, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fieldList != null)
            {
                foreach (var item_ in fieldList) { urlBuilder_.Append(System.Uri.EscapeDataString("fieldList") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (propertyList != null)
            {
                foreach (var item_ in propertyList) { urlBuilder_.Append(System.Uri.EscapeDataString("propertyList") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (entities != null)
            {
                foreach (var item_ in entities) { urlBuilder_.Append(System.Uri.EscapeDataString("entities") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (useCache != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("useCache") + "=").Append(System.Uri.EscapeDataString(ConvertToString(useCache, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (forceCacheDelete != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("forceCacheDelete") + "=").Append(System.Uri.EscapeDataString(ConvertToString(forceCacheDelete, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (sortField != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("sortField") + "=").Append(System.Uri.EscapeDataString(ConvertToString(sortField, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (sortOrder != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("sortOrder") + "=").Append(System.Uri.EscapeDataString(ConvertToString(sortOrder, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (relationType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("relationType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(relationType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SearchNativeResult>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SearchNativeResult);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Performs a large search</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="request">request</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SearchNativeResult> SearchPostAsync(string nuix_auth_token, string caseId, SearchNativeRequest request)
        {
            return SearchPostAsync(nuix_auth_token, caseId, request, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Performs a large search</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="request">request</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SearchNativeResult> SearchPostAsync(string nuix_auth_token, string caseId, SearchNativeRequest request, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v2/cases/{caseId}/search");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SearchNativeResult>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SearchNativeResult);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Creates new tags for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="tagRequest">The tag request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CreateTagListResponse> TagsPostAsync(string nuix_auth_token, TagList tagRequest, string caseId)
        {
            return TagsPostAsync(nuix_auth_token, tagRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Creates new tags for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="tagRequest">The tag request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>Created</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CreateTagListResponse> TagsPostAsync(string nuix_auth_token, TagList tagRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v2/cases/{caseId}/tags");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(tagRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "201")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CreateTagListResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(CreateTagListResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Deletes tags for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="tagRequest">The tag request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<DeleteTagListResponse> TagsDeleteAsync(string nuix_auth_token, TagList tagRequest, string caseId)
        {
            return TagsDeleteAsync(nuix_auth_token, tagRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Deletes tags for a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="tagRequest">The tag request body object</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<DeleteTagListResponse> TagsDeleteAsync(string nuix_auth_token, TagList tagRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v2/cases/{caseId}/tags");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(tagRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeleteTagListResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("No Content", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(DeleteTagListResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface IClusterRunsClient
    {
        /// <summary>Lists items in this cluster run</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="clusterRunName">Cluster run name</param>
        /// <param name="startIndex">Start index, defaults to 0</param>
        /// <param name="numberOfRecordsRequested">Number of records to return, defaults to all</param>
        /// <param name="clusterNumber">Cluter number.</param>
        /// <param name="isPivot">Match pivot items, defaults to all</param>
        /// <param name="isUnclustered">Matches items that did not cluster, despite being eligible to exist in a cluster.</param>
        /// <param name="isIgnored">Matches items that were ignored because they were ineligible to exist in a cluster.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SearchNativeResult> ItemsAsync(string nuix_auth_token, string caseId, string clusterRunName, int? startIndex, int? numberOfRecordsRequested, int? clusterNumber, bool? isPivot, bool? isUnclustered, bool? isIgnored);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Lists items in this cluster run</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="clusterRunName">Cluster run name</param>
        /// <param name="startIndex">Start index, defaults to 0</param>
        /// <param name="numberOfRecordsRequested">Number of records to return, defaults to all</param>
        /// <param name="clusterNumber">Cluter number.</param>
        /// <param name="isPivot">Match pivot items, defaults to all</param>
        /// <param name="isUnclustered">Matches items that did not cluster, despite being eligible to exist in a cluster.</param>
        /// <param name="isIgnored">Matches items that were ignored because they were ineligible to exist in a cluster.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SearchNativeResult> ItemsAsync(string nuix_auth_token, string caseId, string clusterRunName, int? startIndex, int? numberOfRecordsRequested, int? clusterNumber, bool? isPivot, bool? isUnclustered, bool? isIgnored, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ClusterRunsClient : IClusterRunsClient
    {
        private string _baseUrl = "localhost:8080/nuix-restful-service/svc";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public ClusterRunsClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>Lists items in this cluster run</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="clusterRunName">Cluster run name</param>
        /// <param name="startIndex">Start index, defaults to 0</param>
        /// <param name="numberOfRecordsRequested">Number of records to return, defaults to all</param>
        /// <param name="clusterNumber">Cluter number.</param>
        /// <param name="isPivot">Match pivot items, defaults to all</param>
        /// <param name="isUnclustered">Matches items that did not cluster, despite being eligible to exist in a cluster.</param>
        /// <param name="isIgnored">Matches items that were ignored because they were ineligible to exist in a cluster.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SearchNativeResult> ItemsAsync(string nuix_auth_token, string caseId, string clusterRunName, int? startIndex, int? numberOfRecordsRequested, int? clusterNumber, bool? isPivot, bool? isUnclustered, bool? isIgnored)
        {
            return ItemsAsync(nuix_auth_token, caseId, clusterRunName, startIndex, numberOfRecordsRequested, clusterNumber, isPivot, isUnclustered, isIgnored, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Lists items in this cluster run</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="clusterRunName">Cluster run name</param>
        /// <param name="startIndex">Start index, defaults to 0</param>
        /// <param name="numberOfRecordsRequested">Number of records to return, defaults to all</param>
        /// <param name="clusterNumber">Cluter number.</param>
        /// <param name="isPivot">Match pivot items, defaults to all</param>
        /// <param name="isUnclustered">Matches items that did not cluster, despite being eligible to exist in a cluster.</param>
        /// <param name="isIgnored">Matches items that were ignored because they were ineligible to exist in a cluster.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SearchNativeResult> ItemsAsync(string nuix_auth_token, string caseId, string clusterRunName, int? startIndex, int? numberOfRecordsRequested, int? clusterNumber, bool? isPivot, bool? isUnclustered, bool? isIgnored, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/clusterRuns/{clusterRunName}/items?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (clusterRunName != null)
                urlBuilder_.Replace("{clusterRunName}", System.Uri.EscapeDataString(ConvertToString(clusterRunName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{clusterRunName}", string.Empty);
            if (startIndex != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("startIndex") + "=").Append(System.Uri.EscapeDataString(ConvertToString(startIndex, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (numberOfRecordsRequested != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("numberOfRecordsRequested") + "=").Append(System.Uri.EscapeDataString(ConvertToString(numberOfRecordsRequested, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (clusterNumber != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("clusterNumber") + "=").Append(System.Uri.EscapeDataString(ConvertToString(clusterNumber, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isPivot != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isPivot") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isPivot, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isUnclustered != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isUnclustered") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isUnclustered, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isIgnored != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("isIgnored") + "=").Append(System.Uri.EscapeDataString(ConvertToString(isIgnored, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SearchNativeResult>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SearchNativeResult);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface IEvidenceClient
    {
        /// <summary>Ingests a new Centera target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> CenteraAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleCenteraCluster ingestionRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new Centera target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> CenteraAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleCenteraCluster ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Ingests a new Dropbox target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> DropboxAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleDropbox ingestionRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new Dropbox target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> DropboxAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleDropbox ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Ingests a new enterprise vault target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor and container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> EvAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleEnterpriseVault ingestionRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new enterprise vault target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor and container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> EvAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleEnterpriseVault ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Ingests a new Exchange target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ExchangeAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleExchangeMailbox ingestionRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new Exchange target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ExchangeAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleExchangeMailbox ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Ingests a new file/directory target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> FileAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleFile ingestionRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new file/directory target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> FileAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleFile ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Ingests a new load file target into a container within a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> LoadFileAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleLoadFile ingestionRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new load file target into a container within a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> LoadFileAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleLoadFile ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Ingests a new mail target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> MailAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleMailStore ingestionRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new mail target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> MailAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleMailStore ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Ingests a directory and creates a repository in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, repository settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> RepositoryAsync(string nuix_auth_token, SingleRepositoryIngestionRequest ingestionRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a directory and creates a repository in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, repository settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> RepositoryAsync(string nuix_auth_token, SingleRepositoryIngestionRequest ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Ingests a new S3 target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> S3Async(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleS3Bucket ingestionRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new S3 target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> S3Async(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleS3Bucket ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Ingests a new SharePoint target into a container within a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> SharepointAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleSharepoint ingestionRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new SharePoint target into a container within a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> SharepointAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleSharepoint ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Ingests a new split file list target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> SplitFilesAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleSplitFileList ingestionRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new split file list target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> SplitFilesAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleSplitFileList ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Ingests a new SQL target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> SqlAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleSQLServer ingestionRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new SQL target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> SqlAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleSQLServer ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Ingests a new SSH-based target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> SshAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleSSH ingestionRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new SSH-based target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> SshAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleSSH ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class EvidenceClient : IEvidenceClient
    {
        private string _baseUrl = "localhost:8080/nuix-restful-service/svc";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public EvidenceClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>Ingests a new Centera target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> CenteraAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleCenteraCluster ingestionRequest, string caseId)
        {
            return CenteraAsync(nuix_auth_token, ingestionRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new Centera target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> CenteraAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleCenteraCluster ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/evidence/centera");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(ingestionRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Ingests a new Dropbox target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> DropboxAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleDropbox ingestionRequest, string caseId)
        {
            return DropboxAsync(nuix_auth_token, ingestionRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new Dropbox target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> DropboxAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleDropbox ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/evidence/dropbox");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(ingestionRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Ingests a new enterprise vault target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor and container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> EvAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleEnterpriseVault ingestionRequest, string caseId)
        {
            return EvAsync(nuix_auth_token, ingestionRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new enterprise vault target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor and container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> EvAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleEnterpriseVault ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/evidence/ev");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(ingestionRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Ingests a new Exchange target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> ExchangeAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleExchangeMailbox ingestionRequest, string caseId)
        {
            return ExchangeAsync(nuix_auth_token, ingestionRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new Exchange target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> ExchangeAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleExchangeMailbox ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/evidence/exchange");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(ingestionRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Ingests a new file/directory target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> FileAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleFile ingestionRequest, string caseId)
        {
            return FileAsync(nuix_auth_token, ingestionRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new file/directory target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> FileAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleFile ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/evidence/file");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(ingestionRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Ingests a new load file target into a container within a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> LoadFileAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleLoadFile ingestionRequest, string caseId)
        {
            return LoadFileAsync(nuix_auth_token, ingestionRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new load file target into a container within a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> LoadFileAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleLoadFile ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/evidence/loadFile");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(ingestionRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Ingests a new mail target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> MailAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleMailStore ingestionRequest, string caseId)
        {
            return MailAsync(nuix_auth_token, ingestionRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new mail target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> MailAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleMailStore ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/evidence/mail");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(ingestionRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Ingests a directory and creates a repository in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, repository settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> RepositoryAsync(string nuix_auth_token, SingleRepositoryIngestionRequest ingestionRequest, string caseId)
        {
            return RepositoryAsync(nuix_auth_token, ingestionRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a directory and creates a repository in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, repository settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> RepositoryAsync(string nuix_auth_token, SingleRepositoryIngestionRequest ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/evidence/repository");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(ingestionRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Ingests a new S3 target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> S3Async(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleS3Bucket ingestionRequest, string caseId)
        {
            return S3Async(nuix_auth_token, ingestionRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new S3 target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> S3Async(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleS3Bucket ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/evidence/s3");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(ingestionRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Ingests a new SharePoint target into a container within a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> SharepointAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleSharepoint ingestionRequest, string caseId)
        {
            return SharepointAsync(nuix_auth_token, ingestionRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new SharePoint target into a container within a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> SharepointAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleSharepoint ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/evidence/sharepoint");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(ingestionRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Ingests a new split file list target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> SplitFilesAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleSplitFileList ingestionRequest, string caseId)
        {
            return SplitFilesAsync(nuix_auth_token, ingestionRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new split file list target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> SplitFilesAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleSplitFileList ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/evidence/splitFiles");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(ingestionRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Ingests a new SQL target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> SqlAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleSQLServer ingestionRequest, string caseId)
        {
            return SqlAsync(nuix_auth_token, ingestionRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new SQL target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> SqlAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleSQLServer ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/evidence/sql");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(ingestionRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Ingests a new SSH-based target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> SshAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleSSH ingestionRequest, string caseId)
        {
            return SshAsync(nuix_auth_token, ingestionRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Ingests a new SSH-based target into a container in a simple case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="ingestionRequest">The request body object containing processor, container/target settings</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> SshAsync(string nuix_auth_token, SingleContainerIngestionRequestOfIngestibleSSH ingestionRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/evidence/ssh");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(ingestionRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface IItemSetsClient
    {
        /// <summary>Returns the batches in this item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ItemSetBatchResponse>> BatchesAsync(string nuix_auth_token, string caseId, string itemSetName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the batches in this item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ItemSetBatchResponse>> BatchesAsync(string nuix_auth_token, string caseId, string itemSetName, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the duplicate items in this set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="batch">Item set batch name, defaults to all batches</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ItemSetDuplicatesResponse> DuplicatesGetAsync(string nuix_auth_token, string caseId, string itemSetName, string batch);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the duplicate items in this set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="batch">Item set batch name, defaults to all batches</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ItemSetDuplicatesResponse> DuplicatesGetAsync(string nuix_auth_token, string caseId, string itemSetName, string batch, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns items in an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="batchName">Batch name (null for all batches)</param>
        /// <param name="startIndex">Start index, defaults to 0</param>
        /// <param name="numberOfRecordsRequested">Number of records to return, defaults to all</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SearchNativeResult> ItemsGetAsync(string nuix_auth_token, string caseId, string itemSetName, string batchName, int? startIndex, int? numberOfRecordsRequested);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns items in an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="batchName">Batch name (null for all batches)</param>
        /// <param name="startIndex">Start index, defaults to 0</param>
        /// <param name="numberOfRecordsRequested">Number of records to return, defaults to all</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SearchNativeResult> ItemsGetAsync(string nuix_auth_token, string caseId, string itemSetName, string batchName, int? startIndex, int? numberOfRecordsRequested, System.Threading.CancellationToken cancellationToken);

        /// <summary>Adds items to an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="itemSetRequest">The item set add items request body</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ItemsPostAsync(string nuix_auth_token, string caseId, string itemSetName, ItemSetAddItemsRequest itemSetRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Adds items to an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="itemSetRequest">The item set add items request body</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ItemsPostAsync(string nuix_auth_token, string caseId, string itemSetName, ItemSetAddItemsRequest itemSetRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Removes items from an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="itemSetRequest">The remove items request body</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ItemsDeleteAsync(string nuix_auth_token, string caseId, string itemSetName, ItemSetRemoveItemsRequest itemSetRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Removes items from an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="itemSetRequest">The remove items request body</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ItemsDeleteAsync(string nuix_auth_token, string caseId, string itemSetName, ItemSetRemoveItemsRequest itemSetRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns duplicates for an item in an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="itemGuid">Item guid to find duplicates of</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ItemSetDuplicatesResponse> ItemSetDuplicatesGetAsync(string nuix_auth_token, string caseId, string itemSetName, string itemGuid);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns duplicates for an item in an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="itemGuid">Item guid to find duplicates of</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ItemSetDuplicatesResponse> ItemSetDuplicatesGetAsync(string nuix_auth_token, string caseId, string itemSetName, string itemGuid, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ItemSetsClient : IItemSetsClient
    {
        private string _baseUrl = "localhost:8080/nuix-restful-service/svc";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public ItemSetsClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>Returns the batches in this item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ItemSetBatchResponse>> BatchesAsync(string nuix_auth_token, string caseId, string itemSetName)
        {
            return BatchesAsync(nuix_auth_token, caseId, itemSetName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the batches in this item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ItemSetBatchResponse>> BatchesAsync(string nuix_auth_token, string caseId, string itemSetName, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemSets/{itemSetName}/batches");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemSetName != null)
                urlBuilder_.Replace("{itemSetName}", System.Uri.EscapeDataString(ConvertToString(itemSetName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemSetName}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<ItemSetBatchResponse>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<ItemSetBatchResponse>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the duplicate items in this set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="batch">Item set batch name, defaults to all batches</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ItemSetDuplicatesResponse> DuplicatesGetAsync(string nuix_auth_token, string caseId, string itemSetName, string batch)
        {
            return DuplicatesGetAsync(nuix_auth_token, caseId, itemSetName, batch, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the duplicate items in this set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="batch">Item set batch name, defaults to all batches</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ItemSetDuplicatesResponse> DuplicatesGetAsync(string nuix_auth_token, string caseId, string itemSetName, string batch, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemSets/{itemSetName}/duplicates?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemSetName != null)
                urlBuilder_.Replace("{itemSetName}", System.Uri.EscapeDataString(ConvertToString(itemSetName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemSetName}", string.Empty);
            if (batch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("batch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(batch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ItemSetDuplicatesResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ItemSetDuplicatesResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns items in an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="batchName">Batch name (null for all batches)</param>
        /// <param name="startIndex">Start index, defaults to 0</param>
        /// <param name="numberOfRecordsRequested">Number of records to return, defaults to all</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SearchNativeResult> ItemsGetAsync(string nuix_auth_token, string caseId, string itemSetName, string batchName, int? startIndex, int? numberOfRecordsRequested)
        {
            return ItemsGetAsync(nuix_auth_token, caseId, itemSetName, batchName, startIndex, numberOfRecordsRequested, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns items in an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="batchName">Batch name (null for all batches)</param>
        /// <param name="startIndex">Start index, defaults to 0</param>
        /// <param name="numberOfRecordsRequested">Number of records to return, defaults to all</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SearchNativeResult> ItemsGetAsync(string nuix_auth_token, string caseId, string itemSetName, string batchName, int? startIndex, int? numberOfRecordsRequested, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemSets/{itemSetName}/items?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemSetName != null)
                urlBuilder_.Replace("{itemSetName}", System.Uri.EscapeDataString(ConvertToString(itemSetName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemSetName}", string.Empty);
            if (batchName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("batchName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(batchName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (startIndex != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("startIndex") + "=").Append(System.Uri.EscapeDataString(ConvertToString(startIndex, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (numberOfRecordsRequested != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("numberOfRecordsRequested") + "=").Append(System.Uri.EscapeDataString(ConvertToString(numberOfRecordsRequested, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SearchNativeResult>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SearchNativeResult);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Adds items to an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="itemSetRequest">The item set add items request body</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> ItemsPostAsync(string nuix_auth_token, string caseId, string itemSetName, ItemSetAddItemsRequest itemSetRequest)
        {
            return ItemsPostAsync(nuix_auth_token, caseId, itemSetName, itemSetRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Adds items to an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="itemSetRequest">The item set add items request body</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> ItemsPostAsync(string nuix_auth_token, string caseId, string itemSetName, ItemSetAddItemsRequest itemSetRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemSets/{itemSetName}/items");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemSetName != null)
                urlBuilder_.Replace("{itemSetName}", System.Uri.EscapeDataString(ConvertToString(itemSetName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemSetName}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(itemSetRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Removes items from an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="itemSetRequest">The remove items request body</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ItemsDeleteAsync(string nuix_auth_token, string caseId, string itemSetName, ItemSetRemoveItemsRequest itemSetRequest)
        {
            return ItemsDeleteAsync(nuix_auth_token, caseId, itemSetName, itemSetRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Removes items from an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="itemSetRequest">The remove items request body</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task ItemsDeleteAsync(string nuix_auth_token, string caseId, string itemSetName, ItemSetRemoveItemsRequest itemSetRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemSets/{itemSetName}/items");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemSetName != null)
                urlBuilder_.Replace("{itemSetName}", System.Uri.EscapeDataString(ConvertToString(itemSetName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemSetName}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(itemSetRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns duplicates for an item in an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="itemGuid">Item guid to find duplicates of</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ItemSetDuplicatesResponse> ItemSetDuplicatesGetAsync(string nuix_auth_token, string caseId, string itemSetName, string itemGuid)
        {
            return DuplicatesGetAsync(nuix_auth_token, caseId, itemSetName, itemGuid, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns duplicates for an item in an item set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemSetName">Item set name</param>
        /// <param name="itemGuid">Item guid to find duplicates of</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ItemSetDuplicatesResponse> ItemSetDuplicatesGetAsync(string nuix_auth_token, string caseId, string itemSetName, string itemGuid, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/itemSets/{itemSetName}/{itemGuid}/duplicates");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemSetName != null)
                urlBuilder_.Replace("{itemSetName}", System.Uri.EscapeDataString(ConvertToString(itemSetName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemSetName}", string.Empty);
            if (itemGuid != null)
                urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemGuid}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ItemSetDuplicatesResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ItemSetDuplicatesResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface IItemsClient
    {
        /// <summary>Performs OCR on query items</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="ocrRequest">The OCR request body object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<AsyncFunctionResponse> OcrPutAsync(string nuix_auth_token, string caseId, OcrRequest ocrRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Performs OCR on query items</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="ocrRequest">The OCR request body object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<AsyncFunctionResponse> OcrPutAsync(string nuix_auth_token, string caseId, OcrRequest ocrRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns comments for an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ItemCommentResponse> CommentGetAsync(string nuix_auth_token, string caseId, string itemGuid);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns comments for an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ItemCommentResponse> CommentGetAsync(string nuix_auth_token, string caseId, string itemGuid, System.Threading.CancellationToken cancellationToken);

        /// <summary>Applies a comment to an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="itemComment">Comments about the item</param>
        /// <param name="append">Append to existing comment</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ItemCommentResponse> CommentPutAsync(string nuix_auth_token, string caseId, string itemGuid, ItemCommentRequest itemComment, bool? append);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Applies a comment to an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="itemComment">Comments about the item</param>
        /// <param name="append">Append to existing comment</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ItemCommentResponse> CommentPutAsync(string nuix_auth_token, string caseId, string itemGuid, ItemCommentRequest itemComment, bool? append, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns custom metadata for an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="fieldNameFilter">Field name filter.  Filters metadata fields that are returned.  Fields that do not match the regular expression are removed by the filter.</param>
        /// <param name="typeFilter">Type filter.  Filters metadata fields that are returned.  Fields that do not match the type are removed by the filter.</param>
        /// <param name="modeFilter">Mode filter.  Filters metadata fields that are returned.  Fields that do not match the mode are removed by the filter.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CustomMetadataResponse>> CustomMetadataGetAsync(string nuix_auth_token, string caseId, string itemGuid, string fieldNameFilter, TypeFilter? typeFilter, ModeFilter? modeFilter);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns custom metadata for an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="fieldNameFilter">Field name filter.  Filters metadata fields that are returned.  Fields that do not match the regular expression are removed by the filter.</param>
        /// <param name="typeFilter">Type filter.  Filters metadata fields that are returned.  Fields that do not match the type are removed by the filter.</param>
        /// <param name="modeFilter">Mode filter.  Filters metadata fields that are returned.  Fields that do not match the mode are removed by the filter.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CustomMetadataResponse>> CustomMetadataGetAsync(string nuix_auth_token, string caseId, string itemGuid, string fieldNameFilter, TypeFilter? typeFilter, ModeFilter? modeFilter, System.Threading.CancellationToken cancellationToken);

        /// <summary>Applies custom metadata to an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="applyToFamily">Apply metadata to family items</param>
        /// <param name="applyToDuplicates">Apply metadata to duplicates</param>
        /// <param name="customMetadata">customMetadata</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CustomMetadataPutAsync(string nuix_auth_token, string caseId, string itemGuid, bool? applyToFamily, bool? applyToDuplicates, CustomMetadataRequest customMetadata);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Applies custom metadata to an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="applyToFamily">Apply metadata to family items</param>
        /// <param name="applyToDuplicates">Apply metadata to duplicates</param>
        /// <param name="customMetadata">customMetadata</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CustomMetadataPutAsync(string nuix_auth_token, string caseId, string itemGuid, bool? applyToFamily, bool? applyToDuplicates, CustomMetadataRequest customMetadata, System.Threading.CancellationToken cancellationToken);

        /// <summary>Removes custom metadata on an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="applyToFamily">Remove metadata from family items</param>
        /// <param name="applyToDuplicates">Remove metadata from duplicates</param>
        /// <param name="fieldName">Field name</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CustomMetadataDeleteAsync(string nuix_auth_token, string caseId, string itemGuid, bool? applyToFamily, bool? applyToDuplicates, string fieldName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Removes custom metadata on an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="applyToFamily">Remove metadata from family items</param>
        /// <param name="applyToDuplicates">Remove metadata from duplicates</param>
        /// <param name="fieldName">Field name</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task CustomMetadataDeleteAsync(string nuix_auth_token, string caseId, string itemGuid, bool? applyToFamily, bool? applyToDuplicates, string fieldName, System.Threading.CancellationToken cancellationToken);

        /// <summary>Downloads an item from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="overwriteExisting">Overwrite Existing; this value is treated as always true for PDFs</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileSystemResource> DownloadGetAsync(string nuix_auth_token, string caseId, string itemGuid, bool? overwriteExisting);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Downloads an item from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="overwriteExisting">Overwrite Existing; this value is treated as always true for PDFs</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileSystemResource> DownloadGetAsync(string nuix_auth_token, string caseId, string itemGuid, bool? overwriteExisting, System.Threading.CancellationToken cancellationToken);

        /// <summary>Downloads an item from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="overwriteExisting">Overwrite Existing; this value is treated as always true for PDFs</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> DownloadHeadAsync(string nuix_auth_token, string caseId, string itemGuid, bool? overwriteExisting);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Downloads an item from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="overwriteExisting">Overwrite Existing; this value is treated as always true for PDFs</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> DownloadHeadAsync(string nuix_auth_token, string caseId, string itemGuid, bool? overwriteExisting, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns item text</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="htmlEscape">Replaces newline and tab characters with their HTML variants</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ItemTextResponse> ItemTextAsync(string nuix_auth_token, string caseId, string itemGuid, bool? htmlEscape);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns item text</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="htmlEscape">Replaces newline and tab characters with their HTML variants</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ItemTextResponse> ItemTextAsync(string nuix_auth_token, string caseId, string itemGuid, bool? htmlEscape, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns search hits for an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="searchHitRequest">Search hit request body</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="property">List of properties associated with this item</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SearchHitResponse> SearchHitsAsync(string nuix_auth_token, string caseId, SearchHitRequest searchHitRequest, string itemGuid, System.Collections.Generic.IEnumerable<string> property);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns search hits for an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="searchHitRequest">Search hit request body</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="property">List of properties associated with this item</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SearchHitResponse> SearchHitsAsync(string nuix_auth_token, string caseId, SearchHitRequest searchHitRequest, string itemGuid, System.Collections.Generic.IEnumerable<string> property, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the list of tags for an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TagList> TagsGetAsync(string nuix_auth_token, string caseId, string itemGuid);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the list of tags for an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TagList> TagsGetAsync(string nuix_auth_token, string caseId, string itemGuid, System.Threading.CancellationToken cancellationToken);

        /// <summary>Tags an item in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="tagName">Tag name</param>
        /// <param name="applyToFamily">Tag family items</param>
        /// <param name="applyToDuplicates">Tag duplicates</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GenericResponse> TagsPutAsync(string nuix_auth_token, string caseId, string itemGuid, string tagName, bool? applyToFamily, bool? applyToDuplicates);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Tags an item in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="tagName">Tag name</param>
        /// <param name="applyToFamily">Tag family items</param>
        /// <param name="applyToDuplicates">Tag duplicates</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GenericResponse> TagsPutAsync(string nuix_auth_token, string caseId, string itemGuid, string tagName, bool? applyToFamily, bool? applyToDuplicates, System.Threading.CancellationToken cancellationToken);

        /// <summary>Removes a tag from an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="tagName">Tag name</param>
        /// <param name="applyToFamily">Removes tags from family items. Defaults to false.</param>
        /// <param name="applyToDuplicates">Removes tags from the item's duplicates. Defaults to false.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GenericResponse> TagsDeleteAsync(string nuix_auth_token, string caseId, string itemGuid, string tagName, bool? applyToFamily, bool? applyToDuplicates);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Removes a tag from an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="tagName">Tag name</param>
        /// <param name="applyToFamily">Removes tags from family items. Defaults to false.</param>
        /// <param name="applyToDuplicates">Removes tags from the item's duplicates. Defaults to false.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GenericResponse> TagsDeleteAsync(string nuix_auth_token, string caseId, string itemGuid, string tagName, bool? applyToFamily, bool? applyToDuplicates, System.Threading.CancellationToken cancellationToken);

        /// <summary>Enables you to view a case item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="overwriteExisting">Overwrite Existing</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileSystemResource> ViewGetAsync(string nuix_auth_token, string caseId, string itemGuid, bool? overwriteExisting);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Enables you to view a case item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="overwriteExisting">Overwrite Existing</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileSystemResource> ViewGetAsync(string nuix_auth_token, string caseId, string itemGuid, bool? overwriteExisting, System.Threading.CancellationToken cancellationToken);

        /// <summary>Enables you to view a case item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="overwriteExisting">Overwrite Existing</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> ViewHeadAsync(string nuix_auth_token, string caseId, string itemGuid, bool? overwriteExisting);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Enables you to view a case item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="overwriteExisting">Overwrite Existing</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> ViewHeadAsync(string nuix_auth_token, string caseId, string itemGuid, bool? overwriteExisting, System.Threading.CancellationToken cancellationToken);

        /// <summary>Performs OCR on query items</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="ocrRequest">The OCR request body object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> OcrPutAsync(string nuix_auth_token, string caseId, OcrRequestV2 ocrRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Performs OCR on query items</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="ocrRequest">The OCR request body object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> OcrPutAsync(string nuix_auth_token, string caseId, OcrRequestV2 ocrRequest, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ItemsClient : IItemsClient
    {
        private string _baseUrl = "localhost:8080/nuix-restful-service/svc";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public ItemsClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>Performs OCR on query items</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="ocrRequest">The OCR request body object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<AsyncFunctionResponse> OcrPutAsync(string nuix_auth_token, string caseId, OcrRequest ocrRequest)
        {
            return OcrPutAsync(nuix_auth_token, caseId, ocrRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Performs OCR on query items</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="ocrRequest">The OCR request body object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> OcrPutAsync(string nuix_auth_token, string caseId, OcrRequest ocrRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/items/ocr");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(ocrRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns comments for an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ItemCommentResponse> CommentGetAsync(string nuix_auth_token, string caseId, string itemGuid)
        {
            return CommentGetAsync(nuix_auth_token, caseId, itemGuid, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns comments for an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ItemCommentResponse> CommentGetAsync(string nuix_auth_token, string caseId, string itemGuid, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/items/{itemGuid}/comment");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemGuid != null)
                urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemGuid}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ItemCommentResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ItemCommentResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Applies a comment to an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="itemComment">Comments about the item</param>
        /// <param name="append">Append to existing comment</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ItemCommentResponse> CommentPutAsync(string nuix_auth_token, string caseId, string itemGuid, ItemCommentRequest itemComment, bool? append)
        {
            return CommentPutAsync(nuix_auth_token, caseId, itemGuid, itemComment, append, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Applies a comment to an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="itemComment">Comments about the item</param>
        /// <param name="append">Append to existing comment</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ItemCommentResponse> CommentPutAsync(string nuix_auth_token, string caseId, string itemGuid, ItemCommentRequest itemComment, bool? append, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/items/{itemGuid}/comment?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemGuid != null)
                urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemGuid}", string.Empty);
            if (append != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("append") + "=").Append(System.Uri.EscapeDataString(ConvertToString(append, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(itemComment, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ItemCommentResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ItemCommentResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns custom metadata for an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="fieldNameFilter">Field name filter.  Filters metadata fields that are returned.  Fields that do not match the regular expression are removed by the filter.</param>
        /// <param name="typeFilter">Type filter.  Filters metadata fields that are returned.  Fields that do not match the type are removed by the filter.</param>
        /// <param name="modeFilter">Mode filter.  Filters metadata fields that are returned.  Fields that do not match the mode are removed by the filter.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CustomMetadataResponse>> CustomMetadataGetAsync(string nuix_auth_token, string caseId, string itemGuid, string fieldNameFilter, TypeFilter? typeFilter, ModeFilter? modeFilter)
        {
            return CustomMetadataGetAsync(nuix_auth_token, caseId, itemGuid, fieldNameFilter, typeFilter, modeFilter, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns custom metadata for an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="fieldNameFilter">Field name filter.  Filters metadata fields that are returned.  Fields that do not match the regular expression are removed by the filter.</param>
        /// <param name="typeFilter">Type filter.  Filters metadata fields that are returned.  Fields that do not match the type are removed by the filter.</param>
        /// <param name="modeFilter">Mode filter.  Filters metadata fields that are returned.  Fields that do not match the mode are removed by the filter.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CustomMetadataResponse>> CustomMetadataGetAsync(string nuix_auth_token, string caseId, string itemGuid, string fieldNameFilter, TypeFilter? typeFilter, ModeFilter? modeFilter, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/items/{itemGuid}/customMetadata?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemGuid != null)
                urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemGuid}", string.Empty);
            if (fieldNameFilter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fieldNameFilter") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fieldNameFilter, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (typeFilter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("typeFilter") + "=").Append(System.Uri.EscapeDataString(ConvertToString(typeFilter, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (modeFilter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("modeFilter") + "=").Append(System.Uri.EscapeDataString(ConvertToString(modeFilter, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<CustomMetadataResponse>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<CustomMetadataResponse>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Applies custom metadata to an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="applyToFamily">Apply metadata to family items</param>
        /// <param name="applyToDuplicates">Apply metadata to duplicates</param>
        /// <param name="customMetadata">customMetadata</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task CustomMetadataPutAsync(string nuix_auth_token, string caseId, string itemGuid, bool? applyToFamily, bool? applyToDuplicates, CustomMetadataRequest customMetadata)
        {
            return CustomMetadataPutAsync(nuix_auth_token, caseId, itemGuid, applyToFamily, applyToDuplicates, customMetadata, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Applies custom metadata to an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="applyToFamily">Apply metadata to family items</param>
        /// <param name="applyToDuplicates">Apply metadata to duplicates</param>
        /// <param name="customMetadata">customMetadata</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task CustomMetadataPutAsync(string nuix_auth_token, string caseId, string itemGuid, bool? applyToFamily, bool? applyToDuplicates, CustomMetadataRequest customMetadata, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/items/{itemGuid}/customMetadata?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemGuid != null)
                urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemGuid}", string.Empty);
            if (applyToFamily != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applyToFamily") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applyToFamily, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (applyToDuplicates != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applyToDuplicates") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applyToDuplicates, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(customMetadata, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            return;
                        }
                        else
                        if (status_ == "201")
                        {
                            return;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Removes custom metadata on an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="applyToFamily">Remove metadata from family items</param>
        /// <param name="applyToDuplicates">Remove metadata from duplicates</param>
        /// <param name="fieldName">Field name</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task CustomMetadataDeleteAsync(string nuix_auth_token, string caseId, string itemGuid, bool? applyToFamily, bool? applyToDuplicates, string fieldName)
        {
            return CustomMetadataDeleteAsync(nuix_auth_token, caseId, itemGuid, applyToFamily, applyToDuplicates, fieldName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Removes custom metadata on an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="applyToFamily">Remove metadata from family items</param>
        /// <param name="applyToDuplicates">Remove metadata from duplicates</param>
        /// <param name="fieldName">Field name</param>
        /// <returns>No Content</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task CustomMetadataDeleteAsync(string nuix_auth_token, string caseId, string itemGuid, bool? applyToFamily, bool? applyToDuplicates, string fieldName, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/items/{itemGuid}/customMetadata?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemGuid != null)
                urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemGuid}", string.Empty);
            if (applyToFamily != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applyToFamily") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applyToFamily, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (applyToDuplicates != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applyToDuplicates") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applyToDuplicates, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fieldName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fieldName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fieldName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            return;
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Downloads an item from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="overwriteExisting">Overwrite Existing; this value is treated as always true for PDFs</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileSystemResource> DownloadGetAsync(string nuix_auth_token, string caseId, string itemGuid, bool? overwriteExisting)
        {
            return DownloadGetAsync(nuix_auth_token, caseId, itemGuid, overwriteExisting, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Downloads an item from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="overwriteExisting">Overwrite Existing; this value is treated as always true for PDFs</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FileSystemResource> DownloadGetAsync(string nuix_auth_token, string caseId, string itemGuid, bool? overwriteExisting, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/items/{itemGuid}/download?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemGuid != null)
                urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemGuid}", string.Empty);
            if (overwriteExisting != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("overwriteExisting") + "=").Append(System.Uri.EscapeDataString(ConvertToString(overwriteExisting, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FileSystemResource>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileSystemResource);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Downloads an item from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="overwriteExisting">Overwrite Existing; this value is treated as always true for PDFs</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<string> DownloadHeadAsync(string nuix_auth_token, string caseId, string itemGuid, bool? overwriteExisting)
        {
            return DownloadHeadAsync(nuix_auth_token, caseId, itemGuid, overwriteExisting, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Downloads an item from a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="overwriteExisting">Overwrite Existing; this value is treated as always true for PDFs</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> DownloadHeadAsync(string nuix_auth_token, string caseId, string itemGuid, bool? overwriteExisting, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/items/{itemGuid}/download?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemGuid != null)
                urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemGuid}", string.Empty);
            if (overwriteExisting != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("overwriteExisting") + "=").Append(System.Uri.EscapeDataString(ConvertToString(overwriteExisting, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("HEAD");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("No Content", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(string);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns item text</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="htmlEscape">Replaces newline and tab characters with their HTML variants</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ItemTextResponse> ItemTextAsync(string nuix_auth_token, string caseId, string itemGuid, bool? htmlEscape)
        {
            return ItemTextAsync(nuix_auth_token, caseId, itemGuid, htmlEscape, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns item text</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="htmlEscape">Replaces newline and tab characters with their HTML variants</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ItemTextResponse> ItemTextAsync(string nuix_auth_token, string caseId, string itemGuid, bool? htmlEscape, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/items/{itemGuid}/itemText?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemGuid != null)
                urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemGuid}", string.Empty);
            if (htmlEscape != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("htmlEscape") + "=").Append(System.Uri.EscapeDataString(ConvertToString(htmlEscape, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ItemTextResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ItemTextResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns search hits for an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="searchHitRequest">Search hit request body</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="property">List of properties associated with this item</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SearchHitResponse> SearchHitsAsync(string nuix_auth_token, string caseId, SearchHitRequest searchHitRequest, string itemGuid, System.Collections.Generic.IEnumerable<string> property)
        {
            return SearchHitsAsync(nuix_auth_token, caseId, searchHitRequest, itemGuid, property, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns search hits for an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="searchHitRequest">Search hit request body</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="property">List of properties associated with this item</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SearchHitResponse> SearchHitsAsync(string nuix_auth_token, string caseId, SearchHitRequest searchHitRequest, string itemGuid, System.Collections.Generic.IEnumerable<string> property, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/items/{itemGuid}/searchHits?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemGuid != null)
                urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemGuid}", string.Empty);
            if (property != null)
            {
                foreach (var item_ in property) { urlBuilder_.Append(System.Uri.EscapeDataString("property") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(searchHitRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SearchHitResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SearchHitResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the list of tags for an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<TagList> TagsGetAsync(string nuix_auth_token, string caseId, string itemGuid)
        {
            return TagsGetAsync(nuix_auth_token, caseId, itemGuid, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the list of tags for an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<TagList> TagsGetAsync(string nuix_auth_token, string caseId, string itemGuid, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/items/{itemGuid}/tags");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemGuid != null)
                urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemGuid}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TagList>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(TagList);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Tags an item in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="tagName">Tag name</param>
        /// <param name="applyToFamily">Tag family items</param>
        /// <param name="applyToDuplicates">Tag duplicates</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GenericResponse> TagsPutAsync(string nuix_auth_token, string caseId, string itemGuid, string tagName, bool? applyToFamily, bool? applyToDuplicates)
        {
            return TagsPutAsync(nuix_auth_token, caseId, itemGuid, tagName, applyToFamily, applyToDuplicates, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Tags an item in a case</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="tagName">Tag name</param>
        /// <param name="applyToFamily">Tag family items</param>
        /// <param name="applyToDuplicates">Tag duplicates</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GenericResponse> TagsPutAsync(string nuix_auth_token, string caseId, string itemGuid, string tagName, bool? applyToFamily, bool? applyToDuplicates, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/items/{itemGuid}/tags/{tagName}?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemGuid != null)
                urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemGuid}", string.Empty);
            if (tagName != null)
                urlBuilder_.Replace("{tagName}", System.Uri.EscapeDataString(ConvertToString(tagName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{tagName}", string.Empty);
            if (applyToFamily != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applyToFamily") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applyToFamily, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (applyToDuplicates != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applyToDuplicates") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applyToDuplicates, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "*/*");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GenericResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(GenericResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Removes a tag from an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="tagName">Tag name</param>
        /// <param name="applyToFamily">Removes tags from family items. Defaults to false.</param>
        /// <param name="applyToDuplicates">Removes tags from the item's duplicates. Defaults to false.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GenericResponse> TagsDeleteAsync(string nuix_auth_token, string caseId, string itemGuid, string tagName, bool? applyToFamily, bool? applyToDuplicates)
        {
            return TagsDeleteAsync(nuix_auth_token, caseId, itemGuid, tagName, applyToFamily, applyToDuplicates, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Removes a tag from an item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="tagName">Tag name</param>
        /// <param name="applyToFamily">Removes tags from family items. Defaults to false.</param>
        /// <param name="applyToDuplicates">Removes tags from the item's duplicates. Defaults to false.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GenericResponse> TagsDeleteAsync(string nuix_auth_token, string caseId, string itemGuid, string tagName, bool? applyToFamily, bool? applyToDuplicates, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/items/{itemGuid}/tags/{tagName}?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemGuid != null)
                urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemGuid}", string.Empty);
            if (tagName != null)
                urlBuilder_.Replace("{tagName}", System.Uri.EscapeDataString(ConvertToString(tagName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{tagName}", string.Empty);
            if (applyToFamily != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applyToFamily") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applyToFamily, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (applyToDuplicates != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("applyToDuplicates") + "=").Append(System.Uri.EscapeDataString(ConvertToString(applyToDuplicates, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GenericResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("No Content", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(GenericResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Enables you to view a case item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="overwriteExisting">Overwrite Existing</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileSystemResource> ViewGetAsync(string nuix_auth_token, string caseId, string itemGuid, bool? overwriteExisting)
        {
            return ViewGetAsync(nuix_auth_token, caseId, itemGuid, overwriteExisting, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Enables you to view a case item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="overwriteExisting">Overwrite Existing</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FileSystemResource> ViewGetAsync(string nuix_auth_token, string caseId, string itemGuid, bool? overwriteExisting, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/items/{itemGuid}/view?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemGuid != null)
                urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemGuid}", string.Empty);
            if (overwriteExisting != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("overwriteExisting") + "=").Append(System.Uri.EscapeDataString(ConvertToString(overwriteExisting, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FileSystemResource>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileSystemResource);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Enables you to view a case item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="overwriteExisting">Overwrite Existing</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<string> ViewHeadAsync(string nuix_auth_token, string caseId, string itemGuid, bool? overwriteExisting)
        {
            return ViewHeadAsync(nuix_auth_token, caseId, itemGuid, overwriteExisting, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Enables you to view a case item</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="overwriteExisting">Overwrite Existing</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<string> ViewHeadAsync(string nuix_auth_token, string caseId, string itemGuid, bool? overwriteExisting, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/items/{itemGuid}/view?");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (itemGuid != null)
                urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{itemGuid}", string.Empty);
            if (overwriteExisting != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("overwriteExisting") + "=").Append(System.Uri.EscapeDataString(ConvertToString(overwriteExisting, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("HEAD");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<string>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("No Content", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(string);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Performs OCR on query items</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="ocrRequest">The OCR request body object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> OcrPutAsync(string nuix_auth_token, string caseId, OcrRequestV2 ocrRequest)
        {
            return OcrPutAsync(nuix_auth_token, caseId, ocrRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Performs OCR on query items</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="ocrRequest">The OCR request body object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> OcrPutAsync(string nuix_auth_token, string caseId, OcrRequestV2 ocrRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v2/cases/{caseId}/items/ocr");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(ocrRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface IItemClient
    {
        /// <summary>Returns a print preview for an item in the production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="pageNumber">The page number to be printed</param>
        /// <param name="generateNew">Force regeneration of print preview</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> PrintPreviewAsync(string nuix_auth_token, string caseId, string productionSetId, string itemGuid, int pageNumber, bool? generateNew);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns a print preview for an item in the production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="pageNumber">The page number to be printed</param>
        /// <param name="generateNew">Force regeneration of print preview</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> PrintPreviewAsync(string nuix_auth_token, string caseId, string productionSetId, string itemGuid, int pageNumber, bool? generateNew, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ItemClient : IItemClient
    {
        private string _baseUrl = "localhost:8080/nuix-restful-service/svc";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public ItemClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>Returns a print preview for an item in the production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="pageNumber">The page number to be printed</param>
        /// <param name="generateNew">Force regeneration of print preview</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> PrintPreviewAsync(string nuix_auth_token, string caseId, string productionSetId, string itemGuid, int pageNumber, bool? generateNew)
        {
            return PrintPreviewAsync(nuix_auth_token, caseId, productionSetId, itemGuid, pageNumber, generateNew, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns a print preview for an item in the production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <param name="itemGuid">Item GUID</param>
        /// <param name="pageNumber">The page number to be printed</param>
        /// <param name="generateNew">Force regeneration of print preview</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<byte[]>> PrintPreviewAsync(string nuix_auth_token, string caseId, string productionSetId, string itemGuid, int pageNumber, bool? generateNew, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            if (productionSetId == null)
                throw new System.ArgumentNullException("productionSetId");

            if (itemGuid == null)
                throw new System.ArgumentNullException("itemGuid");

            if (pageNumber == null)
                throw new System.ArgumentNullException("pageNumber");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/productionSets/{productionSetId}/item/{itemGuid}/printPreview?");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{productionSetId}", System.Uri.EscapeDataString(ConvertToString(productionSetId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{itemGuid}", System.Uri.EscapeDataString(ConvertToString(itemGuid, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append(System.Uri.EscapeDataString("pageNumber") + "=").Append(System.Uri.EscapeDataString(ConvertToString(pageNumber, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (generateNew != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("generateNew") + "=").Append(System.Uri.EscapeDataString(ConvertToString(generateNew, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<byte[]>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<byte[]>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface IProductionSetsClient
    {
        /// <summary>Returns the items in this production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <param name="startIndex">Start index, defaults to 0</param>
        /// <param name="numberOfRecordsRequested">Number of records to return, defaults to all</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SearchNativeResult> ItemsGetAsync(string nuix_auth_token, string caseId, string productionSetId, int? startIndex, int? numberOfRecordsRequested);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the items in this production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <param name="startIndex">Start index, defaults to 0</param>
        /// <param name="numberOfRecordsRequested">Number of records to return, defaults to all</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SearchNativeResult> ItemsGetAsync(string nuix_auth_token, string caseId, string productionSetId, int? startIndex, int? numberOfRecordsRequested, System.Threading.CancellationToken cancellationToken);

        /// <summary>Adds items to a production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <param name="productionSetRequest">Request body</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ItemsPostAsync(string nuix_auth_token, string productionSetId, ProductionSetRequest productionSetRequest, string caseId);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Adds items to a production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <param name="productionSetRequest">Request body</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AsyncFunctionResponse> ItemsPostAsync(string nuix_auth_token, string productionSetId, ProductionSetRequest productionSetRequest, string caseId, System.Threading.CancellationToken cancellationToken);

        /// <summary>Generates print previews for items in the production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <param name="allItems">Generate all print previews, or only generate previews that don't already exist</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProductionSetResponse> PrintPreviewAsync(string nuix_auth_token, string caseId, string productionSetId, bool? allItems);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Generates print previews for items in the production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <param name="allItems">Generate all print previews, or only generate previews that don't already exist</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ProductionSetResponse> PrintPreviewAsync(string nuix_auth_token, string caseId, string productionSetId, bool? allItems, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ProductionSetsClient : IProductionSetsClient
    {
        private string _baseUrl = "localhost:8080/nuix-restful-service/svc";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public ProductionSetsClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>Returns the items in this production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <param name="startIndex">Start index, defaults to 0</param>
        /// <param name="numberOfRecordsRequested">Number of records to return, defaults to all</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SearchNativeResult> ItemsGetAsync(string nuix_auth_token, string caseId, string productionSetId, int? startIndex, int? numberOfRecordsRequested)
        {
            return ItemsGetAsync(nuix_auth_token, caseId, productionSetId, startIndex, numberOfRecordsRequested, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the items in this production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <param name="startIndex">Start index, defaults to 0</param>
        /// <param name="numberOfRecordsRequested">Number of records to return, defaults to all</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SearchNativeResult> ItemsGetAsync(string nuix_auth_token, string caseId, string productionSetId, int? startIndex, int? numberOfRecordsRequested, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            if (productionSetId == null)
                throw new System.ArgumentNullException("productionSetId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/productionSets/{productionSetId}/items?");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{productionSetId}", System.Uri.EscapeDataString(ConvertToString(productionSetId, System.Globalization.CultureInfo.InvariantCulture)));
            if (startIndex != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("startIndex") + "=").Append(System.Uri.EscapeDataString(ConvertToString(startIndex, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (numberOfRecordsRequested != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("numberOfRecordsRequested") + "=").Append(System.Uri.EscapeDataString(ConvertToString(numberOfRecordsRequested, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SearchNativeResult>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SearchNativeResult);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Adds items to a production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <param name="productionSetRequest">Request body</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<AsyncFunctionResponse> ItemsPostAsync(string nuix_auth_token, string productionSetId, ProductionSetRequest productionSetRequest, string caseId)
        {
            return ItemsPostAsync(nuix_auth_token, productionSetId, productionSetRequest, caseId, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Adds items to a production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <param name="productionSetRequest">Request body</param>
        /// <param name="caseId">Case identification token</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<AsyncFunctionResponse> ItemsPostAsync(string nuix_auth_token, string productionSetId, ProductionSetRequest productionSetRequest, string caseId, System.Threading.CancellationToken cancellationToken)
        {
            if (productionSetId == null)
                throw new System.ArgumentNullException("productionSetId");

            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/productionSets/{productionSetId}/items");
            urlBuilder_.Replace("{productionSetId}", System.Uri.EscapeDataString(ConvertToString(productionSetId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(productionSetRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AsyncFunctionResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(AsyncFunctionResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Generates print previews for items in the production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <param name="allItems">Generate all print previews, or only generate previews that don't already exist</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ProductionSetResponse> PrintPreviewAsync(string nuix_auth_token, string caseId, string productionSetId, bool? allItems)
        {
            return PrintPreviewAsync(nuix_auth_token, caseId, productionSetId, allItems, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Generates print previews for items in the production set</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="productionSetId">Production set GUID</param>
        /// <param name="allItems">Generate all print previews, or only generate previews that don't already exist</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ProductionSetResponse> PrintPreviewAsync(string nuix_auth_token, string caseId, string productionSetId, bool? allItems, System.Threading.CancellationToken cancellationToken)
        {
            if (caseId == null)
                throw new System.ArgumentNullException("caseId");

            if (productionSetId == null)
                throw new System.ArgumentNullException("productionSetId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/productionSets/{productionSetId}/printPreview?");
            urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{productionSetId}", System.Uri.EscapeDataString(ConvertToString(productionSetId, System.Globalization.CultureInfo.InvariantCulture)));
            if (allItems != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("allItems") + "=").Append(System.Uri.EscapeDataString(ConvertToString(allItems, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "*/*");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProductionSetResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ProductionSetResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface IReviewJobsClient
    {
        /// <summary>Returns the review job items</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<NuixReviewJobItem>> ItemsGetAsync(string nuix_auth_token, string caseId, string reviewJobName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the review job items</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<NuixReviewJobItem>> ItemsGetAsync(string nuix_auth_token, string caseId, string reviewJobName, System.Threading.CancellationToken cancellationToken);

        /// <summary>Adds items to a review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <param name="reviewJobAddItemsRequest">The request body for the review job add items request</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ReviewJobResponse> ItemsPostAsync(string nuix_auth_token, string caseId, string reviewJobName, ReviewJobAddItemsRequest reviewJobAddItemsRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Adds items to a review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <param name="reviewJobAddItemsRequest">The request body for the review job add items request</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ReviewJobResponse> ItemsPostAsync(string nuix_auth_token, string caseId, string reviewJobName, ReviewJobAddItemsRequest reviewJobAddItemsRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the active reviewers in this review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<NmsUser>> ReviewersAsync(string nuix_auth_token, string caseId, string reviewJobName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the active reviewers in this review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<NmsUser>> ReviewersAsync(string nuix_auth_token, string caseId, string reviewJobName, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the tags in this review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> TagsAsync(string nuix_auth_token, string caseId, string reviewJobName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the tags in this review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> TagsAsync(string nuix_auth_token, string caseId, string reviewJobName, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ReviewJobsClient : IReviewJobsClient
    {
        private string _baseUrl = "localhost:8080/nuix-restful-service/svc";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public ReviewJobsClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>Returns the review job items</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<NuixReviewJobItem>> ItemsGetAsync(string nuix_auth_token, string caseId, string reviewJobName)
        {
            return ItemsGetAsync(nuix_auth_token, caseId, reviewJobName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the review job items</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<NuixReviewJobItem>> ItemsGetAsync(string nuix_auth_token, string caseId, string reviewJobName, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/reviewJobs/{reviewJobName}/items");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (reviewJobName != null)
                urlBuilder_.Replace("{reviewJobName}", System.Uri.EscapeDataString(ConvertToString(reviewJobName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{reviewJobName}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<NuixReviewJobItem>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<NuixReviewJobItem>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Adds items to a review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <param name="reviewJobAddItemsRequest">The request body for the review job add items request</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ReviewJobResponse> ItemsPostAsync(string nuix_auth_token, string caseId, string reviewJobName, ReviewJobAddItemsRequest reviewJobAddItemsRequest)
        {
            return ItemsPostAsync(nuix_auth_token, caseId, reviewJobName, reviewJobAddItemsRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Adds items to a review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <param name="reviewJobAddItemsRequest">The request body for the review job add items request</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ReviewJobResponse> ItemsPostAsync(string nuix_auth_token, string caseId, string reviewJobName, ReviewJobAddItemsRequest reviewJobAddItemsRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/reviewJobs/{reviewJobName}/items");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (reviewJobName != null)
                urlBuilder_.Replace("{reviewJobName}", System.Uri.EscapeDataString(ConvertToString(reviewJobName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{reviewJobName}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(reviewJobAddItemsRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ReviewJobResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(ReviewJobResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the active reviewers in this review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<NmsUser>> ReviewersAsync(string nuix_auth_token, string caseId, string reviewJobName)
        {
            return ReviewersAsync(nuix_auth_token, caseId, reviewJobName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the active reviewers in this review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<NmsUser>> ReviewersAsync(string nuix_auth_token, string caseId, string reviewJobName, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/reviewJobs/{reviewJobName}/reviewers");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (reviewJobName != null)
                urlBuilder_.Replace("{reviewJobName}", System.Uri.EscapeDataString(ConvertToString(reviewJobName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{reviewJobName}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<NmsUser>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<NmsUser>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the tags in this review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> TagsAsync(string nuix_auth_token, string caseId, string reviewJobName)
        {
            return TagsAsync(nuix_auth_token, caseId, reviewJobName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the tags in this review job</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">Case identification token</param>
        /// <param name="reviewJobName">Review job name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> TagsAsync(string nuix_auth_token, string caseId, string reviewJobName, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cases/{caseId}/reviewJobs/{reviewJobName}/tags");
            if (caseId != null)
                urlBuilder_.Replace("{caseId}", System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{caseId}", string.Empty);
            if (reviewJobName != null)
                urlBuilder_.Replace("{reviewJobName}", System.Uri.EscapeDataString(ConvertToString(reviewJobName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{reviewJobName}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface IInventoryClient
    {
        /// <summary>Returns the set of case digests for all inventory locations</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CaseDigest>> DigestAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the set of case digests for all inventory locations</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CaseDigest>> DigestAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Returns the set of inventory locations</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> LocationsAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the set of inventory locations</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> LocationsAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class InventoryClient : IInventoryClient
    {
        private string _baseUrl = "localhost:8080/nuix-restful-service/svc";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public InventoryClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>Returns the set of case digests for all inventory locations</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CaseDigest>> DigestAsync(string nuix_auth_token)
        {
            return DigestAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the set of case digests for all inventory locations</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CaseDigest>> DigestAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/inventory/digest");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<CaseDigest>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<CaseDigest>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Returns the set of inventory locations</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> LocationsAsync(string nuix_auth_token)
        {
            return LocationsAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns the set of inventory locations</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> LocationsAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/inventory/locations");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<string>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<string>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface IResourcesClient
    {
        /// <summary>Detects whether OCR functionality is available</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GenericResponse> OcrAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Detects whether OCR functionality is available</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GenericResponse> OcrAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ResourcesClient : IResourcesClient
    {
        private string _baseUrl = "localhost:8080/nuix-restful-service/svc";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public ResourcesClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>Detects whether OCR functionality is available</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GenericResponse> OcrAsync(string nuix_auth_token)
        {
            return OcrAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Detects whether OCR functionality is available</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GenericResponse> OcrAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/resources/ocr");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GenericResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(GenericResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface ISystemClient
    {
        /// <summary>Generates a system diagnostics ZIP file</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="includeResourceDetails">Creates an additional diagnostics file that includes the engine version, search cache, system resources, function queue, and active user count.</param>
        /// <param name="requestingApplication">requestingApplication</param>
        /// <param name="requestingApplicationVersion">requestingApplicationVersion</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> DiagnosticsAsync(string nuix_auth_token, bool? includeResourceDetails, string requestingApplication, string requestingApplicationVersion);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Generates a system diagnostics ZIP file</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="includeResourceDetails">Creates an additional diagnostics file that includes the engine version, search cache, system resources, function queue, and active user count.</param>
        /// <param name="requestingApplication">requestingApplication</param>
        /// <param name="requestingApplicationVersion">requestingApplicationVersion</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FileResponse> DiagnosticsAsync(string nuix_auth_token, bool? includeResourceDetails, string requestingApplication, string requestingApplicationVersion, System.Threading.CancellationToken cancellationToken);

        /// <summary>Checks whether the REST server is running</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GenericResponse> HealthAsync(string nuix_auth_token);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Checks whether the REST server is running</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GenericResponse> HealthAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken);

        /// <summary>Gets a Nuix system property</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="propertyName">Property name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SystemPropertyResponse> PropertiesGetAsync(string nuix_auth_token, string propertyName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Gets a Nuix system property</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="propertyName">Property name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SystemPropertyResponse> PropertiesGetAsync(string nuix_auth_token, string propertyName, System.Threading.CancellationToken cancellationToken);

        /// <summary>Sets a Nuix system property</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="propertyName">Property name</param>
        /// <param name="systemPropertyRequest">The Nuix system property request object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SystemPropertyResponse> PropertiesPutAsync(string nuix_auth_token, string propertyName, SystemPropertyRequest systemPropertyRequest);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Sets a Nuix system property</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="propertyName">Property name</param>
        /// <param name="systemPropertyRequest">The Nuix system property request object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SystemPropertyResponse> PropertiesPutAsync(string nuix_auth_token, string propertyName, SystemPropertyRequest systemPropertyRequest, System.Threading.CancellationToken cancellationToken);

        /// <summary>Clears a Nuix system property</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="propertyName">Property name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SystemPropertyResponse> PropertiesDeleteAsync(string nuix_auth_token, string propertyName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Clears a Nuix system property</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="propertyName">Property name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SystemPropertyResponse> PropertiesDeleteAsync(string nuix_auth_token, string propertyName, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class SystemClient : ISystemClient
    {
        private string _baseUrl = "localhost:8080/nuix-restful-service/svc";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public SystemClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>Generates a system diagnostics ZIP file</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="includeResourceDetails">Creates an additional diagnostics file that includes the engine version, search cache, system resources, function queue, and active user count.</param>
        /// <param name="requestingApplication">requestingApplication</param>
        /// <param name="requestingApplicationVersion">requestingApplicationVersion</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FileResponse> DiagnosticsAsync(string nuix_auth_token, bool? includeResourceDetails, string requestingApplication, string requestingApplicationVersion)
        {
            return DiagnosticsAsync(nuix_auth_token, includeResourceDetails, requestingApplication, requestingApplicationVersion, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Generates a system diagnostics ZIP file</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="includeResourceDetails">Creates an additional diagnostics file that includes the engine version, search cache, system resources, function queue, and active user count.</param>
        /// <param name="requestingApplication">requestingApplication</param>
        /// <param name="requestingApplicationVersion">requestingApplicationVersion</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FileResponse> DiagnosticsAsync(string nuix_auth_token, bool? includeResourceDetails, string requestingApplication, string requestingApplicationVersion, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/system/diagnostics?");
            if (includeResourceDetails != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("includeResourceDetails") + "=").Append(System.Uri.EscapeDataString(ConvertToString(includeResourceDetails, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (requestingApplication != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("requestingApplication") + "=").Append(System.Uri.EscapeDataString(ConvertToString(requestingApplication, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (requestingApplicationVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("requestingApplicationVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(requestingApplicationVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/zip"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200" || status_ == "206")
                        {
                            return default(FileResponse);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(FileResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Checks whether the REST server is running</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<GenericResponse> HealthAsync(string nuix_auth_token)
        {
            return HealthAsync(nuix_auth_token, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Checks whether the REST server is running</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<GenericResponse> HealthAsync(string nuix_auth_token, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/system/health");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GenericResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(GenericResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Gets a Nuix system property</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="propertyName">Property name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SystemPropertyResponse> PropertiesGetAsync(string nuix_auth_token, string propertyName)
        {
            return PropertiesGetAsync(nuix_auth_token, propertyName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Gets a Nuix system property</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="propertyName">Property name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SystemPropertyResponse> PropertiesGetAsync(string nuix_auth_token, string propertyName, System.Threading.CancellationToken cancellationToken)
        {
            if (propertyName == null)
                throw new System.ArgumentNullException("propertyName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/system/properties/{propertyName}");
            urlBuilder_.Replace("{propertyName}", System.Uri.EscapeDataString(ConvertToString(propertyName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SystemPropertyResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SystemPropertyResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Sets a Nuix system property</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="propertyName">Property name</param>
        /// <param name="systemPropertyRequest">The Nuix system property request object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SystemPropertyResponse> PropertiesPutAsync(string nuix_auth_token, string propertyName, SystemPropertyRequest systemPropertyRequest)
        {
            return PropertiesPutAsync(nuix_auth_token, propertyName, systemPropertyRequest, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Sets a Nuix system property</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="propertyName">Property name</param>
        /// <param name="systemPropertyRequest">The Nuix system property request object</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SystemPropertyResponse> PropertiesPutAsync(string nuix_auth_token, string propertyName, SystemPropertyRequest systemPropertyRequest, System.Threading.CancellationToken cancellationToken)
        {
            if (propertyName == null)
                throw new System.ArgumentNullException("propertyName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/system/properties/{propertyName}");
            urlBuilder_.Replace("{propertyName}", System.Uri.EscapeDataString(ConvertToString(propertyName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(systemPropertyRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SystemPropertyResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SystemPropertyResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        /// <summary>Clears a Nuix system property</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="propertyName">Property name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SystemPropertyResponse> PropertiesDeleteAsync(string nuix_auth_token, string propertyName)
        {
            return PropertiesDeleteAsync(nuix_auth_token, propertyName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Clears a Nuix system property</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="propertyName">Property name</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SystemPropertyResponse> PropertiesDeleteAsync(string nuix_auth_token, string propertyName, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/system/properties/{propertyName}");
            if (propertyName != null)
                urlBuilder_.Replace("{propertyName}", System.Uri.EscapeDataString(ConvertToString(propertyName, System.Globalization.CultureInfo.InvariantCulture)));
            else
                urlBuilder_.Replace("/{propertyName}", string.Empty);

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SystemPropertyResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "204")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("No Content", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(SystemPropertyResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface IValidationClient
    {
        /// <summary>Validates a list of queries</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="queryList">List of queries to validate</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<QueryValidationResponse>> QueryAsync(string nuix_auth_token, System.Collections.Generic.IEnumerable<string> queryList);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Validates a list of queries</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="queryList">List of queries to validate</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<QueryValidationResponse>> QueryAsync(string nuix_auth_token, System.Collections.Generic.IEnumerable<string> queryList, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ValidationClient : IValidationClient
    {
        private string _baseUrl = "localhost:8080/nuix-restful-service/svc";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public ValidationClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>Validates a list of queries</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="queryList">List of queries to validate</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<QueryValidationResponse>> QueryAsync(string nuix_auth_token, System.Collections.Generic.IEnumerable<string> queryList)
        {
            return QueryAsync(nuix_auth_token, queryList, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Validates a list of queries</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="queryList">List of queries to validate</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<QueryValidationResponse>> QueryAsync(string nuix_auth_token, System.Collections.Generic.IEnumerable<string> queryList, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/validation/query");

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(queryList, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("*/*"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<QueryValidationResponse>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "201")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Created", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<QueryValidationResponse>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial interface IV2Client
    {
        /// <summary>Returns asynchronous function statuses</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">The case to filter functions returned on.</param>
        /// <param name="friendlyName">The type of function to filter on.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<AsyncFunctionStatusOfobject>> AsyncFunctionsAsync(string nuix_auth_token, string caseId, string friendlyName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns asynchronous function statuses</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">The case to filter functions returned on.</param>
        /// <param name="friendlyName">The type of function to filter on.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<AsyncFunctionStatusOfobject>> AsyncFunctionsAsync(string nuix_auth_token, string caseId, string friendlyName, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class V2Client : IV2Client
    {
        private string _baseUrl = "localhost:8080/nuix-restful-service/svc";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public V2Client(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>Returns asynchronous function statuses</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">The case to filter functions returned on.</param>
        /// <param name="friendlyName">The type of function to filter on.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<AsyncFunctionStatusOfobject>> AsyncFunctionsAsync(string nuix_auth_token, string caseId, string friendlyName)
        {
            return AsyncFunctionsAsync(nuix_auth_token, caseId, friendlyName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Returns asynchronous function statuses</summary>
        /// <param name="nuix_auth_token">Authorization Header</param>
        /// <param name="caseId">The case to filter functions returned on.</param>
        /// <param name="friendlyName">The type of function to filter on.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<AsyncFunctionStatusOfobject>> AsyncFunctionsAsync(string nuix_auth_token, string caseId, string friendlyName, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v2/asyncFunctions?");
            if (caseId != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("caseId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(caseId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (friendlyName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("friendlyName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(friendlyName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (nuix_auth_token != null)
                        request_.Headers.TryAddWithoutValidation("nuix-auth-token", ConvertToString(nuix_auth_token, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json;charset=utf-8"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200")
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<AsyncFunctionStatusOfobject>>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Unauthorized", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "403")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Forbidden", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ == "404")
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Not Found", (int)response_.StatusCode, responseText_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }

                        return default(System.Collections.Generic.ICollection<AsyncFunctionStatusOfobject>);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class InvestigatorTimeZoneResponse
    {
        [Newtonsoft.Json.JsonProperty("timeZone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TimeZone { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AsyncFunctionResponse
    {
        /// <summary>functionKey</summary>
        [Newtonsoft.Json.JsonProperty("functionKey", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FunctionKey { get; set; }

        /// <summary>http://nuix-restful-service:8080/svc/v1/asyncFunctions/{functionKey}</summary>
        [Newtonsoft.Json.JsonProperty("location", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Location { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CreateTagListResponse
    {
        /// <summary>List of tags that were succuessfully created</summary>
        [Newtonsoft.Json.JsonProperty("createdTags", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> CreatedTags { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>List of tags that failed to be created</summary>
        [Newtonsoft.Json.JsonProperty("failedTags", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> FailedTags { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>List of tags used during the operation</summary>
        [Newtonsoft.Json.JsonProperty("tagList", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> TagList { get; set; } = new System.Collections.ObjectModel.Collection<string>();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CaseResponse
    {
        /// <summary>The binary store location for this case, if applicable</summary>
        [Newtonsoft.Json.JsonProperty("binaryStoreLocation", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string BinaryStoreLocation { get; set; }

        /// <summary>Deprecated; use 'creationDate' instead</summary>
        [Newtonsoft.Json.JsonProperty("caseCreationDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset CaseCreationDate { get; set; }

        /// <summary>Deprecated; use 'description' instead</summary>
        [Newtonsoft.Json.JsonProperty("caseDescription", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CaseDescription { get; set; }

        /// <summary>The case's unique identifier</summary>
        [Newtonsoft.Json.JsonProperty("caseId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CaseId { get; set; }

        /// <summary>The investigation time zone, e.g. America/New_York</summary>
        [Newtonsoft.Json.JsonProperty("caseInvestigationTimeZone", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CaseInvestigationTimeZone { get; set; }

        /// <summary>Deprecated; use 'investigator' instead</summary>
        [Newtonsoft.Json.JsonProperty("caseInvestigator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CaseInvestigator { get; set; }

        /// <summary>Deprecated; use 'name' instead</summary>
        [Newtonsoft.Json.JsonProperty("caseName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CaseName { get; set; }

        /// <summary>Deprecated; use 'path' instead</summary>
        [Newtonsoft.Json.JsonProperty("casePath", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CasePath { get; set; }

        /// <summary>Path to the parent directory of the case</summary>
        [Newtonsoft.Json.JsonProperty("casePathParent", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CasePathParent { get; set; }

        /// <summary>The size of the case on disk, in bytes</summary>
        [Newtonsoft.Json.JsonProperty("caseSize", Required = Newtonsoft.Json.Required.Always)]
        public long CaseSize { get; set; }

        /// <summary>Whether this case is Simple or Compound</summary>
        [Newtonsoft.Json.JsonProperty("compound", Required = Newtonsoft.Json.Required.Always)]
        public bool Compound { get; set; }

        /// <summary>The date/time this case was created, in milliseconds since epoch</summary>
        [Newtonsoft.Json.JsonProperty("creationDate", Required = Newtonsoft.Json.Required.Always)]
        public long CreationDate { get; set; }

        /// <summary>The case description</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

        /// <summary>Whether this is an Elastic case</summary>
        [Newtonsoft.Json.JsonProperty("elastic", Required = Newtonsoft.Json.Required.Always)]
        public bool Elastic { get; set; }

        /// <summary>The investigator for this case</summary>
        [Newtonsoft.Json.JsonProperty("investigator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Investigator { get; set; }

        /// <summary>The case name</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>The path to the case</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Path { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class BulkProductionSetWithProfilesRequest
    {
        /// <summary>Set the long description of the production set.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        [Newtonsoft.Json.JsonProperty("duplicatesQuery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DuplicatesQuery { get; set; }

        [Newtonsoft.Json.JsonProperty("familyQuery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FamilyQuery { get; set; }

        /// <summary>The name of the imaging profile to use.</summary>
        [Newtonsoft.Json.JsonProperty("imagingProfileName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImagingProfileName { get; set; }

        [Newtonsoft.Json.JsonProperty("includeDuplicates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeDuplicates { get; set; }

        [Newtonsoft.Json.JsonProperty("includeFamily", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeFamily { get; set; }

        [Newtonsoft.Json.JsonProperty("includeNearDuplicates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeNearDuplicates { get; set; }

        /// <summary>The name of the production set to operate on.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("nearDuplicatesQuery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NearDuplicatesQuery { get; set; }

        [Newtonsoft.Json.JsonProperty("nearDuplicatesThreshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? NearDuplicatesThreshold { get; set; }

        /// <summary>The name of the production profile to use.</summary>
        [Newtonsoft.Json.JsonProperty("productionProfileName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProductionProfileName { get; set; }

        /// <summary>Query items that should be included. If a query is not supplied it defaults to an empty string, which returns all items.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }

        /// <summary>Sets whether this production set skips export of natives for slip-sheeted items.</summary>
        [Newtonsoft.Json.JsonProperty("skipNativesSlipsheetedItems", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SkipNativesSlipsheetedItems { get; set; }

        [Newtonsoft.Json.JsonProperty("threadsQuery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ThreadsQuery { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ThumbnailUtilityRequestDimension
    {
        /// <summary>Height of the thumbnail as an integer representing number of pixels.</summary>
        [Newtonsoft.Json.JsonProperty("height", Required = Newtonsoft.Json.Required.Always)]
        public int Height { get; set; }

        /// <summary>Width of the thumbnail as an integer representing number of pixels.</summary>
        [Newtonsoft.Json.JsonProperty("width", Required = Newtonsoft.Json.Required.Always)]
        public int Width { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class MimeTypeSpecificProcessingSettings
    {
        /// <summary>Controls whether items matching this MIME type, and their embedded descendants, will be processed.  Default is true</summary>
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }

        /// <summary>Controls whether embedded descendants matching this MIME type will be processed.  Default is true</summary>
        [Newtonsoft.Json.JsonProperty("processEmbedded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ProcessEmbedded { get; set; }

        /// <summary>Controls whether items matching this MIME type will have their image data processed. This setting only takes effect if 'createThumbnails' is enabled in 'ProcessorSettings'.  Default is true</summary>
        [Newtonsoft.Json.JsonProperty("processImages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ProcessImages { get; set; }

        /// <summary>Controls whether items matching this MIME type will have their named entities processed. This setting only takes effect if either 'extractNamedEntitiesFromText' or 'extractNamedEntitiesFromProperties' is enabled in 'ProcessorSettings'. Default is true</summary>
        [Newtonsoft.Json.JsonProperty("processNamedEntities", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ProcessNamedEntities { get; set; }

        /// <summary>Controls whether items matching this MIME type will have their text processed.  This setting takes precedence over 'textStrip' if both are set to true.  Set this and 'textStrip' to false in order to skip text processing.  Default is true</summary>
        [Newtonsoft.Json.JsonProperty("processText", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ProcessText { get; set; }

        /// <summary>Controls whether items matching this MIME type will have their binary data stored.  This setting only takes effect if 'storeBinary' is enabled in 'ProcessorSettings'.  Default is true</summary>
        [Newtonsoft.Json.JsonProperty("storeBinary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? StoreBinary { get; set; }

        /// <summary>Controls whether items matching this MIME type will have their binary data text stripped.  Set this and 'processText' to false in order to skip text processing.  Default is false</summary>
        [Newtonsoft.Json.JsonProperty("textStrip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? TextStrip { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class BatchLoadDetailsResponse
    {
        /// <summary>batch identifier</summary>
        [Newtonsoft.Json.JsonProperty("batchId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string BatchId { get; set; }

        /// <summary>case evidence settings for the batch as a map</summary>
        [Newtonsoft.Json.JsonProperty("caseEvidenceSettings", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object CaseEvidenceSettings { get; set; } = new object();

        /// <summary>data settings for the batch as a map</summary>
        [Newtonsoft.Json.JsonProperty("dataSettings", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object DataSettings { get; set; } = new object();

        /// <summary>data processing settings for the batch as a map</summary>
        [Newtonsoft.Json.JsonProperty("dataProcessingSettings", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object DataProcessingSettings { get; set; } = new object();

        /// <summary>any additional settings for the load as a map</summary>
        [Newtonsoft.Json.JsonProperty("additionalSettings", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object AdditionalSettings { get; set; } = new object();

        /// <summary>date and time in milliseconds the batch was loaded</summary>
        [Newtonsoft.Json.JsonProperty("loadedOn", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset LoadedOn { get; set; }

        /// <summary>name of the operating system the batch was loaded under</summary>
        [Newtonsoft.Json.JsonProperty("operatingSystem", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string OperatingSystem { get; set; }

        /// <summary>operating system architecture the batch was loaded under</summary>
        [Newtonsoft.Json.JsonProperty("operatingSystemArchitecture", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string OperatingSystemArchitecture { get; set; }

        /// <summary>parallel processing settings for the batch as a map</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object ParallelProcessingSettings { get; set; } = new object();

        /// <summary>process architecture the batch was loaded under</summary>
        [Newtonsoft.Json.JsonProperty("processArchitecture", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ProcessArchitecture { get; set; }

        /// <summary>evidence container name</summary>
        [Newtonsoft.Json.JsonProperty("evidenceContainerName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string EvidenceContainerName { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class Success
    {
        [Newtonsoft.Json.JsonProperty("success", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Success1 { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CaseDigest
    {
        /// <summary>The binary store location for this case, if applicable</summary>
        [Newtonsoft.Json.JsonProperty("binaryStoreLocation", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string BinaryStoreLocation { get; set; }

        /// <summary>The case's unique identifier</summary>
        [Newtonsoft.Json.JsonProperty("caseId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CaseId { get; set; }

        /// <summary>The child cases of this case, when applicable.  If the child case is known to this REST instance then the value will be the child case's GUID.  Otherwise it will be the absolute path to the child case</summary>
        [Newtonsoft.Json.JsonProperty("childCases", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> ChildCases { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>Whether this case is Simple or Compound</summary>
        [Newtonsoft.Json.JsonProperty("compound", Required = Newtonsoft.Json.Required.Always)]
        public bool Compound { get; set; }

        /// <summary>The date/time this case was created, in milliseconds since epoch</summary>
        [Newtonsoft.Json.JsonProperty("creationDate", Required = Newtonsoft.Json.Required.Always)]
        public long CreationDate { get; set; }

        /// <summary>The case description</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

        /// <summary>Whether this is an Elastic case</summary>
        [Newtonsoft.Json.JsonProperty("elastic", Required = Newtonsoft.Json.Required.Always)]
        public bool Elastic { get; set; }

        /// <summary>The investigator for this case</summary>
        [Newtonsoft.Json.JsonProperty("investigator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Investigator { get; set; }

        /// <summary>Whether or not this case is currently open, which means something in REST is working with this case</summary>
        [Newtonsoft.Json.JsonProperty("isOpen", Required = Newtonsoft.Json.Required.Always)]
        public bool IsOpen { get; set; }

        /// <summary>The case name</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>The path to the case</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Path { get; set; }

        /// <summary>Deprecated; use 'path' instead</summary>
        [Newtonsoft.Json.JsonProperty("physicalPath", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string PhysicalPath { get; set; }

        /// <summary>The name of the product that created / opened this case</summary>
        [Newtonsoft.Json.JsonProperty("productName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ProductName { get; set; }

        /// <summary>The Server ID of the REST instance that contains this case</summary>
        [Newtonsoft.Json.JsonProperty("serverId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ServerId { get; set; }

        /// <summary>The URL of the REST instance that contains this case</summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Url { get; set; }

        /// <summary>The version of Nuix that most recently opened this case</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Version { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class NumAuthenticationRequest
    {
        [Newtonsoft.Json.JsonProperty("licenceDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LicenceDescription { get; set; }

        [Newtonsoft.Json.JsonProperty("licenceShortName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LicenceShortName { get; set; }

        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Password { get; set; }

        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Username { get; set; }

        [Newtonsoft.Json.JsonProperty("workers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Workers { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class MarkupSetDeleteResponse
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("success", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Success { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ItemSizesRequest
    {
        /// <summary>The deduplication to apply over each query. Defaults to 'none'</summary>
        [Newtonsoft.Json.JsonProperty("deduplication", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ItemSizesRequestDeduplication? Deduplication { get; set; }

        /// <summary>The set of queries which will be executed.</summary>
        [Newtonsoft.Json.JsonProperty("queryList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> QueryList { get; set; }

        /// <summary>The size type to calculate.</summary>
        [Newtonsoft.Json.JsonProperty("sizeType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ItemSizesRequestSizeType SizeType { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class IngestibleEnterpriseVault
    {
        /// <summary>This optional parameter limits the evidence to the specified Enterprise Vault archive.</summary>
        [Newtonsoft.Json.JsonProperty("archive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Archive { get; set; }

        /// <summary>The hostname or IP address of the target server.</summary>
        [Newtonsoft.Json.JsonProperty("computer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Computer { get; set; }

        /// <summary>This optional parameter limits the evidence to the specified custodian or author.</summary>
        [Newtonsoft.Json.JsonProperty("custodian", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Custodian { get; set; }

        /// <summary>This optional parameter specifies how keywords are combined and treated for keyword-based queries. It must be accompanied by the 'keywords' parameter but will default to any if it is omitted. A value from any, all, allnear, phrase, begins, beginany, exact, exactany, ends, endsany.</summary>
        [Newtonsoft.Json.JsonProperty("flag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Flag { get; set; }

        /// <summary>This optional parameter limits the evidence to a date range beginning from the specified date/time. It must be accompanied by the 'to' parameter.</summary>
        [Newtonsoft.Json.JsonProperty("from", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? From { get; set; }

        /// <summary>This optional parameter limits the evidence to results matching Enterprise Vault's query using the words in this string. Subject and message/document content are searched by Enterprise Vault and it will match any word in the string unless specified differently in the flag parameter.</summary>
        [Newtonsoft.Json.JsonProperty("keywords", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Keywords { get; set; }

        /// <summary>This optional parameter limits the evidence to a date range ending at the specified date/time. It must be accompanied by the 'from' parameter.</summary>
        [Newtonsoft.Json.JsonProperty("to", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? To { get; set; }

        /// <summary>This optional parameter limits the evidence to the specified Enterprise Vault vault.</summary>
        [Newtonsoft.Json.JsonProperty("vault", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Vault { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SingleContainerIngestionRequestOfIngestibleSharepoint
    {
        /// <summary>Deprecated in favor of processingProfile. Configuration profile to use as base set of processor, parallel processing, and mime type settings.  Values present in processorSettings, parallelProcessingSettings, and mimeTypeProcessorSettings will override anything defined by this profile.</summary>
        [Newtonsoft.Json.JsonProperty("configurationProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationProfile { get; set; }

        /// <summary>The evidence container to create for this ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("container", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EvidenceContainer Container { get; set; }

        /// <summary>Sets the settings used to apply a keystore file to the ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("keystoreKeyParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyStoreKeyParameters> KeystoreKeyParameters { get; set; }

        /// <summary>Sets the processing settings for individual mime types.</summary>
        [Newtonsoft.Json.JsonProperty("mimeTypeProcessorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MimeTypeProcessingSetting> MimeTypeProcessorSettings { get; set; }

        /// <summary>Sets the parallel processing settings to use for processing.</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>The name of the Processing Profile to use. If you use this setting then do not use any other settings from processorSettings as everything will be overridden by the loaded Processing profile.</summary>
        [Newtonsoft.Json.JsonProperty("processingProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessingProfile { get; set; }

        /// <summary>Sets the processing settings to use.</summary>
        [Newtonsoft.Json.JsonProperty("processorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProcessorSettings ProcessorSettings { get; set; }

        /// <summary>If true, the case's Evidence Repositories will be rescanned to discover new Evidence Containers within them and new files within existing Evidence Containers which are themselves within the cases's Evidence Repositories. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("rescanEvidenceRepositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RescanEvidenceRepositories { get; set; }

        /// <summary>The ingestible target to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IngestibleSharepoint Target { get; set; } = new IngestibleSharepoint();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ItemSetRequest
    {
        /// <summary>Defaults to date in format yy/MM/dd kk:mm:ss z</summary>
        [Newtonsoft.Json.JsonProperty("batchName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BatchName { get; set; }

        /// <summary>List of custodian names ordered from highest ranked to lowest ranked.  If this parameter is present and the deduplication parameter has not been specified, MD5 Randed Custodian is assumed.  If deduplication is any value other than MD5 Randed Custodian this list is ignored.</summary>
        [Newtonsoft.Json.JsonProperty("custodianRanking", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> CustodianRanking { get; set; }

        /// <summary>deduplicateBy.  Defaults to INDIVIDUAL</summary>
        [Newtonsoft.Json.JsonProperty("deduplicateBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ItemSetRequestDeduplicateBy? DeduplicateBy { get; set; }

        /// <summary>How the deduplication is applied.  None returns all items matching the query including duplicates.  Other options return deduplicated items based on the deduplication methods used.  Defaults to None</summary>
        [Newtonsoft.Json.JsonProperty("deduplication", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ItemSetRequestDeduplication? Deduplication { get; set; }

        /// <summary>description</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>name</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>Query items that should be included. If a query is not supplied it defaults to an empty string, which returns all items.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SlipsheetsRequest
    {
        /// <summary>Defines the metadata profile to be used when generating slipsheets.  Defaults to no metadata profile.</summary>
        [Newtonsoft.Json.JsonProperty("metadataProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MetadataProfile { get; set; }

        /// <summary>Query items that should be included. If a query is not supplied it defaults to an empty string, which returns all items.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CustomMetadataRequest
    {
        /// <summary>The name of the custom metadata field</summary>
        [Newtonsoft.Json.JsonProperty("fieldName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FieldName { get; set; }

        /// <summary>The custom metadata mode</summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CustomMetadataRequestMode Mode { get; set; }

        /// <summary>Any parameters required to parse the value field</summary>
        [Newtonsoft.Json.JsonProperty("params", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Params { get; set; }

        /// <summary>The data type of the field</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CustomMetadataRequestType Type { get; set; }

        /// <summary>The value of the custom metadata field</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object Value { get; set; } = new object();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class MimeTypeProcessingSetting
    {
        /// <summary>Sets the MIME type</summary>
        [Newtonsoft.Json.JsonProperty("mimeType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string MimeType { get; set; }

        /// <summary>Sets the processing settings to use for this MIME type</summary>
        [Newtonsoft.Json.JsonProperty("settings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public MimeTypeSpecificProcessingSettings Settings { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ItemCommentRequest
    {
        /// <summary>itemComment</summary>
        [Newtonsoft.Json.JsonProperty("itemComment", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ItemComment { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class MarkupSetRequest
    {
        /// <summary>A description of the markup set.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>An explaination of why the redaction was added.</summary>
        [Newtonsoft.Json.JsonProperty("redactionReason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RedactionReason { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ItemSetAddItemsRequest
    {
        /// <summary>Defaults to date in format yy/MM/dd kk:mm:ss z</summary>
        [Newtonsoft.Json.JsonProperty("batchName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BatchName { get; set; }

        /// <summary>Query items that should be included. If a query is not supplied it defaults to an empty string, which returns all items.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class KindTypeResponse
    {
        [Newtonsoft.Json.JsonProperty("itemKind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ItemKind { get; set; }

        [Newtonsoft.Json.JsonProperty("itemTypes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<NuixItemType> ItemTypes { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DeleteTagListResponse
    {
        /// <summary>List of tags that were successfully deleted</summary>
        [Newtonsoft.Json.JsonProperty("deletedTags", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> DeletedTags { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>List of tags that failed deletion</summary>
        [Newtonsoft.Json.JsonProperty("failedTags", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> FailedTags { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>List of tags used during the operation</summary>
        [Newtonsoft.Json.JsonProperty("tagList", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> TagList { get; set; } = new System.Collections.ObjectModel.Collection<string>();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class IngestibleDropbox
    {
        /// <summary>The access token for accessing Dropbox. Provide in place of 'authCode' when applicable. This code does not expire until the account owner revokes access for Nuix.</summary>
        [Newtonsoft.Json.JsonProperty("accessToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AccessToken { get; set; }

        /// <summary>Temporary authorization code provided by Dropbox for accessing a given account or team.</summary>
        [Newtonsoft.Json.JsonProperty("authCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AuthCode { get; set; }

        /// <summary>Whether or not a Dropbox team is being ingested.  Omit when adding an individual Dropbox account.</summary>
        [Newtonsoft.Json.JsonProperty("team", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Team { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CreateReviewJobRequest
    {
        /// <summary>The name of the review job.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>The options for the review job.</summary>
        [Newtonsoft.Json.JsonProperty("options", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CreateReviewJobOptions Options { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ProductionSetResponse
    {
        /// <summary>Description of the production set.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

        /// <summary>Document number for the first item in this production set.</summary>
        [Newtonsoft.Json.JsonProperty("firstDocumentNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FirstDocumentNumber { get; set; }

        /// <summary>Indicates whether or not the production set is frozen.</summary>
        [Newtonsoft.Json.JsonProperty("frozen", Required = Newtonsoft.Json.Required.Always)]
        public bool Frozen { get; set; }

        /// <summary>Production set GUID.</summary>
        [Newtonsoft.Json.JsonProperty("guid", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Guid { get; set; }

        /// <summary>Number of items in the production set.</summary>
        [Newtonsoft.Json.JsonProperty("itemCount", Required = Newtonsoft.Json.Required.Always)]
        public long ItemCount { get; set; }

        /// <summary>Name of the production set.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>Document ID that will be used for the next item added to this production set.</summary>
        [Newtonsoft.Json.JsonProperty("nextDocumentId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string NextDocumentId { get; set; }

        /// <summary>Document number that will be used for the next item added to this production set.</summary>
        [Newtonsoft.Json.JsonProperty("nextDocumentNumber", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string NextDocumentNumber { get; set; }

        /// <summary>Prefix used for document numbering.</summary>
        [Newtonsoft.Json.JsonProperty("prefix", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Prefix { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class BulkInclusionRequest
    {
        [Newtonsoft.Json.JsonProperty("duplicatesQuery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DuplicatesQuery { get; set; }

        [Newtonsoft.Json.JsonProperty("familyQuery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FamilyQuery { get; set; }

        [Newtonsoft.Json.JsonProperty("includeDuplicates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeDuplicates { get; set; }

        [Newtonsoft.Json.JsonProperty("includeFamily", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeFamily { get; set; }

        [Newtonsoft.Json.JsonProperty("includeNearDuplicates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeNearDuplicates { get; set; }

        [Newtonsoft.Json.JsonProperty("nearDuplicatesQuery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NearDuplicatesQuery { get; set; }

        [Newtonsoft.Json.JsonProperty("nearDuplicatesThreshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? NearDuplicatesThreshold { get; set; }

        /// <summary>Query items that should be included. If a query is not supplied it defaults to an empty string, which returns all items.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }

        [Newtonsoft.Json.JsonProperty("threadsQuery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ThreadsQuery { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CaseMetadataField
    {
        /// <summary>The metadata field name</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>The metadata field type. Will be one of:&lt;br/&gt;SPECIAL: Metadata defined by the application such as GUID, Name, etc.&lt;br/&gt;PROPERTY: Regular metadata which was stored within an item.&lt;br/&gt;DERIVED: Metadata identifier using an arbitrary expression.&lt;br/&gt;EVIDENCE: Metadata assigned at the evidence level at load time.&lt;br/&gt;SCRIPTED: Metadata using an arbitrary scripted expression.&lt;br/&gt;CUSTOM: User-defined custom metadata.</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class IngestibleExchangeMailbox
    {
        /// <summary>This optional parameter defines the Windows networking domain of the server account.</summary>
        [Newtonsoft.Json.JsonProperty("domain", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Domain { get; set; }

        /// <summary>This optional parameter limits the evidence to a date range beginning from the specified date/time. It must be accompanied by the 'to' parameter.</summary>
        [Newtonsoft.Json.JsonProperty("from", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? From { get; set; }

        /// <summary>Instructs Exchange to impersonate the mailbox user instead of delegating when the mailbox and username are different. Defaults to false.</summary>
        [Newtonsoft.Json.JsonProperty("impersonating", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Impersonating { get; set; }

        /// <summary>The mailbox (specified by email address) to ingest if it differs from the username.</summary>
        [Newtonsoft.Json.JsonProperty("mailbox", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Mailbox { get; set; }

        /// <summary>A list containing one or more of the following string values: mailbox, archive, purges, deletions, recoverable_items, archive_purges, archive_deletions, archive_recoverable_items, public_folders. Determines whether to extract from the user's mailbox, archive, recoverable items.</summary>
        [Newtonsoft.Json.JsonProperty("mailboxRetrieval", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> MailboxRetrieval { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>The password needed to access the server account.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Password { get; set; }

        /// <summary>This optional parameter limits the evidence to a date range ending at the specified date/time. It must be accompanied by the 'from' parameter.</summary>
        [Newtonsoft.Json.JsonProperty("to", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? To { get; set; }

        /// <summary>Protocol, host, port and path can all be specified. For SharePoint the address is the site address. For Exchange the address is the path to the Exchange Web Service (e.g., https://ex2010/ews/exchange.asmx) and it can be omitted to use auto-discovery based on the mailbox or username address.</summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Uri { get; set; }

        /// <summary>The username needed to access the server account.</summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Username { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AddRemoteWorkersRequest
    {
        /// <summary>Host the agent has been bound to. If none was specified when the agent was created, use the one returned in the response of the agent creation endpoint.</summary>
        [Newtonsoft.Json.JsonProperty("workerAgentAddress", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string WorkerAgentAddress { get; set; }

        /// <summary>Number of workers to add. Defaults to max available.</summary>
        [Newtonsoft.Json.JsonProperty("workerCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? WorkerCount { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class OcrOptionsV2
    {
        /// <summary>Specifies whether to clear OCR cache. By default the OCR cache will be deleted upon completion. The default location for this cache is under the case directory. See also 'outputDirectory' for customising the location of this cache. Defaults to true</summary>
        [Newtonsoft.Json.JsonProperty("clearOcrCache", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ClearOcrCache { get; set; }

        /// <summary>Whether to deskew text. This will attempt to correct images where text is not level with the page. Defaults to true</summary>
        [Newtonsoft.Json.JsonProperty("deskew", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Deskew { get; set; }

        /// <summary>Specifies the languages to use during recognition. Defaults to English</summary>
        [Newtonsoft.Json.JsonProperty("languages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Languages> Languages { get; set; }

        /// <summary>Specifies the output directory. Defaults to the temporary directory</summary>
        [Newtonsoft.Json.JsonProperty("outputDirectory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OutputDirectory { get; set; }

        /// <summary>Specifies the OCR processing profile to use.&lt;br/&gt;'default' will use default values which usually produce a good result in a resonable time.&lt;br/&gt;In the following descriptions, those ending in '_speed' have an emphasis on speed rather than accuracy:&lt;br/&gt;'document_archiving_accuracy' is suitable for creating an electronic archive (e.g. PDF). Enables detection of maximum text on an image, including text embedded into the image. Full synthesis of the logical structure of a document is not performed.&lt;br/&gt;'book_archiving_accuracy' is suitable for creating an electronic library (e.g. PDF). Enables detection of font styles and full synthesis of the logical structure of a document.&lt;br/&gt;'document_conversion_accuracy' is suitable for converting documents into an editable format (e.g. RTF, DOCX). Enables detection of font styles and full synthesis of the logical structore of a document.&lt;br/&gt;'text_extraction_accuracy' is suitable for extracting text from a document. Enables detection of all text on an image, including small text areas of low quality (pictures and tables are not detected). Full synthesis of the logical structure of a document is not performed.&lt;br/&gt;'field_level_recognition' is suitable for recognizing short text fragments.&lt;br/&gt;'fast' is deprecated. See 'default'.&lt;br/&gt;'mid_range' is deprecated. See 'document_archiving_speed'.&lt;br/&gt;'high_quality' is deprecated. See 'document_archiving_accuracy'.&lt;br/&gt;Defaults to 'document_archiving_accuracy'</summary>
        [Newtonsoft.Json.JsonProperty("quality", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OcrOptionsV2Quality? Quality { get; set; }

        /// <summary>Specifies whether to regenerate PDFs before they are sent to the OCR processor. Defaults to false</summary>
        [Newtonsoft.Json.JsonProperty("regeneratePdfs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RegeneratePdfs { get; set; }

        /// <summary>Specifies the page rotation to use on the images. This will rotate the images before processing.&lt;br/&gt;'left' indicates the top of the image is on the left side of the document i.e. it is rotated 90 degrees counter-clockwise.&lt;br/&gt;'right' indicates the top of the image is on the right side of the document i.e. it is rotate 90 degrees clockwise.&lt;br/&gt;'upside_down' indicates the document should be rotate 180 degrees before processing.&lt;br/&gt;Defaults to auto</summary>
        [Newtonsoft.Json.JsonProperty("rotation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OcrOptionsV2Rotation? Rotation { get; set; }

        /// <summary>Specifies whether to append or overwrite new text to the item's existing text. Ignored if 'updateText' is set to false. Defaults to append</summary>
        [Newtonsoft.Json.JsonProperty("textModification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OcrOptionsV2TextModification? TextModification { get; set; }

        /// <summary>The timeout duration in minutes for processing an item. Must be greater than 1 minute. Defaults to 90</summary>
        [Newtonsoft.Json.JsonProperty("timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Timeout { get; set; }

        /// <summary>Update all duplicate items in the case. Defaults to false</summary>
        [Newtonsoft.Json.JsonProperty("updateDuplicates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UpdateDuplicates { get; set; }

        /// <summary>Specifies whether to update PDFs in the print store with the PDF created by the OCR processor. Defaults to true</summary>
        [Newtonsoft.Json.JsonProperty("updatePdf", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UpdatePdf { get; set; }

        /// <summary>Specifies whether to update the item's text with the text extrated with the OCR processor. Defaults to true</summary>
        [Newtonsoft.Json.JsonProperty("updateText", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UpdateText { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SystemPropertyRequest
    {
        /// <summary>The value of the system property.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class IngestibleSplitFileList
    {
        /// <summary>The list of files to add. Absolute paths are recommended.</summary>
        [Newtonsoft.Json.JsonProperty("files", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Files { get; set; } = new System.Collections.ObjectModel.Collection<string>();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ItemCommentResponse
    {
        /// <summary>Comments for this item</summary>
        [Newtonsoft.Json.JsonProperty("itemComment", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ItemComment { get; set; }

        /// <summary>itemGUID</summary>
        [Newtonsoft.Json.JsonProperty("itemGuid", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ItemGuid { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CaseDeleteResponse
    {
        /// <summary>caseId</summary>
        [Newtonsoft.Json.JsonProperty("caseId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CaseId { get; set; }

        [Newtonsoft.Json.JsonProperty("childCases", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CaseDeleteResponse> ChildCases { get; set; }

        /// <summary>success</summary>
        [Newtonsoft.Json.JsonProperty("success", Required = Newtonsoft.Json.Required.Always)]
        public bool Success { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class KeyStoreKeyParameters
    {
        /// <summary>Specifies the password protecting the file (e.g. for PKCS#12)</summary>
        [Newtonsoft.Json.JsonProperty("filePassword", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FilePassword { get; set; }

        /// <summary>Specifies the passwords protecting individual keys when extracting multiple password-protected keys from a single file.</summary>
        [Newtonsoft.Json.JsonProperty("keyPasswords", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> KeyPasswords { get; set; }

        /// <summary>The name of the keystore file being used.</summary>
        [Newtonsoft.Json.JsonProperty("keystoreName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string KeystoreName { get; set; }

        /// <summary>For Lotus Notes ID files, this value should contain the file name of the NSF file protected by this key.</summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Target { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SearchNativeResult
    {
        /// <summary>Date the search completed</summary>
        [Newtonsoft.Json.JsonProperty("completedOn", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset CompletedOn { get; set; }

        /// <summary>Count of items in results</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Always)]
        public int Count { get; set; }

        /// <summary>Count of deduplicated items</summary>
        [Newtonsoft.Json.JsonProperty("deduplicatedCount", Required = Newtonsoft.Json.Required.Always)]
        public int DeduplicatedCount { get; set; }

        /// <summary>Elapsed time to perform search</summary>
        [Newtonsoft.Json.JsonProperty("elapsedTimeForSearch", Required = Newtonsoft.Json.Required.Always)]
        public long ElapsedTimeForSearch { get; set; }

        /// <summary>SearchNativeRequest object used for search</summary>
        [Newtonsoft.Json.JsonProperty("request", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public SearchNativeRequest Request { get; set; } = new SearchNativeRequest();

        /// <summary>Results of the search</summary>
        [Newtonsoft.Json.JsonProperty("resultList", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<MapOfstringAndobject> ResultList { get; set; } = new System.Collections.ObjectModel.Collection<MapOfstringAndobject>();

        /// <summary>Date the search started</summary>
        [Newtonsoft.Json.JsonProperty("startedOn", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset StartedOn { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ItemSetRemoveItemsRequest
    {
        /// <summary>Query items that should be included. If a query is not supplied it defaults to an empty string, which returns all items.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }

        /// <summary>removeDuplicates.  Default is true.</summary>
        [Newtonsoft.Json.JsonProperty("removeDuplicates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RemoveDuplicates { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ItemsShinglesRequest
    {
        /// <summary>deduplication.  Default is None.</summary>
        [Newtonsoft.Json.JsonProperty("deduplication", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ItemsShinglesRequestDeduplication? Deduplication { get; set; }

        /// <summary>maxItems.  Default is 1000 items.</summary>
        [Newtonsoft.Json.JsonProperty("maxItems", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxItems { get; set; }

        /// <summary>The maximum number of shingles to return.  Default is 100 shingles.</summary>
        [Newtonsoft.Json.JsonProperty("maxShingleResponse", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxShingleResponse { get; set; }

        /// <summary>Query items that should be included.  If a query is not supplied it defaults to an empty string, which returns all items.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SearchHitRequest
    {
        /// <summary>Search hits query. If a query is not supplied, it defaults to an empty string which will not return search hits.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Query { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TimezoneRequest
    {
        /// <summary>A valid Joda timezone ID.</summary>
        [Newtonsoft.Json.JsonProperty("timezone", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Timezone { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class WorkerAgent
    {
        /// <summary>Total number of workers available to the agent when it was started</summary>
        [Newtonsoft.Json.JsonProperty("availableWorkers", Required = Newtonsoft.Json.Required.Always)]
        public int AvailableWorkers { get; set; }

        /// <summary>Unique ID for the worker agent. Matches the id generated by the engine.</summary>
        [Newtonsoft.Json.JsonProperty("guid", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Guid { get; set; }

        /// <summary>Host the agent has been bound to.</summary>
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Host { get; set; }

        /// <summary>Licence used to start the agent</summary>
        [Newtonsoft.Json.JsonProperty("licenceShortName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string LicenceShortName { get; set; }

        /// <summary>Worker broker address in the format address:port</summary>
        [Newtonsoft.Json.JsonProperty("workerBrokerAddress", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string WorkerBrokerAddress { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AddRemoteWorkersResponse
    {
        /// <summary>Message from the exception if an error occurred.</summary>
        [Newtonsoft.Json.JsonProperty("errorMessage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ErrorMessage { get; set; }

        /// <summary>Address in the format host:port</summary>
        [Newtonsoft.Json.JsonProperty("workerAgentAddress", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string WorkerAgentAddress { get; set; }

        /// <summary>Number of workers added if successful.</summary>
        [Newtonsoft.Json.JsonProperty("workersAdded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? WorkersAdded { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class RestCluster
    {
        /// <summary>The local member where the cluster endpoint is called from.</summary>
        [Newtonsoft.Json.JsonProperty("localMember", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public RestMember LocalMember { get; set; } = new RestMember();

        /// <summary>List of members of the cluster, including the local member. There should be at least one member in the list.</summary>
        [Newtonsoft.Json.JsonProperty("members", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<RestMember> Members { get; set; } = new System.Collections.ObjectModel.Collection<RestMember>();

        /// <summary>The name of the cluster</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class MarkupSet
    {
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("redactionReason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RedactionReason { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ItemPropertiesRequest
    {
        /// <summary>If true, excludes duplicate property values from the results. Default is true.</summary>
        [Newtonsoft.Json.JsonProperty("distinct", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Distinct { get; set; }

        /// <summary>Query items that should be included.  If a query is not supplied it defaults to an empty string, which returns all items.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Query { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class IngestibleCenteraCluster
    {
        /// <summary>Location of a file containing Centera Clip IDs separated by new-line characters. Both File and String instances are supported.</summary>
        [Newtonsoft.Json.JsonProperty("clipsFile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ClipsFile { get; set; }

        /// <summary>Location of a file containing IP addresses separated by new-line characters. Both File and String instances are supported.</summary>
        [Newtonsoft.Json.JsonProperty("ipsFile", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string IpsFile { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CustomMetadataFieldResponse
    {
        /// <summary>The default value</summary>
        [Newtonsoft.Json.JsonProperty("defaultValue", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object DefaultValue { get; set; } = new object();

        /// <summary>fieldName</summary>
        [Newtonsoft.Json.JsonProperty("fieldName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FieldName { get; set; }

        /// <summary>true if a null value is allowed, false otherwise</summary>
        [Newtonsoft.Json.JsonProperty("isNullAllowed", Required = Newtonsoft.Json.Required.Always)]
        public bool IsNullAllowed { get; set; }

        /// <summary>mode</summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Mode { get; set; }

        /// <summary>The allowable option values</summary>
        [Newtonsoft.Json.JsonProperty("options", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<object> Options { get; set; } = new System.Collections.ObjectModel.Collection<object>();

        /// <summary>type</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class WorkerBroker
    {
        /// <summary>The network address this worker broker is listening to. In the format - host:port</summary>
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Address { get; set; }

        /// <summary>A unique identifier for related IMS server instance.</summary>
        [Newtonsoft.Json.JsonProperty("serverId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ServerId { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AsyncFunctionSingleItemQueueStatus
    {
        [Newtonsoft.Json.JsonProperty("pause", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Pause { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SingleContainerIngestionRequestOfIngestibleSSH
    {
        /// <summary>Deprecated in favor of processingProfile. Configuration profile to use as base set of processor, parallel processing, and mime type settings.  Values present in processorSettings, parallelProcessingSettings, and mimeTypeProcessorSettings will override anything defined by this profile.</summary>
        [Newtonsoft.Json.JsonProperty("configurationProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationProfile { get; set; }

        /// <summary>The evidence container to create for this ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("container", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EvidenceContainer Container { get; set; }

        /// <summary>Sets the settings used to apply a keystore file to the ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("keystoreKeyParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyStoreKeyParameters> KeystoreKeyParameters { get; set; }

        /// <summary>Sets the processing settings for individual mime types.</summary>
        [Newtonsoft.Json.JsonProperty("mimeTypeProcessorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MimeTypeProcessingSetting> MimeTypeProcessorSettings { get; set; }

        /// <summary>Sets the parallel processing settings to use for processing.</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>The name of the Processing Profile to use. If you use this setting then do not use any other settings from processorSettings as everything will be overridden by the loaded Processing profile.</summary>
        [Newtonsoft.Json.JsonProperty("processingProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessingProfile { get; set; }

        /// <summary>Sets the processing settings to use.</summary>
        [Newtonsoft.Json.JsonProperty("processorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProcessorSettings ProcessorSettings { get; set; }

        /// <summary>If true, the case's Evidence Repositories will be rescanned to discover new Evidence Containers within them and new files within existing Evidence Containers which are themselves within the cases's Evidence Repositories. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("rescanEvidenceRepositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RescanEvidenceRepositories { get; set; }

        /// <summary>The ingestible target to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IngestibleSSH Target { get; set; } = new IngestibleSSH();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class BulkSearcherRequest
    {
        /// <summary>Whether the same query can be applied on more than one row with different tags. Defaults to true.</summary>
        [Newtonsoft.Json.JsonProperty("allowDuplicateQueries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AllowDuplicateQueries { get; set; }

        /// <summary>Whether the same tag can be applied on more than one row with different queries. Defaults to true.</summary>
        [Newtonsoft.Json.JsonProperty("allowDuplicateTags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AllowDuplicateTags { get; set; }

        /// <summary>Whether to create tags even if no items match them. Only has effect if matchingItemsAction == "addTags". Defaults to false.</summary>
        [Newtonsoft.Json.JsonProperty("createUnusedTags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CreateUnusedTags { get; set; }

        /// <summary>Whether deduplicated item families should also be matched. Defaults to false.</summary>
        [Newtonsoft.Json.JsonProperty("deduplicateFamilies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DeduplicateFamilies { get; set; }

        /// <summary>Whether tags for top-level item matches and family item matches should be expanded according to the tagExpansion map. Defaults to true.</summary>
        [Newtonsoft.Json.JsonProperty("expandTags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExpandTags { get; set; }

        /// <summary>Whether item families should also be matched. Defaults to false.</summary>
        [Newtonsoft.Json.JsonProperty("includeFamilies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeFamilies { get; set; }

        /// <summary>Action to take when a matching item is found. Tagging is performed when this option is "ADD_TAGS". Defaults to "ADD_TAGS".</summary>
        [Newtonsoft.Json.JsonProperty("matchingItemsAction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BulkSearcherRequestMatchingItemsAction? MatchingItemsAction { get; set; }

        /// <summary>What to do when a tag is missing in a table row. Does not affect blank rows. Defaults to FILL_WITH_QUERY.</summary>
        [Newtonsoft.Json.JsonProperty("missingTagsAction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BulkSearcherRequestMissingTagsAction? MissingTagsAction { get; set; }

        /// <summary>Whether excluded items should be excluded from matches. Defaults to true.</summary>
        [Newtonsoft.Json.JsonProperty("omitExcludedItems", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OmitExcludedItems { get; set; }

        /// <summary>Whether immaterial family items should be excluded from family item and deduplicated family item matches. Defaults to true.</summary>
        [Newtonsoft.Json.JsonProperty("omitImmaterialFamilyItems", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OmitImmaterialFamilyItems { get; set; }

        /// <summary>Whether to remove tags from the case if there are no longer any items that match them. Only has effect if matchingItemsAction == "removeTags". Defaults to false.</summary>
        [Newtonsoft.Json.JsonProperty("removeEmptyTags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RemoveEmptyTags { get; set; }

        /// <summary>A query that restricts the scope of all queries in the file. i.e. a common query that is joined with every individual query to limit the items that it can match. Defaults to an empty string.</summary>
        [Newtonsoft.Json.JsonProperty("scopingQuery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScopingQuery { get; set; }

        /// <summary>A list of fields to search. If null is passed in or this field is not set or empty then a list of default search fields is used (which consists of "CONTENT", "PROPERTIES", "NAME" and "PATH_NAME").</summary>
        [Newtonsoft.Json.JsonProperty("searchFields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<SearchFields> SearchFields { get; set; }

        /// <summary>Whether to show the tag name columns in the results table. Defaults to true.</summary>
        [Newtonsoft.Json.JsonProperty("showTagColumns", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ShowTagColumns { get; set; }

        [Newtonsoft.Json.JsonProperty("tagExpansion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TagExpansion TagExpansion { get; set; }

        /// <summary>A list of tag requests to perform.</summary>
        [Newtonsoft.Json.JsonProperty("tagRequests", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<TagRequest> TagRequests { get; set; } = new System.Collections.ObjectModel.Collection<TagRequest>();

        /// <summary>Whether to record items that only matched a single query. Defaults to false.</summary>
        [Newtonsoft.Json.JsonProperty("tagUniqueItems", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? TagUniqueItems { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AboutResponse
    {
        /// <summary>engineVersion</summary>
        [Newtonsoft.Json.JsonProperty("engineVersion", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string EngineVersion { get; set; }

        /// <summary>licenceSource</summary>
        [Newtonsoft.Json.JsonProperty("licenceSource", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string LicenceSource { get; set; }

        /// <summary>nuixRestfulVersion</summary>
        [Newtonsoft.Json.JsonProperty("nuixRestfulVersion", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string NuixRestfulVersion { get; set; }

        /// <summary>server</summary>
        [Newtonsoft.Json.JsonProperty("server", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Server { get; set; }

        /// <summary>serverId</summary>
        [Newtonsoft.Json.JsonProperty("serverId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ServerId { get; set; }

        /// <summary>startupTime</summary>
        [Newtonsoft.Json.JsonProperty("startupTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset StartupTime { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class OcrRequest
    {
        /// <summary>imagingOptions</summary>
        [Newtonsoft.Json.JsonProperty("ocrImagingOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ImagingOptions OcrImagingOptions { get; set; }

        /// <summary>ocrOptions</summary>
        [Newtonsoft.Json.JsonProperty("ocrOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OcrOptions OcrOptions { get; set; }

        /// <summary>paralleProcessingSettings</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>Query items that should be included. If a query is not supplied it defaults to an empty string, which returns everything.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class NuixReviewJobItem
    {
        /// <summary>Returns the date the review item was completed.</summary>
        [Newtonsoft.Json.JsonProperty("completionDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? CompletionDateTime { get; set; }

        /// <summary>Returns the item</summary>
        [Newtonsoft.Json.JsonProperty("item", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object Item { get; set; } = new object();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AsyncFunctionStatus
    {
        /// <summary>action</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Action { get; set; }

        /// <summary>Indicates whether the Async function has been canceled.</summary>
        [Newtonsoft.Json.JsonProperty("cancelled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cancelled { get; set; }

        /// <summary>Case identification token for the case on which the Async function was performed.</summary>
        [Newtonsoft.Json.JsonProperty("caseId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CaseId { get; set; }

        /// <summary>Location of the case on which the Async function was performed.</summary>
        [Newtonsoft.Json.JsonProperty("caseLocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CaseLocation { get; set; }

        /// <summary>Name of the case on which the Async function was performed.</summary>
        [Newtonsoft.Json.JsonProperty("caseName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CaseName { get; set; }

        /// <summary>Indicates whether the Async function has completed.</summary>
        [Newtonsoft.Json.JsonProperty("done", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Done { get; set; }

        /// <summary>Date at which the Async function request was finished.</summary>
        [Newtonsoft.Json.JsonProperty("finishTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? FinishTime { get; set; }

        /// <summary>Friendly name for the Async function.</summary>
        [Newtonsoft.Json.JsonProperty("friendlyName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FriendlyName { get; set; }

        /// <summary>Async function key</summary>
        [Newtonsoft.Json.JsonProperty("functionKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FunctionKey { get; set; }

        /// <summary>Indicated whether the Async function has successfully completed.</summary>
        [Newtonsoft.Json.JsonProperty("hasSuccessfullyCompleted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? HasSuccessfullyCompleted { get; set; }

        /// <summary>Options used during the execution of the Async function.</summary>
        [Newtonsoft.Json.JsonProperty("options", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Options { get; set; }

        /// <summary>participatingInCaseFunctionQueue</summary>
        [Newtonsoft.Json.JsonProperty("participatingInCaseFunctionQueue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ParticipatingInCaseFunctionQueue { get; set; }

        /// <summary>Percent completed, if available</summary>
        [Newtonsoft.Json.JsonProperty("percentComplete", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? PercentComplete { get; set; }

        /// <summary>Progress of the Async function</summary>
        [Newtonsoft.Json.JsonProperty("progress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Progress { get; set; }

        /// <summary>Date at which the Async function request was made.</summary>
        [Newtonsoft.Json.JsonProperty("requestTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? RequestTime { get; set; }

        /// <summary>Username for user who requested the Async function.</summary>
        [Newtonsoft.Json.JsonProperty("requestor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Requestor { get; set; }

        /// <summary>Result of the function.</summary>
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Result { get; set; }

        /// <summary>Date at which the Async function request was started.</summary>
        [Newtonsoft.Json.JsonProperty("startTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? StartTime { get; set; }

        /// <summary>Status of the Async function.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Status { get; set; }

        /// <summary>Authentication token used to initiate the function.</summary>
        [Newtonsoft.Json.JsonProperty("token", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Token { get; set; }

        /// <summary>total</summary>
        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Total { get; set; }

        /// <summary>Date at which the Async function was last updated.</summary>
        [Newtonsoft.Json.JsonProperty("updatedOn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? UpdatedOn { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TagExpansion
    {
        /// <summary>A prefix to apply to deduplicated family item matches, or null not to apply a prefix. Only has an effect if deduplicateFamilies == true. Defaults to null.</summary>
        [Newtonsoft.Json.JsonProperty("deduplicatedFamilyMatchPrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DeduplicatedFamilyMatchPrefix { get; set; }

        /// <summary>A suffix to apply to deduplicated family item matches, or null not to apply a suffix. Only has an effect if deduplicateFamilies == true. Defaults to null.</summary>
        [Newtonsoft.Json.JsonProperty("deduplicatedFamilyMatchSuffix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DeduplicatedFamilyMatchSuffix { get; set; }

        /// <summary>A prefix to apply to deduplicated top-level item matches, or null not to apply a prefix. Only has an effect if deduplicateFamilies == true. Defaults to null.</summary>
        [Newtonsoft.Json.JsonProperty("deduplicatedTopLevelMatchPrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DeduplicatedTopLevelMatchPrefix { get; set; }

        /// <summary>A suffix to apply to deduplicated top-level item matches, or null not to apply a suffix. Only has an effect if deduplicateFamilies == true. Defaults to null.</summary>
        [Newtonsoft.Json.JsonProperty("deduplicatedTopLevelMatchSuffix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DeduplicatedTopLevelMatchSuffix { get; set; }

        /// <summary>A prefix to apply to direct matches, i.e. items that match the given query, or null not to apply a prefix. Defaults to null.</summary>
        [Newtonsoft.Json.JsonProperty("directMatchPrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DirectMatchPrefix { get; set; }

        /// <summary>A suffix to apply to direct matches, i.e. items that match the given query, or null not to apply a suffix. Defaults to null.</summary>
        [Newtonsoft.Json.JsonProperty("directMatchSuffix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DirectMatchSuffix { get; set; }

        /// <summary>A prefix to apply to family item matches, or null not to apply a prefix. Only has an effect if includeFamilies == true. Defaults to null.</summary>
        [Newtonsoft.Json.JsonProperty("familyMatchPrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FamilyMatchPrefix { get; set; }

        /// <summary>A suffix to apply to family item matches, or null not to apply a suffix. Only has an effect if includeFamilies == true. Defaults to null.</summary>
        [Newtonsoft.Json.JsonProperty("familyMatchSuffix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FamilyMatchSuffix { get; set; }

        /// <summary>A prefix to apply to top-level item matches, or null not to apply a prefix. Only has an effect if includeFamilies == true. Defaults to null.</summary>
        [Newtonsoft.Json.JsonProperty("topLevelMatchPrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TopLevelMatchPrefix { get; set; }

        /// <summary>A suffix to apply to top-level item matches, or null not to apply a suffix. Only has an effect if includeFamilies == true. Defaults to null.</summary>
        [Newtonsoft.Json.JsonProperty("topLevelMatchSuffix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TopLevelMatchSuffix { get; set; }

        /// <summary>A prefix to apply to unique item matches, or null not to apply a prefix. Only has an effect if tagUniqueItems == true. Defaults to null.</summary>
        [Newtonsoft.Json.JsonProperty("uniqueMatchPrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UniqueMatchPrefix { get; set; }

        /// <summary>A suffix to apply to unique item matches, or null not to apply a prefix. Only has an effect if tagUniqueItems == true. Defaults to null.</summary>
        [Newtonsoft.Json.JsonProperty("uniqueMatchSuffix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string UniqueMatchSuffix { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SingleContainerIngestionRequestOfIngestibleDropbox
    {
        /// <summary>Deprecated in favor of processingProfile. Configuration profile to use as base set of processor, parallel processing, and mime type settings.  Values present in processorSettings, parallelProcessingSettings, and mimeTypeProcessorSettings will override anything defined by this profile.</summary>
        [Newtonsoft.Json.JsonProperty("configurationProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationProfile { get; set; }

        /// <summary>The evidence container to create for this ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("container", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EvidenceContainer Container { get; set; }

        /// <summary>Sets the settings used to apply a keystore file to the ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("keystoreKeyParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyStoreKeyParameters> KeystoreKeyParameters { get; set; }

        /// <summary>Sets the processing settings for individual mime types.</summary>
        [Newtonsoft.Json.JsonProperty("mimeTypeProcessorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MimeTypeProcessingSetting> MimeTypeProcessorSettings { get; set; }

        /// <summary>Sets the parallel processing settings to use for processing.</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>The name of the Processing Profile to use. If you use this setting then do not use any other settings from processorSettings as everything will be overridden by the loaded Processing profile.</summary>
        [Newtonsoft.Json.JsonProperty("processingProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessingProfile { get; set; }

        /// <summary>Sets the processing settings to use.</summary>
        [Newtonsoft.Json.JsonProperty("processorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProcessorSettings ProcessorSettings { get; set; }

        /// <summary>If true, the case's Evidence Repositories will be rescanned to discover new Evidence Containers within them and new files within existing Evidence Containers which are themselves within the cases's Evidence Repositories. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("rescanEvidenceRepositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RescanEvidenceRepositories { get; set; }

        /// <summary>The ingestible target to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IngestibleDropbox Target { get; set; } = new IngestibleDropbox();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SearchMacroStructuredResponse
    {
        [Newtonsoft.Json.JsonProperty("files", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SearchMacroResponse> Files { get; set; } = new System.Collections.ObjectModel.Collection<SearchMacroResponse>();

        [Newtonsoft.Json.JsonProperty("folders", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IDictionary<string, SearchMacroStructuredResponse> Folders { get; set; } = new System.Collections.Generic.Dictionary<string, SearchMacroStructuredResponse>();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApplyTagListResponse
    {
        /// <summary>List of tags that failed the operation</summary>
        [Newtonsoft.Json.JsonProperty("failedTags", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> FailedTags { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>List of tags that successfully completed the operation</summary>
        [Newtonsoft.Json.JsonProperty("successfulTags", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> SuccessfulTags { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>List of tags used during the operation</summary>
        [Newtonsoft.Json.JsonProperty("tagList", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> TagList { get; set; } = new System.Collections.ObjectModel.Collection<string>();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SearchNativeRequest
    {
        /// <summary>Deduplicate content based on the Value field selection.  Defaults to no deduplication.</summary>
        [Newtonsoft.Json.JsonProperty("deduplicate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SearchNativeRequestDeduplicate? Deduplicate { get; set; }

        /// <summary>List of entity names to include in response (e.g. company,email)</summary>
        [Newtonsoft.Json.JsonProperty("entities", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Entities { get; set; }

        /// <summary>List of fields to be returned for each item in the results.</summary>
        [Newtonsoft.Json.JsonProperty("fieldList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> FieldList { get; set; }

        /// <summary>Specifies whether the cached results should be deleted before performing the search. Defaults to false.</summary>
        [Newtonsoft.Json.JsonProperty("forceCacheDelete", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ForceCacheDelete { get; set; }

        /// <summary>Defines the metadata profile to be appied to the results. Needed to get custom metadata. Defaults to no metadata profile.</summary>
        [Newtonsoft.Json.JsonProperty("metadataProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MetadataProfile { get; set; }

        /// <summary>The number of records that should be returned. Defaults to all records.</summary>
        [Newtonsoft.Json.JsonProperty("numberOfRecordsRequested", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumberOfRecordsRequested { get; set; }

        /// <summary>List of properties to be returned for each item in the results.</summary>
        [Newtonsoft.Json.JsonProperty("propertyList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> PropertyList { get; set; }

        /// <summary>Identifies what items should be returned.  If a query is not supplied it defaults to an empty string, which returns all items.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Query { get; set; }

        /// <summary>The relation to apply to the found items. For performance reaons, the family option is run against the top-level items.</summary>
        [Newtonsoft.Json.JsonProperty("relationType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SearchNativeRequestRelationType? RelationType { get; set; }

        /// <summary>Any field in the metadata profile which you want to sort by.</summary>
        [Newtonsoft.Json.JsonProperty("sortField", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SortField { get; set; }

        /// <summary>Sets the sort order for the results. Defaults to "ASC".</summary>
        [Newtonsoft.Json.JsonProperty("sortOrder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SearchNativeRequestSortOrder? SortOrder { get; set; }

        /// <summary>The index of the first record that should be returned. Defaults to 0.</summary>
        [Newtonsoft.Json.JsonProperty("startIndex", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? StartIndex { get; set; }

        /// <summary>Specifies whether the results should be loaded from and stored in cache. Defaults to false.</summary>
        [Newtonsoft.Json.JsonProperty("useCache", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UseCache { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SearchMacroResponse
    {
        [Newtonsoft.Json.JsonProperty("expansion", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Expansion { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class BulkExclusionRequest
    {
        [Newtonsoft.Json.JsonProperty("duplicatesQuery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DuplicatesQuery { get; set; }

        [Newtonsoft.Json.JsonProperty("excludeDescendants", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExcludeDescendants { get; set; }

        [Newtonsoft.Json.JsonProperty("familyQuery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FamilyQuery { get; set; }

        [Newtonsoft.Json.JsonProperty("includeDuplicates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeDuplicates { get; set; }

        [Newtonsoft.Json.JsonProperty("includeFamily", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeFamily { get; set; }

        [Newtonsoft.Json.JsonProperty("includeNearDuplicates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeNearDuplicates { get; set; }

        [Newtonsoft.Json.JsonProperty("nearDuplicatesQuery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NearDuplicatesQuery { get; set; }

        [Newtonsoft.Json.JsonProperty("nearDuplicatesThreshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? NearDuplicatesThreshold { get; set; }

        /// <summary>Query items that should be included. If a query is not supplied it defaults to an empty string, which returns all items.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }

        [Newtonsoft.Json.JsonProperty("reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reason { get; set; }

        [Newtonsoft.Json.JsonProperty("threadsQuery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ThreadsQuery { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class IngestibleLoadFile
    {
        /// <summary>Location of a UTF-8 encoded CSV file containing an ITEMPATH column with values containing relative paths to the native items. Currently all other columns become metadata for that item. Not used if missing, but one load file type is required.</summary>
        [Newtonsoft.Json.JsonProperty("csvFile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CsvFile { get; set; }

        /// <summary>Location of a UTF-8 encoded IDX file. Not used if missing, but one load file type is required.</summary>
        [Newtonsoft.Json.JsonProperty("idxFile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IdxFile { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AuthenticationResponse
    {
        /// <summary>authToken</summary>
        [Newtonsoft.Json.JsonProperty("authToken", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AuthToken { get; set; }

        /// <summary>licenceDescription</summary>
        [Newtonsoft.Json.JsonProperty("licenceDescription", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string LicenceDescription { get; set; }

        /// <summary>username</summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Username { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class IngestibleSSH
    {
        /// <summary>When set to true remote disks (e.g. '/dev/sda1') will be exposed as evidence instead of the remote system's file system structure.</summary>
        [Newtonsoft.Json.JsonProperty("accessingRemoteDisks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AccessingRemoteDisks { get; set; }

        /// <summary>The hostname or IP address of the target server.</summary>
        [Newtonsoft.Json.JsonProperty("computer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Computer { get; set; }

        /// <summary>This optional parameter defines the Windows networking domain of the server account.</summary>
        [Newtonsoft.Json.JsonProperty("domain", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Domain { get; set; }

        /// <summary>The expected host fingerprint for the host being connected to. If this value is not set then any host fingerpint will be allowed, leaving the possibility of a man in the middle attack on the connection.</summary>
        [Newtonsoft.Json.JsonProperty("hostFingerprint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HostFingerprint { get; set; }

        /// <summary>Points to a folder on the local system which holds the SSH authentication key pairs.</summary>
        [Newtonsoft.Json.JsonProperty("keyFolder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KeyFolder { get; set; }

        /// <summary>The password needed to access the server account.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Password { get; set; }

        /// <summary>The port number to connect on.</summary>
        [Newtonsoft.Json.JsonProperty("portNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PortNumber { get; set; }

        /// <summary>This optional parameter limits the evidence to items underneath this starting folder.</summary>
        [Newtonsoft.Json.JsonProperty("remoteFolder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RemoteFolder { get; set; }

        /// <summary>The password needed to access protected files when using SSH key based authentication.</summary>
        [Newtonsoft.Json.JsonProperty("sudoPassword", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SudoPassword { get; set; }

        /// <summary>The username needed to access the server account.</summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Username { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class BulkIngestionRequest
    {
        /// <summary>Deprecated in favor of processingProfile. Configuration profile to use as base set of processor, parallel processing, and mime type settings.  Values present in processorSettings, parallelProcessingSettings, and mimeTypeProcessorSettings will override anything defined by this profile.</summary>
        [Newtonsoft.Json.JsonProperty("configurationProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationProfile { get; set; }

        /// <summary>The list of evidence containers to create</summary>
        [Newtonsoft.Json.JsonProperty("containers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EvidenceContainerWithTargets> Containers { get; set; }

        /// <summary>Sets the settings used to apply a keystore file to the ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("keystoreKeyParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyStoreKeyParameters> KeystoreKeyParameters { get; set; }

        /// <summary>Sets the processing settings for individual mime types.</summary>
        [Newtonsoft.Json.JsonProperty("mimeTypeProcessorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MimeTypeProcessingSetting> MimeTypeProcessorSettings { get; set; }

        /// <summary>Sets the parallel processing settings to use for processing.</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>The name of the Processing Profile to use. If you use this setting then do not use any other settings from processorSettings as everything will be overridden by the loaded Processing profile.</summary>
        [Newtonsoft.Json.JsonProperty("processingProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessingProfile { get; set; }

        /// <summary>Sets the processing settings to use.</summary>
        [Newtonsoft.Json.JsonProperty("processorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProcessorSettings ProcessorSettings { get; set; }

        /// <summary>The list of evidence repositories to create</summary>
        [Newtonsoft.Json.JsonProperty("repositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EvidenceRepository> Repositories { get; set; }

        /// <summary>If true, the case's Evidence Repositories will be rescanned to discover new Evidence Containers within them and new files within existing Evidence Containers which are themselves within the cases's Evidence Repositories. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("rescanEvidenceRepositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RescanEvidenceRepositories { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ProcessorSettings
    {
        /// <summary>If true, adds the Bcc field when computing email digests. Using the Bcc field in email digests may prevent the sender and recipients digests from matching. This is because only the sender will have the Bcc field if it is present. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("addBccToEmailDigests", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AddBccToEmailDigests { get; set; }

        /// <summary>If true, adds the communication date when computing email digests. Using the communication date in the email digests may prevent the sender and recipients digests from matching. This is because the sender and recipients communication date / times can be slightly different for the same email. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("addCommunicationDateToEmailDigests", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AddCommunicationDateToEmailDigests { get; set; }

        /// <summary>Specifies the language to use for text analysis when indexing. Supported language codes are: en - English, ja - Japanese. Default is "en".</summary>
        [Newtonsoft.Json.JsonProperty("analysisLanguage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AnalysisLanguage { get; set; }

        /// <summary>If true, calculates audited size.  Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("calculateAuditedSize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CalculateAuditedSize { get; set; }

        /// <summary>If true, calculate SSDeep fuzzy hash values for item. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("calculateSSDeepFuzzyHash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CalculateSSDeepFuzzyHash { get; set; }

        /// <summary>If true, carve data out of file system unallocated space for disk images.  Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("carveFileSystemUnallocatedSpace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CarveFileSystemUnallocatedSpace { get; set; }

        /// <summary>If true, carve data out of unidentified data items.  Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("carveUnidentifiedData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CarveUnidentifiedData { get; set; }

        /// <summary>If null, the block size of the file system is used. Otherwise the given block size is used. File identification is attempted at start of each block, so the smaller the value the longer processing will take. Avoid values smaller than 512 bytes except in specific cases. Default is null.</summary>
        [Newtonsoft.Json.JsonProperty("carvingBlockSize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? CarvingBlockSize { get; set; }

        /// <summary>If true, create and store thumbnails of image data items.  Default is true.</summary>
        [Newtonsoft.Json.JsonProperty("createThumbnails", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CreateThumbnails { get; set; }

        /// <summary>If true, detect faces in photographic items. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("detectFaces", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DetectFaces { get; set; }

        /// <summary>A list of digests to calculate.  Default is MD5</summary>
        [Newtonsoft.Json.JsonProperty("digests", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Digests> Digests { get; set; }

        /// <summary>If true, enables search using "exact" queries.  Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("enableExactQueries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EnableExactQueries { get; set; }

        /// <summary>If true, extract the slack space from the end of file records in disk images.  Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("extractEndOfFileSlackSpace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExtractEndOfFileSlackSpace { get; set; }

        /// <summary>If true, extract deleted data from mailbox file formats and slack space from the end of file records in file system disk images.  Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("extractFromSlackSpace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExtractFromSlackSpace { get; set; }

        /// <summary>If true, extract named entities from the text of a document.  Default is false. NOTE: This is deprecated and will be removed in future release.</summary>
        [Newtonsoft.Json.JsonProperty("extractNamedEntities", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExtractNamedEntities { get; set; }

        /// <summary>If true, extracts named entities from the properties of a document.  Default is false</summary>
        [Newtonsoft.Json.JsonProperty("extractNamedEntitiesFromProperties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExtractNamedEntitiesFromProperties { get; set; }

        /// <summary>If true, extracts named entities from the text of a document.  Default is false</summary>
        [Newtonsoft.Json.JsonProperty("extractNamedEntitiesFromText", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExtractNamedEntitiesFromText { get; set; }

        /// <summary>If true, extracts named entities from the text of text-stripped items, if and only if 'extractNamedEntitesFromText' is true. The 'extractNamedEntitiesFromProperties' setting is independent of this property.  Default is false</summary>
        [Newtonsoft.Json.JsonProperty("extractNamedEntitiesFromTextStripped", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExtractNamedEntitiesFromTextStripped { get; set; }

        /// <summary>If true, extract shingles from item text. Enabling this setting enables near deduplication.  Default is true.</summary>
        [Newtonsoft.Json.JsonProperty("extractShingles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExtractShingles { get; set; }

        /// <summary>If true, hides embedded immaterial data items such as embedded images in documents.  Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("hideEmbeddedImmaterialData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? HideEmbeddedImmaterialData { get; set; }

        /// <summary>If false, only file system metadata is extracted for physical files on disk.  Default is true.</summary>
        [Newtonsoft.Json.JsonProperty("identifyPhysicalFiles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IdentifyPhysicalFiles { get; set; }

        /// <summary>Specifies the maximum size of binary which will be digested, in bytes. Default is 250000000 (250 MB).</summary>
        [Newtonsoft.Json.JsonProperty("maxDigestSize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxDigestSize { get; set; }

        /// <summary>Specifies the maximum size of binary which will be stored into the binary store, in bytes. Default is 250000000 (250 MB).</summary>
        [Newtonsoft.Json.JsonProperty("maxStoredBinarySize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxStoredBinarySize { get; set; }

        /// <summary>If true, top-level items will contain search fields containing text from their family.  Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("processFamilyFields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ProcessFamilyFields { get; set; }

        /// <summary>If true, the contents of forensic images will be exposed. If false metadata about forensic images will be extracted but their contents will not be processed. This settings can be used in combination with processLooseFileContents to explode forensic images but not process their contents. Default is true.</summary>
        [Newtonsoft.Json.JsonProperty("processForensicImages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ProcessForensicImages { get; set; }

        /// <summary>If true, the contents of loose files will be extracted and processed. If false metadata about loose files will be extracted but their contents will not be processed. Default is true.</summary>
        [Newtonsoft.Json.JsonProperty("processLooseFileContents", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ProcessLooseFileContents { get; set; }

        /// <summary>If true, stores and indexes the text of data items.  Default is true.</summary>
        [Newtonsoft.Json.JsonProperty("processText", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ProcessText { get; set; }

        /// <summary>If true, process item text and summarise.  Default is true.</summary>
        [Newtonsoft.Json.JsonProperty("processTextSummaries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ProcessTextSummaries { get; set; }

        /// <summary>If true, recover deleted file records from disk images.  Default is true.</summary>
        [Newtonsoft.Json.JsonProperty("recoverDeletedFiles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RecoverDeletedFiles { get; set; }

        /// <summary>If "physical_files", then the total evidence physical file size is calculated before processing starts. If "none", then no up-front calculation is performed. Non-file data will always be treated as "none". Default is none.</summary>
        [Newtonsoft.Json.JsonProperty("reportProcessingStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ProcessorSettingsReportProcessingStatus? ReportProcessingStatus { get; set; }

        /// <summary>If true, existing evidence stores are used to add any additional data into.  Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("reuseEvidenceStores", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReuseEvidenceStores { get; set; }

        /// <summary>If true, perform analysis on images to detect skintones.  Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("skinToneAnalysis", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SkinToneAnalysis { get; set; }

        /// <summary>If true, only process sections of the Registry that have decoders of have been explicitly selected. Default is false</summary>
        [Newtonsoft.Json.JsonProperty("smartProcessRegistry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SmartProcessRegistry { get; set; }

        /// <summary>If true, stems words using English rules before indexing (e.g. "fishing" -&gt; "fish".). If false, no stemming is performed. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("stemming", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Stemming { get; set; }

        /// <summary>If true, removes English stop words ("a", "and", "the", etc.) from the text index. If false, no stop words are removed. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("stopWords", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? StopWords { get; set; }

        /// <summary>If true, store the binary of data items.  Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("storeBinary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? StoreBinary { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SearchHitResponse
    {
        /// <summary>Map containing the set of search hits by property name.  Objects are map[string, array[SearchHit]</summary>
        [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object Properties { get; set; } = new object();

        /// <summary>Set of matching terms</summary>
        [Newtonsoft.Json.JsonProperty("terms", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Terms { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>Set of search hits matching the text content</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<SearchHit> Text { get; set; } = new System.Collections.ObjectModel.Collection<SearchHit>();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ItemSizeResponse
    {
        /// <summary>The specified query.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }

        /// <summary>The relevant size.</summary>
        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Always)]
        public long Size { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SingleContainerIngestionRequestOfIngestibleEnterpriseVault
    {
        /// <summary>Deprecated in favor of processingProfile. Configuration profile to use as base set of processor, parallel processing, and mime type settings.  Values present in processorSettings, parallelProcessingSettings, and mimeTypeProcessorSettings will override anything defined by this profile.</summary>
        [Newtonsoft.Json.JsonProperty("configurationProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationProfile { get; set; }

        /// <summary>The evidence container to create for this ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("container", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EvidenceContainer Container { get; set; }

        /// <summary>Sets the settings used to apply a keystore file to the ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("keystoreKeyParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyStoreKeyParameters> KeystoreKeyParameters { get; set; }

        /// <summary>Sets the processing settings for individual mime types.</summary>
        [Newtonsoft.Json.JsonProperty("mimeTypeProcessorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MimeTypeProcessingSetting> MimeTypeProcessorSettings { get; set; }

        /// <summary>Sets the parallel processing settings to use for processing.</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>The name of the Processing Profile to use. If you use this setting then do not use any other settings from processorSettings as everything will be overridden by the loaded Processing profile.</summary>
        [Newtonsoft.Json.JsonProperty("processingProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessingProfile { get; set; }

        /// <summary>Sets the processing settings to use.</summary>
        [Newtonsoft.Json.JsonProperty("processorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProcessorSettings ProcessorSettings { get; set; }

        /// <summary>If true, the case's Evidence Repositories will be rescanned to discover new Evidence Containers within them and new files within existing Evidence Containers which are themselves within the cases's Evidence Repositories. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("rescanEvidenceRepositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RescanEvidenceRepositories { get; set; }

        /// <summary>The ingestible target to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IngestibleEnterpriseVault Target { get; set; } = new IngestibleEnterpriseVault();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CaseSubsetProcessingSettings
    {
        /// <summary>A supported language code.  en - English, ja - Japanese. Default is "en".</summary>
        [Newtonsoft.Json.JsonProperty("analysisLanguage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AnalysisLanguage { get; set; }

        /// <summary>enableExactQueries.  Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("enableExactQueries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EnableExactQueries { get; set; }

        /// <summary>If true, stems words using English rules before indexing (e.g. "fishing" -&gt; "fish".) If false, no stemming is performed. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("stemming", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Stemming { get; set; }

        /// <summary>stopWords.  Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("stopWords", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? StopWords { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class IngestibleS3Bucket
    {
        /// <summary>This parameter specifies the access key ID for an Amazon Web Service account.</summary>
        [Newtonsoft.Json.JsonProperty("access", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Access { get; set; }

        /// <summary>This optional parameter specifies a bucket and optionally a path to a folder within the bucket that contains the evidence to ingest. For example, 'com.nuix.mybucket/top folder/sub folder'. Omitting this parameter will cause all buckets to be added to evidence.</summary>
        [Newtonsoft.Json.JsonProperty("bucket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bucket { get; set; }

        /// <summary>This optional parameter specifies a particular Amazon Web Service server endpoint. This can be used to connect to a particular regional server e.g., https://s3.amazonaws.com.</summary>
        [Newtonsoft.Json.JsonProperty("endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Endpoint { get; set; }

        /// <summary>This parameter specifies the secret access key for an Amazon Web Service account.</summary>
        [Newtonsoft.Json.JsonProperty("secret", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Secret { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ImagingOptions
    {
        /// <summary>Defaults to INTERNAL</summary>
        [Newtonsoft.Json.JsonProperty("excelExportingEngine", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ImagingOptionsExcelExportingEngine? ExcelExportingEngine { get; set; }

        /// <summary>Defaults to null which uses the settings present in the document</summary>
        [Newtonsoft.Json.JsonProperty("excelFitToPagesTall", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ExcelFitToPagesTall { get; set; }

        /// <summary>Defaults to null which uses the settings present in the document</summary>
        [Newtonsoft.Json.JsonProperty("excelFitToPagesWide", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ExcelFitToPagesWide { get; set; }

        /// <summary>Defaults to null which uses the settings present in the document</summary>
        [Newtonsoft.Json.JsonProperty("excelPageNumberLimit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ExcelPageNumberLimit { get; set; }

        /// <summary>Defaults to null which uses the settings present in the document</summary>
        [Newtonsoft.Json.JsonProperty("excelPageOrientation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ImagingOptionsExcelPageOrientation? ExcelPageOrientation { get; set; }

        /// <summary>Defaults to null which uses the settings present in the document</summary>
        [Newtonsoft.Json.JsonProperty("excelPageZoom", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ImagingOptionsExcelPageZoom? ExcelPageZoom { get; set; }

        /// <summary>Defaults to null which uses the settings present in the document</summary>
        [Newtonsoft.Json.JsonProperty("excelPaperSize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ImagingOptionsExcelPaperSize? ExcelPaperSize { get; set; }

        /// <summary>Defaults to null which uses the settings present in the document</summary>
        [Newtonsoft.Json.JsonProperty("excelPrintComments", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ImagingOptionsExcelPrintComments? ExcelPrintComments { get; set; }

        /// <summary>Defaults to true</summary>
        [Newtonsoft.Json.JsonProperty("excelPrintGridlines", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExcelPrintGridlines { get; set; }

        /// <summary>Defaults to true</summary>
        [Newtonsoft.Json.JsonProperty("excelPrintHeadings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExcelPrintHeadings { get; set; }

        /// <summary>Defaults to null which uses the settings present in the document</summary>
        [Newtonsoft.Json.JsonProperty("excelPrintHiddenColumns", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExcelPrintHiddenColumns { get; set; }

        /// <summary>Defaults to null which uses the settings present in the document</summary>
        [Newtonsoft.Json.JsonProperty("excelPrintHiddenRows", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExcelPrintHiddenRows { get; set; }

        /// <summary>Defaults to SHEET_VERY_HIDDEN</summary>
        [Newtonsoft.Json.JsonProperty("excelPrintHiddenWorksheets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ImagingOptionsExcelPrintHiddenWorksheets? ExcelPrintHiddenWorksheets { get; set; }

        /// <summary>Defaults to null which uses the settings present in the document</summary>
        [Newtonsoft.Json.JsonProperty("excelPrintNotes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ExcelPrintNotes { get; set; }

        /// <summary>Empty string for entire worksheet or standard excel range string (e.g., $A$1:$J$10). Defaults to empty string</summary>
        [Newtonsoft.Json.JsonProperty("excelWorksheetPrintArea", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExcelWorksheetPrintArea { get; set; }

        /// <summary>Defaults to false</summary>
        [Newtonsoft.Json.JsonProperty("imageExcelSpreadsheets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ImageExcelSpreadsheets { get; set; }

        /// <summary>Defaults to PRINT_OUTPUT_SLIDES</summary>
        [Newtonsoft.Json.JsonProperty("powerPointPrintOutputType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ImagingOptionsPowerPointPrintOutputType? PowerPointPrintOutputType { get; set; }

        /// <summary>Defaults to INTERNAL</summary>
        [Newtonsoft.Json.JsonProperty("powerpointExportEngine", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ImagingOptionsPowerpointExportEngine? PowerpointExportEngine { get; set; }

        /// <summary>Defaults to false</summary>
        [Newtonsoft.Json.JsonProperty("slipSheetContainers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SlipSheetContainers { get; set; }

        /// <summary>Defaults to null which uses the settings present in the document</summary>
        [Newtonsoft.Json.JsonProperty("slipSheetMetadataProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SlipSheetMetadataProfile { get; set; }

        /// <summary>Defaults to INTERNAL</summary>
        [Newtonsoft.Json.JsonProperty("wordExportingEngine", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ImagingOptionsWordExportingEngine? WordExportingEngine { get; set; }

        /// <summary>Defaults to null which uses the settings present in the document</summary>
        [Newtonsoft.Json.JsonProperty("wordShowHiddenText", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? WordShowHiddenText { get; set; }

        /// <summary>Defaults to null which uses the settings present in the document</summary>
        [Newtonsoft.Json.JsonProperty("wordShowMarkup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? WordShowMarkup { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class NuixItemType
    {
        /// <summary>count</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Always)]
        public long Count { get; set; }

        /// <summary>kind</summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Kind { get; set; }

        /// <summary>localisedName</summary>
        [Newtonsoft.Json.JsonProperty("localisedName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string LocalisedName { get; set; }

        /// <summary>name</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>preferredExtension</summary>
        [Newtonsoft.Json.JsonProperty("preferredExtension", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string PreferredExtension { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SingleContainerIngestionRequestOfIngestibleFile
    {
        /// <summary>Deprecated in favor of processingProfile. Configuration profile to use as base set of processor, parallel processing, and mime type settings.  Values present in processorSettings, parallelProcessingSettings, and mimeTypeProcessorSettings will override anything defined by this profile.</summary>
        [Newtonsoft.Json.JsonProperty("configurationProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationProfile { get; set; }

        /// <summary>The evidence container to create for this ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("container", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EvidenceContainer Container { get; set; }

        /// <summary>Sets the settings used to apply a keystore file to the ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("keystoreKeyParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyStoreKeyParameters> KeystoreKeyParameters { get; set; }

        /// <summary>Sets the processing settings for individual mime types.</summary>
        [Newtonsoft.Json.JsonProperty("mimeTypeProcessorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MimeTypeProcessingSetting> MimeTypeProcessorSettings { get; set; }

        /// <summary>Sets the parallel processing settings to use for processing.</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>The name of the Processing Profile to use. If you use this setting then do not use any other settings from processorSettings as everything will be overridden by the loaded Processing profile.</summary>
        [Newtonsoft.Json.JsonProperty("processingProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessingProfile { get; set; }

        /// <summary>Sets the processing settings to use.</summary>
        [Newtonsoft.Json.JsonProperty("processorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProcessorSettings ProcessorSettings { get; set; }

        /// <summary>If true, the case's Evidence Repositories will be rescanned to discover new Evidence Containers within them and new files within existing Evidence Containers which are themselves within the cases's Evidence Repositories. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("rescanEvidenceRepositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RescanEvidenceRepositories { get; set; }

        /// <summary>The ingestible target to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IngestibleFile Target { get; set; } = new IngestibleFile();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CreateCaseSubsetRequest
    {
        /// <summary>Sets metadata on the case</summary>
        [Newtonsoft.Json.JsonProperty("caseMetadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CaseSubsetMetadata CaseMetadata { get; set; }

        /// <summary>Copy classifiers from the source case to the destination case.  Default is false</summary>
        [Newtonsoft.Json.JsonProperty("copyClassifiers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CopyClassifiers { get; set; }

        /// <summary>Copy clusters from the source case to the destination case.  Default is false</summary>
        [Newtonsoft.Json.JsonProperty("copyClusters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CopyClusters { get; set; }

        /// <summary>Copy comments from the source case to the destination case.  Default is false</summary>
        [Newtonsoft.Json.JsonProperty("copyComments", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CopyComments { get; set; }

        /// <summary>Copy custodians from the source case to the destination case.  Default is false</summary>
        [Newtonsoft.Json.JsonProperty("copyCustodians", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CopyCustodians { get; set; }

        /// <summary>Copy custom metadata from the source case to the destination case.  Default is false</summary>
        [Newtonsoft.Json.JsonProperty("copyCustomMetadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CopyCustomMetadata { get; set; }

        /// <summary>Copy item sets from the source case to the destination case.  Default is false</summary>
        [Newtonsoft.Json.JsonProperty("copyItemSets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CopyItemSets { get; set; }

        /// <summary>Copy markup sets from the source case to the destination case.  Default is false</summary>
        [Newtonsoft.Json.JsonProperty("copyMarkupSets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CopyMarkupSets { get; set; }

        /// <summary>Copy production sets from the source case to the destination case.  Default is false</summary>
        [Newtonsoft.Json.JsonProperty("copyProductionSets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CopyProductionSets { get; set; }

        /// <summary>Copy tags from the source case to the destination case.  Default is false</summary>
        [Newtonsoft.Json.JsonProperty("copyTags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CopyTags { get; set; }

        /// <summary>Specifies the maximum number of evidence stores to create.  Default is 1</summary>
        [Newtonsoft.Json.JsonProperty("evidenceStoreCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? EvidenceStoreCount { get; set; }

        /// <summary>Include item families in export.  Default is false</summary>
        [Newtonsoft.Json.JsonProperty("includeFamilies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeFamilies { get; set; }

        /// <summary>Where the subset case should be created.  e.g. inventory0, or an absolute directory</summary>
        [Newtonsoft.Json.JsonProperty("location", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Location { get; set; }

        /// <summary>Sets settings for processing in the new case</summary>
        [Newtonsoft.Json.JsonProperty("processingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CaseSubsetProcessingSettings ProcessingSettings { get; set; }

        /// <summary>Query items that should be included in the subset. If a query is not supplied it defaults to an empty string, which returns all items.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Query { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ItemSetResponse
    {
        /// <summary>description</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Description { get; set; }

        /// <summary>name</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class RestMember
    {
        /// <summary>The IP address of the member.</summary>
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Address { get; set; }

        /// <summary>The port number of the member for communication between other cluster members.</summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Always)]
        public int Port { get; set; }

        /// <summary>The serverId of the member. The serverId is the instance serverId.</summary>
        [Newtonsoft.Json.JsonProperty("serverId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ServerId { get; set; }

        /// <summary>The worker agent if the instance is running as a worker agent, null otherwise.</summary>
        [Newtonsoft.Json.JsonProperty("workerAgent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WorkerAgent WorkerAgent { get; set; }

        /// <summary>The worker broker if the instance is running as a worker broker, null otherwise.</summary>
        [Newtonsoft.Json.JsonProperty("workerBroker", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WorkerBroker WorkerBroker { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class BulkItemCustomMetadataRequest
    {
        /// <summary>The name of the custom metadata field</summary>
        [Newtonsoft.Json.JsonProperty("fieldName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FieldName { get; set; }

        /// <summary>The custom metadata mode</summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BulkItemCustomMetadataRequestMode Mode { get; set; }

        /// <summary>Any parameters required to parse the value field</summary>
        [Newtonsoft.Json.JsonProperty("params", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Params { get; set; }

        /// <summary>Query items that should be included. If a query is not supplied it defaults to an empty string, which returns all items.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }

        /// <summary>The data type of the field</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BulkItemCustomMetadataRequestType Type { get; set; }

        /// <summary>The value of the custom metadata field</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object Value { get; set; } = new object();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AsyncFunctionStatusOfobject
    {
        /// <summary>action</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Action { get; set; }

        /// <summary>Indicates whether the Async function has been canceled.</summary>
        [Newtonsoft.Json.JsonProperty("cancelled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Cancelled { get; set; }

        /// <summary>Case identification token for the case on which the Async function was performed.</summary>
        [Newtonsoft.Json.JsonProperty("caseId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CaseId { get; set; }

        /// <summary>Location of the case on which the Async function was performed.</summary>
        [Newtonsoft.Json.JsonProperty("caseLocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CaseLocation { get; set; }

        /// <summary>Name of the case on which the Async function was performed.</summary>
        [Newtonsoft.Json.JsonProperty("caseName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CaseName { get; set; }

        /// <summary>Indicates whether the Async function has completed.</summary>
        [Newtonsoft.Json.JsonProperty("done", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Done { get; set; }

        /// <summary>Date at which the Async function request was finished.</summary>
        [Newtonsoft.Json.JsonProperty("finishTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? FinishTime { get; set; }

        /// <summary>Friendly name for the Async function.</summary>
        [Newtonsoft.Json.JsonProperty("friendlyName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FriendlyName { get; set; }

        /// <summary>Async function key</summary>
        [Newtonsoft.Json.JsonProperty("functionKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FunctionKey { get; set; }

        /// <summary>Indicated whether the Async function has successfully completed.</summary>
        [Newtonsoft.Json.JsonProperty("hasSuccessfullyCompleted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? HasSuccessfullyCompleted { get; set; }

        /// <summary>Options used during the execution of the Async function.</summary>
        [Newtonsoft.Json.JsonProperty("options", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Options { get; set; }

        /// <summary>participatingInCaseFunctionQueue</summary>
        [Newtonsoft.Json.JsonProperty("participatingInCaseFunctionQueue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ParticipatingInCaseFunctionQueue { get; set; }

        /// <summary>Percent completed, if available</summary>
        [Newtonsoft.Json.JsonProperty("percentComplete", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? PercentComplete { get; set; }

        /// <summary>Progress of the Async function</summary>
        [Newtonsoft.Json.JsonProperty("progress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Progress { get; set; }

        /// <summary>Date at which the Async function request was made.</summary>
        [Newtonsoft.Json.JsonProperty("requestTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? RequestTime { get; set; }

        /// <summary>Username for user who requested the Async function.</summary>
        [Newtonsoft.Json.JsonProperty("requestor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Requestor { get; set; }

        /// <summary>Result of the function.</summary>
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Result { get; set; }

        /// <summary>Date at which the Async function request was started.</summary>
        [Newtonsoft.Json.JsonProperty("startTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? StartTime { get; set; }

        /// <summary>Status of the Async function.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Status { get; set; }

        /// <summary>Authentication token used to initiate the function.</summary>
        [Newtonsoft.Json.JsonProperty("token", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Token { get; set; }

        /// <summary>total</summary>
        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Total { get; set; }

        /// <summary>Date at which the Async function was last updated.</summary>
        [Newtonsoft.Json.JsonProperty("updatedOn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? UpdatedOn { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ReviewJobResponse
    {
        /// <summary>Review job GUID</summary>
        [Newtonsoft.Json.JsonProperty("guid", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Guid { get; set; }

        /// <summary>name</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class FileSystemResource
    {
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        [Newtonsoft.Json.JsonProperty("file", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] File { get; set; }

        [Newtonsoft.Json.JsonProperty("filename", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Filename { get; set; }

        [Newtonsoft.Json.JsonProperty("open", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Open { get; set; }

        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

        [Newtonsoft.Json.JsonProperty("readable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Readable { get; set; }

        [Newtonsoft.Json.JsonProperty("writable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Writable { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CustomMetadataResponse
    {
        /// <summary>The name of the custom metadata field</summary>
        [Newtonsoft.Json.JsonProperty("fieldName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FieldName { get; set; }

        /// <summary>A template field in the custom metadata template</summary>
        [Newtonsoft.Json.JsonProperty("fieldTemplate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public CustomMetadataFieldResponse FieldTemplate { get; set; } = new CustomMetadataFieldResponse();

        /// <summary>The custom metadata mode</summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CustomMetadataResponseMode Mode { get; set; }

        /// <summary>The name of the custom metadata template that applies to the given custom metadata field</summary>
        [Newtonsoft.Json.JsonProperty("template", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Template { get; set; }

        /// <summary>The data type of the field</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CustomMetadataResponseType Type { get; set; }

        /// <summary>The value of the custom metadata field</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object Value { get; set; } = new object();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CountRequest
    {
        /// <summary>Identifies what items should be returned. If a query is not supplied it defaults to an empty string, which returns all items.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Query { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ElasticSearchSettings
    {
        /// <summary>Additional ElasticSearch settings to include. This is a flattened map (e.g. 'index.refresh_interval'). This is an advanced feature and should only be used by those familiar with ElasticSearch. Values that can be directly specified elsewhere in this request will be ignored if they are provided in this map. See ElasticSearch documentation for more info.</summary>
        [Newtonsoft.Json.JsonProperty("additionalSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> AdditionalSettings { get; set; }

        /// <summary>Name of the cluster to join. See ElasticSearch documentation for more info.</summary>
        [Newtonsoft.Json.JsonProperty("cluster.name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ClusterName { get; set; }

        /// <summary>Number of replicas to use. Must be a positive number. This can be modified after creation, but only through ElasticSearch APIs. See ElasticSearch documentation for more info.</summary>
        [Newtonsoft.Json.JsonProperty("index.number_of_replicas", Required = Newtonsoft.Json.Required.Always)]
        public int IndexNumber_of_replicas { get; set; }

        /// <summary>Number of shards to allocate for the index. Must be greater than zero. Cannot be changed after creating the index. See ElasticSearch documentation for more info.</summary>
        [Newtonsoft.Json.JsonProperty("index.number_of_shards", Required = Newtonsoft.Json.Required.Always)]
        public int IndexNumber_of_shards { get; set; }

        /// <summary>Refresh interval to use. Defaults to '60s'. See ElasticSearch documentation for more info.</summary>
        [Newtonsoft.Json.JsonProperty("index.refresh_interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IndexRefresh_interval { get; set; }

        /// <summary>The authenticated user's password.</summary>
        [Newtonsoft.Json.JsonProperty("nuix.auth.password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NuixAuthPassword { get; set; }

        /// <summary>The authenticated user's username. Used with X-Pack and SearchGuard, this can be different to the transport level credentials.</summary>
        [Newtonsoft.Json.JsonProperty("nuix.auth.username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NuixAuthUsername { get; set; }

        /// <summary>Should closing the case via Nuix close the index in ElasticSearch? Defaults to 'false'.</summary>
        [Newtonsoft.Json.JsonProperty("nuix.index.auto_close", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? NuixIndexAuto_close { get; set; }

        /// <summary>List of hosts (host:port) to communicate with the cluster. This is a round-robin, load-balanced list. Other nodes may be discovered in the cluster. If this and 'discovery.zen.ping.unicast.hosts' are not provided it defaults to localhost.</summary>
        [Newtonsoft.Json.JsonProperty("nuix.transport.hosts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> NuixTransportHosts { get; set; }

        /// <summary>The path to the SSL keystore for this client's identity in JKS format. It contains client's key and certificate signed by the cluster's trusted CA allowing the cluster to trust Nuix.</summary>
        [Newtonsoft.Json.JsonProperty("searchguard.ssl.transport.keystore_filepath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SearchguardSslTransportKeystore_filepath { get; set; }

        /// <summary>The password to the keystore.</summary>
        [Newtonsoft.Json.JsonProperty("searchguard.ssl.transport.keystore_password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SearchguardSslTransportKeystore_password { get; set; }

        /// <summary>The path to the SSL truststore for the client's trusted CAs in JKS format. It contains the CA certificate that signed the cluster's certificates allowing Nuix to trust the cluster.</summary>
        [Newtonsoft.Json.JsonProperty("searchguard.ssl.transport.truststore_filepath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SearchguardSslTransportTruststore_filepath { get; set; }

        /// <summary>The password to the truststore.</summary>
        [Newtonsoft.Json.JsonProperty("searchguard.ssl.transport.truststore_password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SearchguardSslTransportTruststore_password { get; set; }

        /// <summary>The X-Pack password for the user.</summary>
        [Newtonsoft.Json.JsonProperty("xpack.security.password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string XpackSecurityPassword { get; set; }

        /// <summary>Set this to true to enable SSL connections to nodes running X-pack.</summary>
        [Newtonsoft.Json.JsonProperty("xpack.security.transport.ssl.enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? XpackSecurityTransportSslEnabled { get; set; }

        /// <summary>The X-pack user name for transport level credentials. Note the password is not included here as Elastic documentation recommends. Instead it is securely stored in a separate field xpack.security.password.</summary>
        [Newtonsoft.Json.JsonProperty("xpack.security.user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string XpackSecurityUser { get; set; }

        /// <summary>The path to the SSL certificate file for this client's identity in PEM format. It must be signed by the cluster's trusted CA to allow the cluster to trust Nuix.</summary>
        [Newtonsoft.Json.JsonProperty("xpack.ssl.certificate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string XpackSslCertificate { get; set; }

        /// <summary>The path to the SSL CA file for this client's trusted CAs in PEM format. This CA will have signed the cluster's certificates and allows Nuix to trust the cluster.</summary>
        [Newtonsoft.Json.JsonProperty("xpack.ssl.certificate_authorities", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string XpackSslCertificate_authorities { get; set; }

        /// <summary>The path to the SSL key file for this client's identity in PEM format. It must be signed by the cluster's trusted CA to allow the cluster to trust Nuix.</summary>
        [Newtonsoft.Json.JsonProperty("xpack.ssl.key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string XpackSslKey { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TagRequest
    {
        /// <summary>The query to use to find matching items to tag.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }

        /// <summary>The name of the tag to apply or create.</summary>
        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Tag { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SingleContainerIngestionRequestOfIngestibleS3Bucket
    {
        /// <summary>Deprecated in favor of processingProfile. Configuration profile to use as base set of processor, parallel processing, and mime type settings.  Values present in processorSettings, parallelProcessingSettings, and mimeTypeProcessorSettings will override anything defined by this profile.</summary>
        [Newtonsoft.Json.JsonProperty("configurationProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationProfile { get; set; }

        /// <summary>The evidence container to create for this ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("container", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EvidenceContainer Container { get; set; }

        /// <summary>Sets the settings used to apply a keystore file to the ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("keystoreKeyParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyStoreKeyParameters> KeystoreKeyParameters { get; set; }

        /// <summary>Sets the processing settings for individual mime types.</summary>
        [Newtonsoft.Json.JsonProperty("mimeTypeProcessorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MimeTypeProcessingSetting> MimeTypeProcessorSettings { get; set; }

        /// <summary>Sets the parallel processing settings to use for processing.</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>The name of the Processing Profile to use. If you use this setting then do not use any other settings from processorSettings as everything will be overridden by the loaded Processing profile.</summary>
        [Newtonsoft.Json.JsonProperty("processingProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessingProfile { get; set; }

        /// <summary>Sets the processing settings to use.</summary>
        [Newtonsoft.Json.JsonProperty("processorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProcessorSettings ProcessorSettings { get; set; }

        /// <summary>If true, the case's Evidence Repositories will be rescanned to discover new Evidence Containers within them and new files within existing Evidence Containers which are themselves within the cases's Evidence Repositories. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("rescanEvidenceRepositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RescanEvidenceRepositories { get; set; }

        /// <summary>The ingestible target to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IngestibleS3Bucket Target { get; set; } = new IngestibleS3Bucket();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ExportOptions
    {
        /// <summary>= { &lt;span class="propName propOpt"&gt;imageExcelSpreadsheets&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Defaults to false,&lt;br/&gt;&lt;span class="propName propOpt"&gt;slipSheetContainers&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Defaults to false,&lt;br/&gt;&lt;span class="propName propOpt"&gt;excelExportEngine&lt;/span&gt;(&lt;span class="propType"&gt;array[string]&lt;/span&gt;, optional)=['MS_OFFICE' or 'INTERNAL']: Defaults to INTERNAL,&lt;br/&gt;&lt;span class="propName propOpt"&gt;excelPrintHiddenRows&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Defaults to null,&lt;br/&gt;&lt;span class="propName propOpt"&gt;excelPrintHiddenColumns&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Defaults to null,&lt;br/&gt;&lt;span class="propName propOpt"&gt;excelPrintHiddenWorksheets&lt;/span&gt;(&lt;span class="propType"&gt;array[string]&lt;/span&gt;, optional)=['SHEET_HIDDEN' or 'SHEET_VERY_HIDDEN']:Defaults to SHEET_VERY_HIDDEN,&lt;br/&gt;&lt;span class="propName propOpt"&gt;excelPrintHiddenWorksheets&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Defaults to null,&lt;br/&gt;&lt;span class="propName propOpt"&gt;excelPrintComments&lt;/span&gt;(&lt;span class="propType"&gt;array[string]&lt;/span&gt;, optional)=['PRINT_IN_PLACE' or 'PRINT_NO_COMMENTS' or 'PRINT_SHEETEND']:Defaults to null,&lt;br/&gt;&lt;span class="propName propOpt"&gt;excelPaperSize&lt;/span&gt;(&lt;span class="propType"&gt;array[string]&lt;/span&gt;, optional)=['PAPER_10x14' or 'PAPER_11x17' or 'PAPER_A3' or 'PAPER_A4' or 'PAPER_A4Small' or 'PAPER_A5' or 'PAPER_B4' or 'PAPER_B5' or 'PAPER_Csheet' or 'PAPER_Dsheet' or 'PAPER_Envelope10' or 'PAPER_Envelope11' or 'PAPER_Envelope12' or 'PAPER_Envelope14' or 'PAPER_Envelope9' or 'PAPER_EnvelopeB4' or 'PAPER_EnvelopeB5' or 'PAPER_EnvelopeB6' or 'PAPER_EnvelopeC3' or 'PAPER_EnvelopeC4' or 'PAPER_EnvelopeC5' or 'PAPER_EnvelopeC6' or 'PAPER_EnvelopeC65' or 'PAPER_EnvelopeDL' or 'PAPER_EnvelopeItaly' or 'PAPER_EnvelopeMonarch' or 'PAPER_EnvelopePersonal' or 'PAPER_Esheet' or 'PAPER_Executive' or 'PAPER_FanfoldLegalGerman' or 'PAPER_FanfoldStdGerman' or 'PAPER_FanfoldUS' or 'PAPER_Folio' or 'PAPER_Ledger' or 'PAPER_Legal' or 'PAPER_Letter' or 'PAPER_LetterSmall' or 'PAPER_Note' or 'PAPER_Quarto' or 'PAPER_Statement' or 'PAPER_Tabloid']:Defaults to null,&lt;br/&gt;&lt;span class="propName propOpt"&gt;excelPageOrientation&lt;/span&gt;(&lt;span class="propType"&gt;array[string]&lt;/span&gt;, optional)=['PORTRAIT' or 'LANDSCAPE']: Defaults to null,&lt;br/&gt;&lt;span class="propName propOpt"&gt;excelPageZoom&lt;/span&gt;(&lt;span class="propType"&gt;array[string]&lt;/span&gt;, optional)=['PERCENT_10' or 'PERCENT_25' or 'PERCENT_50' or 'PERCENT_75' or 'PERCENT_100' or 'PERCENT_125' or 'PERCENT_150' or 'PERCENT_200' or 'PERCENT_400']:Defaults to null ,&lt;br/&gt;&lt;span class="propName propOpt"&gt;excelFitToPagesTall&lt;/span&gt;(&lt;span class="propType"&gt;integer&lt;/span&gt;, optional): Defaults to null,&lt;br/&gt;&lt;span class="propName propOpt"&gt;excelFitToPagesWide&lt;/span&gt;(&lt;span class="propType"&gt;integer&lt;/span&gt;, optional): Defaults to null,&lt;br/&gt;&lt;span class="propName propOpt"&gt;excelWorksheetPrintArea&lt;/span&gt;(&lt;span class="propType"&gt;array[string]&lt;/span&gt;, optional): Empty string for entire worksheet or standard excel range string,&lt;br/&gt;&lt;span class="propName propOpt"&gt;excelPageNumberLimit&lt;/span&gt;(&lt;span class="propType"&gt;integer&lt;/span&gt;, optional): Defaults to null,&lt;br/&gt;&lt;span class="propName propOpt"&gt;excelPrintGridlines&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Defaults to true,&lt;br/&gt;&lt;span class="propName propOpt"&gt;excelPrintHeadings&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Defaults to true,&lt;br/&gt;&lt;span class="propName propOpt"&gt;wordExportEngine&lt;/span&gt;(&lt;span class="propType"&gt;array[string]&lt;/span&gt;, optional)=['MS_OFFICE' or 'INTERNAL']: Defaults to INTERNAL,&lt;br/&gt;&lt;span class="propName propOpt"&gt;wordShowMarkup&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Defaults to null,&lt;br/&gt;&lt;span class="propName propOpt"&gt;wordShowHiddenText&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Defaults to null,&lt;br/&gt;&lt;span class="propName propOpt"&gt;powerpointExportEngine&lt;/span&gt;(&lt;span class="propType"&gt;array[string]&lt;/span&gt;, optional)=['MS_OFFICE' or 'INTERNAL']: Defaults to INTERNAL,&lt;br/&gt;&lt;span class="propName propOpt"&gt;powerpointPrintOutputType&lt;/span&gt;(&lt;span class="propType"&gt;array[string]&lt;/span&gt;, optional)=['PRINT_OUTPUT_BUILD_SLIDES' or 'PRINT_OUTPUT_FOUR_SLIDE_HANDOUTS' or 'PRINT_OUTPUT_NINE_SLIDE_HANDOUTS' or 'PRINT_OUTPUT_NOTES_PAGES' or 'PRINT_OUTPUT_ONE_SLIDE_HANDOUTS' or 'PRINT_OUTPUT_OUTLINE' or 'PRINT_OUTPUT_SIX_SLIDE_HANDOUTS' or 'PRINT_OUTPUT_SLIDES' or 'PRINT_OUTPUT_THREE_SLIDE_HANDOUTS' or 'PRINT_OUTPUT_TWO_SLIDE_HANDOUTS']:Defaults to PRINT_OUTPUT_SLIDES,&lt;br/&gt;&lt;span class="propName propOpt"&gt;slipSheetMetadataProfile&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): Defaults to null&lt;br/&gt; }</summary>
        [Newtonsoft.Json.JsonProperty("imagingOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object ImagingOptions { get; set; }

        /// <summary>= { &lt;span class="propName propOpt"&gt;metadataProfile&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): Any metadata profile name,&lt;br/&gt;&lt;span class="propName propOpt"&gt;encoding&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): Defaults to UTF-8,&lt;br/&gt;&lt;span class="propName propOpt"&gt;lineSeparator&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): Defaults to System.lineSeparator(),&lt;br/&gt;&lt;span class="propName propOpt"&gt;pathSeparator&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): Defaults to File.separator,&lt;br/&gt;&lt;span class="propName propOpt"&gt;loadFileEntryLimit&lt;/span&gt;(&lt;span class="propType"&gt;integer&lt;/span&gt;, optional): The maximum number of items in a load file before items are rolled over into a new one,&lt;br/&gt;&lt;span class="propName propOpt"&gt;loadFileByteLimit&lt;/span&gt;(&lt;span class="propType"&gt;integer&lt;/span&gt;, optional): The maximum size of the load file as a long, in bytes before items are rolled over into a new one,&lt;br/&gt;&lt;span class="propName propOpt"&gt;version&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): version,&lt;br/&gt;&lt;span class="propName propOpt"&gt;inheritDates&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Ringtail.  Defaults to false,&lt;br/&gt;&lt;span class="propName propOpt"&gt;removeCommas&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Ringtail.  Defaults to false,&lt;br/&gt;&lt;span class="propName propOpt"&gt;directParent&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Ringtail.  Defaults to false,&lt;br/&gt;&lt;span class="propName propOpt"&gt;useDocumentId&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Ringtail.  Defaults to false,&lt;br/&gt;&lt;span class="propName propOpt"&gt;useNativePageCount&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Ringtail.  Defaults to false,&lt;br/&gt;&lt;span class="propName propOpt"&gt;mappingLocation&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): Ringtail,&lt;br/&gt;&lt;span class="propName propOpt"&gt;userName&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): Relativity username,&lt;br/&gt;&lt;span class="propName propOpt"&gt;password&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): Relativity password,&lt;br/&gt;&lt;span class="propName propOpt"&gt;workspaceId&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): Relativity workspaceId,&lt;br/&gt;&lt;span class="propName propOpt"&gt;folderId&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): Relativity folder ID,&lt;br/&gt;&lt;span class="propName propOpt"&gt;accessibleDirectory&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): The absolute path to a directory that is accessible by Relativity,&lt;br/&gt;&lt;span class="propName propOpt"&gt;kweLocation&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): The location of the KWE file,&lt;br/&gt;&lt;span class="propName propOpt"&gt;nrmMappingLocation&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): The location of the Nuix Relativity Mapping (NRM) file,&lt;br/&gt;&lt;span class="propName propOpt"&gt;nrmSettingsLocation&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): The location of the Nuix settings file,&lt;br/&gt;&lt;span class="propName propOpt"&gt;url&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): The Relativity URL,&lt;br/&gt;&lt;span class="propName propOpt"&gt;certValue&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): The Relativity certValue,&lt;br/&gt;&lt;span class="propName propOpt"&gt;endpointType&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): The Relativity Endpoint Type,&lt;br/&gt; }</summary>
        [Newtonsoft.Json.JsonProperty("loadFileOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object LoadFileOptions { get; set; }

        /// <summary>= { &lt;span class="propName propOpt"&gt;createProductionSet&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Defaults to true,&lt;br/&gt;&lt;span class="propName propOpt"&gt;delimiter&lt;/span&gt;(&lt;span class="propType"&gt;array[string]&lt;/span&gt;, optional): Defaults to "."&lt;br/&gt;&lt;span class="propName propOpt"&gt;groupDocumentPages&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Defaults to true,&lt;br/&gt;&lt;span class="propName propOpt"&gt;groupFamilyItems&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Defaults to false,&lt;br/&gt;&lt;span class="propName propOpt"&gt;prefix&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): Any string.  Defaults to null }</summary>
        [Newtonsoft.Json.JsonProperty("numberingOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object NumberingOptions { get; set; }

        /// <summary>= { &lt;span class="propName propOpt"&gt;naming&lt;/span&gt;(&lt;span class="propType"&gt;array[string]&lt;/span&gt;, optional)=['document_id' or 'document_id_with_page' or 'page_only' or 'full' or 'full_with_periods' or 'item_name' or 'item_name_with_path' or 'guid' or 'md5']: Selects the type of naming to apply to the produced files: Defaults to item_name_with_path,&lt;br/&gt;&lt;span class="propName propOpt"&gt;path&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): Specifies the path to place the produced files,&lt;br/&gt;&lt;span class="propName propOpt"&gt;suffix&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): Specifies the file name suffixDefaults to none,&lt;br/&gt;&lt;span class="propName propOpt"&gt;mailFormat&lt;/span&gt;(&lt;span class="propType"&gt;array[string]&lt;/span&gt;)=['native' or 'eml' or 'html' or 'mime_html' or 'msg''dxl' or 'mbox' or 'pst' or 'nsf']: Selects the format for native exports of emails.  Defaults to native,&lt;br/&gt;&lt;span class="propName propOpt"&gt;includeAttachments&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Defaults to true,&lt;br/&gt;&lt;span class="propName propOpt"&gt;regenerateStored&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Defaults to false,&lt;br/&gt;&lt;span class="propName propOpt"&gt;wrapLines&lt;/span&gt;(&lt;span class="propType"&gt;integer&lt;/span&gt;, optional): Specifies the column to wrap text files at,&lt;br/&gt;&lt;span class="propName propOpt"&gt;perPage&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): If false, the entire text for an item will be put in a single fileDefaults to false,&lt;br/&gt;&lt;span class="propName propOpt"&gt;lineSeparator&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;): Defaults to System.lineSeparator(),&lt;br/&gt;&lt;span class="propName propOpt"&gt;encoding&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;): Defaults to UTF-8,&lt;br/&gt;&lt;span class="propName propOpt"&gt;multiPageTiff&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Defaults to false,&lt;br/&gt;&lt;span class="propName propOpt"&gt;tiffDpi&lt;/span&gt;(&lt;span class="propType"&gt;integer&lt;/span&gt;, optional): tiffDpi,&lt;br/&gt;&lt;span class="propName propOpt"&gt;tiffFormat&lt;/span&gt;(&lt;span class="propType"&gt;array[string], optional&lt;/span&gt;)=['MONOCHROME_CCITT_T6_G4' or 'GREYSCALE_UNCOMPRESSED' or 'GREYSCALE_DEFLATE' or 'GREYSCALE_LZW' or 'COLOUR_UNCOMPRESSED' or 'COLOUR_DEFLATE' or 'COLOUR_LZW']: Defaults to MONOCHROME_CCITT_T6_G4&lt;br/&gt; }</summary>
        [Newtonsoft.Json.JsonProperty("productOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object ProductOptions { get; set; }

        /// <summary>= { &lt;span class="propName propOpt"&gt;headerLine&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Defaults to false,&lt;br/&gt;&lt;span class="propName propOpt"&gt;footerLine&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Defaults to false,&lt;br/&gt;&lt;span class="propName propOpt"&gt;increasePageSize&lt;/span&gt;(&lt;span class="propType"&gt;boolean&lt;/span&gt;, optional): Defaults to false,&lt;br/&gt;&lt;span class="propName propOpt"&gt;type&lt;/span&gt;(&lt;span class="propType"&gt;array[string]&lt;/span&gt;)=['name' or 'guid' or 'document_number' or 'first_document_number' or 'page_number' or 'page_count' or 'item_id' or 'produced_by' or 'md5' or 'sha1' or 'sha256' or 'document_id' or 'production_set_name' or 'custom']&lt;br/&gt;&lt;span class="propName propOpt"&gt;customText&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): Specifies the custom text to put in the header when type is custom&lt;br/&gt;&lt;span class="propName propOpt"&gt;metadataItem&lt;/span&gt;(&lt;span class="propType"&gt;string&lt;/span&gt;, optional): Specifies the metadata column to put in the header when type is metadata&lt;br/&gt; }</summary>
        [Newtonsoft.Json.JsonProperty("stampingOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object StampingOptions { get; set; }

        /// <summary>= { &lt;span class="propName propOpt"&gt;strategy&lt;/span&gt;(&lt;span class="propType"&gt;array[string]&lt;/span&gt;, optional)=['items' or 'items_and_descendants' or 'top_level_items' or 'top_level_items_and_descendants' or 'deduplicated_top_level_items' or 'deduplicated_top_level_items_and_descendants']: Defaults to items&lt;br/&gt;&lt;span class="propName propOpt"&gt;deduplication&lt;/span&gt;(&lt;span class="propType"&gt;array[string]&lt;/span&gt;, optional)=['none' or 'md5' or 'md5_per_custodian']: Defaults to none&lt;br/&gt;&lt;span class="propName propOpt"&gt;sortOrder&lt;/span&gt;(&lt;span class="propType"&gt;array[string]&lt;/span&gt;, optional)=['none' or 'position' or 'top_level_item_date' or 'top_level_item_date_descending' or 'document_id']: Defaults to none if strategy is items otherwise positionDefaults to none&lt;br/&gt; }</summary>
        [Newtonsoft.Json.JsonProperty("traversalOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object TraversalOptions { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ClusterRunResponse
    {
        /// <summary>cluster run name</summary>
        [Newtonsoft.Json.JsonProperty("clusterName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterName { get; set; }

        /// <summary>array of cluster IDs</summary>
        [Newtonsoft.Json.JsonProperty("clusters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Clusters { get; set; }

        /// <summary>Gets the resemblance threshold associated with the cluster run, irrespective of what clustering options are set.</summary>
        [Newtonsoft.Json.JsonProperty("resemblanceThreshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? ResemblanceThreshold { get; set; }

        /// <summary>Gets whether or not chained near-duplicates were used during clustering.</summary>
        [Newtonsoft.Json.JsonProperty("useChainedNearDuplicatesEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UseChainedNearDuplicatesEnabled { get; set; }

        /// <summary>Gets whether or not email threads were used during clustering.</summary>
        [Newtonsoft.Json.JsonProperty("useEmailThreadsEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UseEmailThreadsEnabled { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class BulkItemCustomMetadataDeleteRequest
    {
        /// <summary>Result of the query can optionally be deduplicated. Options are 'md5' and 'per custodian'.</summary>
        [Newtonsoft.Json.JsonProperty("deduplicate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Deduplicate { get; set; }

        /// <summary>The name of the custom metadata field</summary>
        [Newtonsoft.Json.JsonProperty("fieldName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FieldName { get; set; }

        /// <summary>Query items that should be included. If a query is not supplied it defaults to an empty string, which returns all items.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }

        /// <summary>Result of the deduplicated query can be applied to related items of the items.  Options are 'topTypes', 'family', and 'descendants'</summary>
        [Newtonsoft.Json.JsonProperty("relationType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RelationType { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ExportRequest
    {
        /// <summary>The map of export options</summary>
        [Newtonsoft.Json.JsonProperty("exportOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ExportOptions ExportOptions { get; set; }

        /// <summary>Defaults to ITEM</summary>
        [Newtonsoft.Json.JsonProperty("exportType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ExportRequestExportType? ExportType { get; set; }

        /// <summary>The folder ID.  A folder with this ID will be created under the export path</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>The load file types to add to the export.  By default, no load file types are selected</summary>
        [Newtonsoft.Json.JsonProperty("loadFileTypes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<LoadFileTypes> LoadFileTypes { get; set; }

        /// <summary>parallelProcessingSettings</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>Root export path folder</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

        /// <summary>Defaults to NATIVE</summary>
        [Newtonsoft.Json.JsonProperty("productTypes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<ProductTypes> ProductTypes { get; set; }

        /// <summary>The production set GUIDs to export</summary>
        [Newtonsoft.Json.JsonProperty("productionSets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ProductionSets { get; set; }

        /// <summary>The list of queries to export.  Only applicable for ITEM exports</summary>
        [Newtonsoft.Json.JsonProperty("queries", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Queries { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class WordCountsResponse
    {
        /// <summary>The frequency of the word / term</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Count { get; set; }

        /// <summary>The word / term</summary>
        [Newtonsoft.Json.JsonProperty("word", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Word { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CaseFunctionQueue
    {
        /// <summary>Case identification token</summary>
        [Newtonsoft.Json.JsonProperty("caseId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CaseId { get; set; }

        /// <summary>List of AsyncFunctionStatus objects for Async functions which are queued to execute.</summary>
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AsyncFunctionStatus> Queue { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class GenericResponse
    {
        /// <summary>success</summary>
        [Newtonsoft.Json.JsonProperty("success", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Success { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ItemSetNameChangeRequest
    {
        /// <summary>New name for the Item Set</summary>
        [Newtonsoft.Json.JsonProperty("newName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string NewName { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class WordcountRequest
    {
        /// <summary>Specifies the deduplication to apply over the query. Defaults to none.</summary>
        [Newtonsoft.Json.JsonProperty("deduplication", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public WordcountRequestDeduplication? Deduplication { get; set; }

        /// <summary>Specifies the filed to search over the query. Defaults to all.</summary>
        [Newtonsoft.Json.JsonProperty("field", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public WordcountRequestField? Field { get; set; }

        /// <summary>Limits returned word counts to the types specified.</summary>
        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public WordcountRequestFilter? Filter { get; set; }

        /// <summary>Returns only results occurring at most this number of times. Specifying minOccurs &gt; maxOccurs causes an exception.</summary>
        [Newtonsoft.Json.JsonProperty("maxOccurs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxOccurs { get; set; }

        /// <summary>Limits the size of the returned list of word counts.</summary>
        [Newtonsoft.Json.JsonProperty("maxResults", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxResults { get; set; }

        /// <summary>Limits results to words whose length is less than or equal to this value.</summary>
        [Newtonsoft.Json.JsonProperty("maxWordLength", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxWordLength { get; set; }

        /// <summary>Returns only results occurring at least this number of times.</summary>
        [Newtonsoft.Json.JsonProperty("minOccurs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MinOccurs { get; set; }

        /// <summary>Limits results to words whose length is greater than or equal to this value.</summary>
        [Newtonsoft.Json.JsonProperty("minWordLength", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MinWordLength { get; set; }

        /// <summary>Query items that should be included. If a query is not supplied it defaults to an empty string, which returns all items.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }

        /// <summary>Sorts the result from most frequent to least frequent. Defaults to off.</summary>
        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public WordcountRequestSort? Sort { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class FamilyStatisticsResponse
    {
        /// <summary>The total number of family items which are audited (excludes immaterial items)</summary>
        [Newtonsoft.Json.JsonProperty("auditItemCount", Required = Newtonsoft.Json.Required.Always)]
        public long AuditItemCount { get; set; }

        /// <summary>The total audit size of all family items</summary>
        [Newtonsoft.Json.JsonProperty("auditSize", Required = Newtonsoft.Json.Required.Always)]
        public long AuditSize { get; set; }

        /// <summary>The total number of family items</summary>
        [Newtonsoft.Json.JsonProperty("itemCount", Required = Newtonsoft.Json.Required.Always)]
        public long ItemCount { get; set; }

        /// <summary>The specified query</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CountResponse
    {
        /// <summary>caseGuid</summary>
        [Newtonsoft.Json.JsonProperty("caseGuid", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CaseGuid { get; set; }

        /// <summary>casePath</summary>
        [Newtonsoft.Json.JsonProperty("casePath", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CasePath { get; set; }

        /// <summary>count</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Always)]
        public long Count { get; set; }

        /// <summary>query</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CaseModification
    {
        [Newtonsoft.Json.JsonProperty("method", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CaseModificationMethod? Method { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SingleRepositoryIngestionRequest
    {
        /// <summary>Deprecated in favor of processingProfile. Configuration profile to use as base set of processor, parallel processing, and mime type settings.  Values present in processorSettings, parallelProcessingSettings, and mimeTypeProcessorSettings will override anything defined by this profile.</summary>
        [Newtonsoft.Json.JsonProperty("configurationProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationProfile { get; set; }

        /// <summary>Sets the settings used to apply a keystore file to the ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("keystoreKeyParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyStoreKeyParameters> KeystoreKeyParameters { get; set; }

        /// <summary>Sets the processing settings for individual mime types.</summary>
        [Newtonsoft.Json.JsonProperty("mimeTypeProcessorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MimeTypeProcessingSetting> MimeTypeProcessorSettings { get; set; }

        /// <summary>Sets the parallel processing settings to use for processing.</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>The name of the Processing Profile to use. If you use this setting then do not use any other settings from processorSettings as everything will be overridden by the loaded Processing profile.</summary>
        [Newtonsoft.Json.JsonProperty("processingProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessingProfile { get; set; }

        /// <summary>Sets the processing settings to use.</summary>
        [Newtonsoft.Json.JsonProperty("processorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProcessorSettings ProcessorSettings { get; set; }

        /// <summary>The evidence repository to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("repository", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public EvidenceRepository Repository { get; set; } = new EvidenceRepository();

        /// <summary>If true, the case's Evidence Repositories will be rescanned to discover new Evidence Containers within them and new files within existing Evidence Containers which are themselves within the cases's Evidence Repositories. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("rescanEvidenceRepositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RescanEvidenceRepositories { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class QueryValidationResponse
    {
        /// <summary>exception</summary>
        [Newtonsoft.Json.JsonProperty("exception", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Exception { get; set; }

        /// <summary>query</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }

        /// <summary>valid</summary>
        [Newtonsoft.Json.JsonProperty("valid", Required = Newtonsoft.Json.Required.Always)]
        public bool Valid { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class LanguageResponse
    {
        /// <summary>code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Code { get; set; }

        [Newtonsoft.Json.JsonProperty("itemCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ItemCount { get; set; }

        /// <summary>languageName</summary>
        [Newtonsoft.Json.JsonProperty("languageName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string LanguageName { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AuditStatus
    {
        /// <summary>The filename of the unverified audit report if it exists.</summary>
        [Newtonsoft.Json.JsonProperty("auditReportFilename", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AuditReportFilename { get; set; }

        /// <summary>The creation date of the unverified audit report if it exists.</summary>
        [Newtonsoft.Json.JsonProperty("creationDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? CreationDate { get; set; }

        /// <summary>Flag indicates whether an unverified audit report exists for the case.</summary>
        [Newtonsoft.Json.JsonProperty("unverifiedAuditReport", Required = Newtonsoft.Json.Required.Always)]
        public bool UnverifiedAuditReport { get; set; }

        /// <summary>The list of verified audit reports if it exists.</summary>
        [Newtonsoft.Json.JsonProperty("verifiedAuditReports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> VerifiedAuditReports { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ClusterRunRequest
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }

        [Newtonsoft.Json.JsonProperty("resemblanceThreshold", Required = Newtonsoft.Json.Required.Always)]
        public double ResemblanceThreshold { get; set; }

        [Newtonsoft.Json.JsonProperty("useChainedNearDuplicates", Required = Newtonsoft.Json.Required.Always)]
        public bool UseChainedNearDuplicates { get; set; }

        [Newtonsoft.Json.JsonProperty("useEmailThreads", Required = Newtonsoft.Json.Required.Always)]
        public bool UseEmailThreads { get; set; }

        [Newtonsoft.Json.JsonProperty("saveIfEmpty", Required = Newtonsoft.Json.Required.Always)]
        public bool SaveIfEmpty { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class DeduplicationQueryListRequest
    {
        /// <summary>The deduplication to apply over each query. Defaults to 'none'</summary>
        [Newtonsoft.Json.JsonProperty("deduplication", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DeduplicationQueryListRequestDeduplication? Deduplication { get; set; }

        /// <summary>The set of queries which will be executed.</summary>
        [Newtonsoft.Json.JsonProperty("queryList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> QueryList { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ItemTextResponse
    {
        /// <summary>binaryAvailable</summary>
        [Newtonsoft.Json.JsonProperty("binaryAvailable", Required = Newtonsoft.Json.Required.Always)]
        public bool BinaryAvailable { get; set; }

        /// <summary>blank</summary>
        [Newtonsoft.Json.JsonProperty("blank", Required = Newtonsoft.Json.Required.Always)]
        public bool Blank { get; set; }

        /// <summary>htlmEscape</summary>
        [Newtonsoft.Json.JsonProperty("htmlEscape", Required = Newtonsoft.Json.Required.Always)]
        public bool HtmlEscape { get; set; }

        /// <summary>text</summary>
        [Newtonsoft.Json.JsonProperty("text", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Text { get; set; }

        [Newtonsoft.Json.JsonProperty("totalTextLength", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? TotalTextLength { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SingleContainerIngestionRequestOfIngestibleSQLServer
    {
        /// <summary>Deprecated in favor of processingProfile. Configuration profile to use as base set of processor, parallel processing, and mime type settings.  Values present in processorSettings, parallelProcessingSettings, and mimeTypeProcessorSettings will override anything defined by this profile.</summary>
        [Newtonsoft.Json.JsonProperty("configurationProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationProfile { get; set; }

        /// <summary>The evidence container to create for this ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("container", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EvidenceContainer Container { get; set; }

        /// <summary>Sets the settings used to apply a keystore file to the ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("keystoreKeyParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyStoreKeyParameters> KeystoreKeyParameters { get; set; }

        /// <summary>Sets the processing settings for individual mime types.</summary>
        [Newtonsoft.Json.JsonProperty("mimeTypeProcessorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MimeTypeProcessingSetting> MimeTypeProcessorSettings { get; set; }

        /// <summary>Sets the parallel processing settings to use for processing.</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>The name of the Processing Profile to use. If you use this setting then do not use any other settings from processorSettings as everything will be overridden by the loaded Processing profile.</summary>
        [Newtonsoft.Json.JsonProperty("processingProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessingProfile { get; set; }

        /// <summary>Sets the processing settings to use.</summary>
        [Newtonsoft.Json.JsonProperty("processorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProcessorSettings ProcessorSettings { get; set; }

        /// <summary>If true, the case's Evidence Repositories will be rescanned to discover new Evidence Containers within them and new files within existing Evidence Containers which are themselves within the cases's Evidence Repositories. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("rescanEvidenceRepositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RescanEvidenceRepositories { get; set; }

        /// <summary>The ingestible target to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IngestibleSQLServer Target { get; set; } = new IngestibleSQLServer();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class NuixItemKindResponse
    {
        /// <summary>localisedName</summary>
        [Newtonsoft.Json.JsonProperty("localisedName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string LocalisedName { get; set; }

        /// <summary>name</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ItemSetBatchResponse
    {
        [Newtonsoft.Json.JsonProperty("batchName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BatchName { get; set; }

        [Newtonsoft.Json.JsonProperty("createdOn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? CreatedOn { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class File
    {
        [Newtonsoft.Json.JsonProperty("absolute", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Absolute { get; set; }

        [Newtonsoft.Json.JsonProperty("absoluteFile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] AbsoluteFile { get; set; }

        [Newtonsoft.Json.JsonProperty("absolutePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AbsolutePath { get; set; }

        [Newtonsoft.Json.JsonProperty("canonicalFile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] CanonicalFile { get; set; }

        [Newtonsoft.Json.JsonProperty("canonicalPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CanonicalPath { get; set; }

        [Newtonsoft.Json.JsonProperty("directory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Directory { get; set; }

        [Newtonsoft.Json.JsonProperty("file", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? File1 { get; set; }

        [Newtonsoft.Json.JsonProperty("freeSpace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? FreeSpace { get; set; }

        [Newtonsoft.Json.JsonProperty("hidden", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Hidden { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("parent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Parent { get; set; }

        [Newtonsoft.Json.JsonProperty("parentFile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] ParentFile { get; set; }

        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

        [Newtonsoft.Json.JsonProperty("totalSpace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? TotalSpace { get; set; }

        [Newtonsoft.Json.JsonProperty("usableSpace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? UsableSpace { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApplyCustomMetadataResponse
    {
        /// <summary>List of item GUIDs that failed the operation</summary>
        [Newtonsoft.Json.JsonProperty("failedItems", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> FailedItems { get; set; } = new System.Collections.ObjectModel.Collection<string>();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ReloadItemsIngestionRequest
    {
        /// <summary>Deprecated in favor of processingProfile. Configuration profile to use as base set of processor, parallel processing, and mime type settings.  Values present in processorSettings, parallelProcessingSettings, and mimeTypeProcessorSettings will override anything defined by this profile.</summary>
        [Newtonsoft.Json.JsonProperty("configurationProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationProfile { get; set; }

        /// <summary>Sets the settings used to apply a keystore file to the ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("keystoreKeyParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyStoreKeyParameters> KeystoreKeyParameters { get; set; }

        /// <summary>Sets the processing settings for individual mime types.</summary>
        [Newtonsoft.Json.JsonProperty("mimeTypeProcessorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MimeTypeProcessingSetting> MimeTypeProcessorSettings { get; set; }

        /// <summary>Sets the parallel processing settings to use for processing.</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>The name of the Processing Profile to use. If you use this setting then do not use any other settings from processorSettings as everything will be overridden by the loaded Processing profile.</summary>
        [Newtonsoft.Json.JsonProperty("processingProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessingProfile { get; set; }

        /// <summary>Sets the processing settings to use.</summary>
        [Newtonsoft.Json.JsonProperty("processorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProcessorSettings ProcessorSettings { get; set; }

        /// <summary>All items matching the query will be reloaded from source.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }

        /// <summary>If true, the case's Evidence Repositories will be rescanned to discover new Evidence Containers within them and new files within existing Evidence Containers which are themselves within the cases's Evidence Repositories. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("rescanEvidenceRepositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RescanEvidenceRepositories { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class EvidenceContainer
    {
        /// <summary>Sets the name of the initial custodian for the data.</summary>
        [Newtonsoft.Json.JsonProperty("custodian", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Custodian { get; set; }

        /// <summary>Sets a map of custom metadata for the evidence container.</summary>
        [Newtonsoft.Json.JsonProperty("customMetadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> CustomMetadata { get; set; }

        /// <summary>Sets the description for the evidence container.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>Sets the encoding for the evidence container. If the encoding is not set the default system encoding will be used.</summary>
        [Newtonsoft.Json.JsonProperty("encoding", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Encoding { get; set; }

        /// <summary>Sets the locale for the evidence container. Some file types and named entities require a locale for them to be ingested accurately. If not set then the system's default locale will be used. Format is that required by IETF BCP 47 (e.g. 'en-US').</summary>
        [Newtonsoft.Json.JsonProperty("locale", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Locale { get; set; }

        /// <summary>Sets the name for the evidence container that is created during ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>Sets the time zone for the evidence container. If the time zone is not set the system's default time zone will be used.</summary>
        [Newtonsoft.Json.JsonProperty("timeZone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TimeZone { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class FileUploadResponse
    {
        [Newtonsoft.Json.JsonProperty("fileUploads", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FileUpload> FileUploads { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SearchHit
    {
        /// <summary>The number of occurrances for this term</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Always)]
        public int Count { get; set; }

        /// <summary>Search hit term.</summary>
        [Newtonsoft.Json.JsonProperty("term", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Term { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CreateCaseRequest
    {
        /// <summary>Path to file system binary store for this case. It can be shared by cases and should be accessible from all workers. Defaults to null, which means binary store will be within the on-disk portion of the case.</summary>
        [Newtonsoft.Json.JsonProperty("binaryStoreLocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BinaryStoreLocation { get; set; }

        /// <summary>Determines whether the case is simple or compound.  Default is false</summary>
        [Newtonsoft.Json.JsonProperty("compound", Required = Newtonsoft.Json.Required.Always)]
        public bool Compound { get; set; }

        /// <summary>The case description</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>The ElasticSearch settings to use for this case. Not supported if compound is true.</summary>
        [Newtonsoft.Json.JsonProperty("elasticSearchSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ElasticSearchSettings ElasticSearchSettings { get; set; }

        /// <summary>The case investigator</summary>
        [Newtonsoft.Json.JsonProperty("investigator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Investigator { get; set; }

        /// <summary>The name of the case.  e.g. mycase</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>Where the case should be created.  e.g. inventory0, or an absolute directory</summary>
        [Newtonsoft.Json.JsonProperty("location", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Location { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SingleContainerIngestionRequestOfIngestibleMailStore
    {
        /// <summary>Deprecated in favor of processingProfile. Configuration profile to use as base set of processor, parallel processing, and mime type settings.  Values present in processorSettings, parallelProcessingSettings, and mimeTypeProcessorSettings will override anything defined by this profile.</summary>
        [Newtonsoft.Json.JsonProperty("configurationProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationProfile { get; set; }

        /// <summary>The evidence container to create for this ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("container", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EvidenceContainer Container { get; set; }

        /// <summary>Sets the settings used to apply a keystore file to the ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("keystoreKeyParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyStoreKeyParameters> KeystoreKeyParameters { get; set; }

        /// <summary>Sets the processing settings for individual mime types.</summary>
        [Newtonsoft.Json.JsonProperty("mimeTypeProcessorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MimeTypeProcessingSetting> MimeTypeProcessorSettings { get; set; }

        /// <summary>Sets the parallel processing settings to use for processing.</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>The name of the Processing Profile to use. If you use this setting then do not use any other settings from processorSettings as everything will be overridden by the loaded Processing profile.</summary>
        [Newtonsoft.Json.JsonProperty("processingProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessingProfile { get; set; }

        /// <summary>Sets the processing settings to use.</summary>
        [Newtonsoft.Json.JsonProperty("processorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProcessorSettings ProcessorSettings { get; set; }

        /// <summary>If true, the case's Evidence Repositories will be rescanned to discover new Evidence Containers within them and new files within existing Evidence Containers which are themselves within the cases's Evidence Repositories. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("rescanEvidenceRepositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RescanEvidenceRepositories { get; set; }

        /// <summary>The ingestible target to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IngestibleMailStore Target { get; set; } = new IngestibleMailStore();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class WordCountsRequest
    {
        /// <summary>The deduplication to apply over each query. Defaults to 'none'</summary>
        [Newtonsoft.Json.JsonProperty("deduplication", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public WordCountsRequestDeduplication? Deduplication { get; set; }

        /// <summary>Specifies the field to search over each query. Defaults to all.</summary>
        [Newtonsoft.Json.JsonProperty("field", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public WordCountsRequestField? Field { get; set; }

        /// <summary>Limits results to words that match the filter.  Default is 'all'</summary>
        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public WordCountsRequestFilter? Filter { get; set; }

        /// <summary>Returns only results occurring at most this number of times.</summary>
        [Newtonsoft.Json.JsonProperty("maxOccurs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxOccurs { get; set; }

        /// <summary>Limits the size of the returned list of word counts.  Defaults to 200; use -1 for no limit.</summary>
        [Newtonsoft.Json.JsonProperty("maxResults", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxResults { get; set; }

        /// <summary>Limits results to words whose length is less than or equal to this value.</summary>
        [Newtonsoft.Json.JsonProperty("maxWordLength", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxWordLength { get; set; }

        /// <summary>Returns only results occurring at least this number of times.</summary>
        [Newtonsoft.Json.JsonProperty("minOccurs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MinOccurs { get; set; }

        /// <summary>Limits results to words whose length is greater than or equal to this value.</summary>
        [Newtonsoft.Json.JsonProperty("minWordLength", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MinWordLength { get; set; }

        /// <summary>The set of queries which will be executed.</summary>
        [Newtonsoft.Json.JsonProperty("queryList", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> QueryList { get; set; }

        /// <summary>Sorts the results from most frequent to least frequent. Defaults to off.</summary>
        [Newtonsoft.Json.JsonProperty("sort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public WordCountsRequestSort? Sort { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class LicenseDescription
    {
        [Newtonsoft.Json.JsonProperty("auditThreshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? AuditThreshold { get; set; }

        [Newtonsoft.Json.JsonProperty("audited", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Audited { get; set; }

        [Newtonsoft.Json.JsonProperty("canChooseWorkers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CanChooseWorkers { get; set; }

        [Newtonsoft.Json.JsonProperty("concurrentUserLimit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ConcurrentUserLimit { get; set; }

        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Count { get; set; }

        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Features { get; set; }

        [Newtonsoft.Json.JsonProperty("legalHoldCustodianLimit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LegalHoldCustodianLimit { get; set; }

        [Newtonsoft.Json.JsonProperty("legalHoldHoldCountLimit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LegalHoldHoldCountLimit { get; set; }

        [Newtonsoft.Json.JsonProperty("location", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Location { get; set; }

        [Newtonsoft.Json.JsonProperty("shortname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Shortname { get; set; }

        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        [Newtonsoft.Json.JsonProperty("workers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Workers { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class IngestibleFile
    {
        /// <summary>Absolute path to the directory or file to be ingested.</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Path { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class OcrRequestV2
    {
        /// <summary>The name of the Imaging Profile to use. If you use this setting then do not use any settings from ocrImagingOptions as those settings will be overridden by the ones from the profile.</summary>
        [Newtonsoft.Json.JsonProperty("imagingProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImagingProfile { get; set; }

        /// <summary>imagingOptions</summary>
        [Newtonsoft.Json.JsonProperty("ocrImagingOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ImagingOptions OcrImagingOptions { get; set; }

        /// <summary>ocrOptions</summary>
        [Newtonsoft.Json.JsonProperty("ocrOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OcrOptionsV2 OcrOptions { get; set; }

        /// <summary>The name of the OCR Profile to use. If you use this setting then do not use any other settings to perform OCR from ocrOptions as everything will be overridden by the loaded OCR profile.</summary>
        [Newtonsoft.Json.JsonProperty("ocrProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OcrProfile { get; set; }

        /// <summary>paralleProcessingSettings</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>Query items that should be included. If a query is not supplied it defaults to an empty string, which returns everything.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class NuixItemTypeResponse
    {
        /// <summary>count</summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Always)]
        public long Count { get; set; }

        /// <summary>kind</summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Kind { get; set; }

        /// <summary>localisedName</summary>
        [Newtonsoft.Json.JsonProperty("localisedName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string LocalisedName { get; set; }

        /// <summary>name</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>preferredExtension</summary>
        [Newtonsoft.Json.JsonProperty("preferredExtension", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string PreferredExtension { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AsyncFunctionSingleItemQueueReorderRequest
    {
        /// <summary>Sets the order of the single item async function queue.</summary>
        [Newtonsoft.Json.JsonProperty("queuedFunctionKeys", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> QueuedFunctionKeys { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ReviewJobAddItemsRequest
    {
        /// <summary>Options specifying how to add the items and the user to assign the items.</summary>
        [Newtonsoft.Json.JsonProperty("options", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ReviewJobAddItemsOptions Options { get; set; }

        /// <summary>Query items that should be added to the review job.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CaseSubsetMetadata
    {
        /// <summary>The case description</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>The case investigator</summary>
        [Newtonsoft.Json.JsonProperty("investigator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Investigator { get; set; }

        /// <summary>The name of the case.  If not supplied the current time in milliseconds will be used.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SingleContainerIngestionRequestOfIngestibleExchangeMailbox
    {
        /// <summary>Deprecated in favor of processingProfile. Configuration profile to use as base set of processor, parallel processing, and mime type settings.  Values present in processorSettings, parallelProcessingSettings, and mimeTypeProcessorSettings will override anything defined by this profile.</summary>
        [Newtonsoft.Json.JsonProperty("configurationProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationProfile { get; set; }

        /// <summary>The evidence container to create for this ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("container", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EvidenceContainer Container { get; set; }

        /// <summary>Sets the settings used to apply a keystore file to the ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("keystoreKeyParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyStoreKeyParameters> KeystoreKeyParameters { get; set; }

        /// <summary>Sets the processing settings for individual mime types.</summary>
        [Newtonsoft.Json.JsonProperty("mimeTypeProcessorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MimeTypeProcessingSetting> MimeTypeProcessorSettings { get; set; }

        /// <summary>Sets the parallel processing settings to use for processing.</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>The name of the Processing Profile to use. If you use this setting then do not use any other settings from processorSettings as everything will be overridden by the loaded Processing profile.</summary>
        [Newtonsoft.Json.JsonProperty("processingProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessingProfile { get; set; }

        /// <summary>Sets the processing settings to use.</summary>
        [Newtonsoft.Json.JsonProperty("processorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProcessorSettings ProcessorSettings { get; set; }

        /// <summary>If true, the case's Evidence Repositories will be rescanned to discover new Evidence Containers within them and new files within existing Evidence Containers which are themselves within the cases's Evidence Repositories. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("rescanEvidenceRepositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RescanEvidenceRepositories { get; set; }

        /// <summary>The ingestible target to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IngestibleExchangeMailbox Target { get; set; } = new IngestibleExchangeMailbox();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApplyTagListRequest
    {
        /// <summary>deduplicate.  Defaults to no deduplication.</summary>
        [Newtonsoft.Json.JsonProperty("deduplicate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApplyTagListRequestDeduplicate? Deduplicate { get; set; }

        /// <summary>An optional query used to select duplicate items.  Will not be used if includeDuplicates is true.  To exclude duplicate items entirely, set includeDuplicates to false and either omit this entry or set its value to null.</summary>
        [Newtonsoft.Json.JsonProperty("duplicatesQuery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DuplicatesQuery { get; set; }

        /// <summary>An optional query used to select family items.  Will not be used if includeFamily is true.  To exclude family items entirely, set includeFamily to false and either omit this entry or set its value to null.</summary>
        [Newtonsoft.Json.JsonProperty("familyQuery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FamilyQuery { get; set; }

        /// <summary>Includes duplicates of items for results of provided query. Defaults to false.</summary>
        [Newtonsoft.Json.JsonProperty("includeDuplicates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeDuplicates { get; set; }

        /// <summary>Includes families of items for results of provided query. Defaults to false.</summary>
        [Newtonsoft.Json.JsonProperty("includeFamily", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeFamily { get; set; }

        /// <summary>Includes near duplicates of items for results of provided query. Defaults to false.</summary>
        [Newtonsoft.Json.JsonProperty("includeNearDuplicates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeNearDuplicates { get; set; }

        /// <summary>An optional query used to select near duplicate items.  Will not be used if includeNearDuplicates is true.  To exclude near duplicate items entirely, set includeNearDuplicates to false and either omit this entry or set its value to null.</summary>
        [Newtonsoft.Json.JsonProperty("nearDuplicatesQuery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NearDuplicatesQuery { get; set; }

        /// <summary>The threshold used to calculate near duplicates.  Defaults to 0.5</summary>
        [Newtonsoft.Json.JsonProperty("nearDuplicatesThreshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? NearDuplicatesThreshold { get; set; }

        /// <summary>Query items that should be included.  If a query is not supplied it defaults to an empty string, which returns all items.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }

        /// <summary>List of tags used during the operation</summary>
        [Newtonsoft.Json.JsonProperty("tagList", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> TagList { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>An optional query used to select thread items.  To exclude thread items entirely, either omit this entry or set its value to null.</summary>
        [Newtonsoft.Json.JsonProperty("threadsQuery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ThreadsQuery { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class TagList
    {
        /// <summary>List of tags used during the operation</summary>
        [Newtonsoft.Json.JsonProperty("tagList", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> TagList1 { get; set; } = new System.Collections.ObjectModel.Collection<string>();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class EvidenceRepository
    {
        /// <summary>If custodian names are present in the repository, this is a positive integer of the number of folder levels nesting inside the repository where custodians are defined. For example custodianLevel = 1 indicates that each folder immediately inside the repository folder is a custodian name, while custodianLevel = 2 indicates that each folder nested two levels inside the repository folder is a custodian name. If the repository does not contain custodian names then this parameter can be either omitted or set to -1.</summary>
        [Newtonsoft.Json.JsonProperty("custodianLevel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? CustodianLevel { get; set; }

        /// <summary>The path of the evidence repository folder. Each folder or file immediately inside this path will become a new evidence container.</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Path { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class FileUpload
    {
        [Newtonsoft.Json.JsonProperty("filePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FilePath { get; set; }

        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Size { get; set; }

        [Newtonsoft.Json.JsonProperty("success", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Success { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class EvidenceContainerWithTargets
    {
        /// <summary>A list of ingestible centera clusters to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("centeraClusters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IngestibleCenteraCluster> CenteraClusters { get; set; }

        /// <summary>Sets the name of the initial custodian for the data.</summary>
        [Newtonsoft.Json.JsonProperty("custodian", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Custodian { get; set; }

        /// <summary>Sets a map of custom metadata for the evidence container.</summary>
        [Newtonsoft.Json.JsonProperty("customMetadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> CustomMetadata { get; set; }

        /// <summary>Sets the description for the evidence container.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>A list of ingestible Dropbox accounts to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("dropboxes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IngestibleDropbox> Dropboxes { get; set; }

        /// <summary>Sets the encoding for the evidence container. If the encoding is not set the default system encoding will be used.</summary>
        [Newtonsoft.Json.JsonProperty("encoding", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Encoding { get; set; }

        /// <summary>A list of ingestible enterprise vaults to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("enterpriseVaults", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IngestibleEnterpriseVault> EnterpriseVaults { get; set; }

        /// <summary>A list of ingestible exchange mailboxes to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("exchangeMailboxes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IngestibleExchangeMailbox> ExchangeMailboxes { get; set; }

        /// <summary>A list of ingestible files to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("files", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IngestibleFile> Files { get; set; }

        /// <summary>A list of ingestible load files to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("loadFiles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IngestibleLoadFile> LoadFiles { get; set; }

        /// <summary>Sets the locale for the evidence container. Some file types and named entities require a locale for them to be ingested accurately. If not set then the system's default locale will be used. Format is that required by IETF BCP 47 (e.g. 'en-US').</summary>
        [Newtonsoft.Json.JsonProperty("locale", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Locale { get; set; }

        /// <summary>A list of ingestible mail stores to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("mailStores", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IngestibleMailStore> MailStores { get; set; }

        /// <summary>Sets the name for the evidence container that is created during ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>A list of ingestible S3 buckets to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("s3Buckets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IngestibleS3Bucket> S3Buckets { get; set; }

        /// <summary>A list of ingestible sharepoint sites to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("sharepointSites", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IngestibleSharepoint> SharepointSites { get; set; }

        /// <summary>A list of ingestible split files to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("splitFiles", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IngestibleSplitFileList> SplitFiles { get; set; }

        /// <summary>A list of ingestible SQL servers to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("sqlServers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IngestibleSQLServer> SqlServers { get; set; }

        /// <summary>A list of SSH-based servers to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("sshServers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<IngestibleSSH> SshServers { get; set; }

        /// <summary>Sets the time zone for the evidence container. If the time zone is not set the system's default time zone will be used.</summary>
        [Newtonsoft.Json.JsonProperty("timeZone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TimeZone { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class IngestibleMailStore
    {
        /// <summary>The host server IP or hostname.</summary>
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Host { get; set; }

        /// <summary>The password.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Password { get; set; }

        /// <summary>The port number.</summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Always)]
        public int Port { get; set; }

        /// <summary>Mailstore protocol, supported values: pop, pops, imap, imaps, gwta.</summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Protocol { get; set; }

        /// <summary>The username for the mail store.</summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Username { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class OcrOptions
    {
        /// <summary>Specifies whether to clear OCR cache. By default the OCR cache will be deleted upon completion. The default location for this cache is under the case directory. See also 'outputDirectory' for customising the location of this cache. Defaults to true</summary>
        [Newtonsoft.Json.JsonProperty("clearOcrCache", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ClearOcrCache { get; set; }

        /// <summary>Whether to deskew text. This will attempt to correct images where text is not level with the page. Defaults to true</summary>
        [Newtonsoft.Json.JsonProperty("deskew", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Deskew { get; set; }

        /// <summary>Specifies the language to use during recognition. Defaults to English</summary>
        [Newtonsoft.Json.JsonProperty("languages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OcrOptionsLanguages? Languages { get; set; }

        /// <summary>Specifies the output directory. Defaults to the temporary directory</summary>
        [Newtonsoft.Json.JsonProperty("outputDirectory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OutputDirectory { get; set; }

        /// <summary>Specifies the OCR processing profile to use.&lt;br/&gt;'default' will use default values which usually produce a good result in a resonable time.&lt;br/&gt;In the following descriptions, those ending in '_speed' have an emphasis on speed rather than accuracy:&lt;br/&gt;'document_archiving_accuracy' is suitable for creating an electronic archive (e.g. PDF). Enables detection of maximum text on an image, including text embedded into the image. Full synthesis of the logical structure of a document is not performed.&lt;br/&gt;'book_archiving_accuracy' is suitable for creating an electronic library (e.g. PDF). Enables detection of font styles and full synthesis of the logical structure of a document.&lt;br/&gt;'document_conversion_accuracy' is suitable for converting documents into an editable format (e.g. RTF, DOCX). Enables detection of font styles and full synthesis of the logical structore of a document.&lt;br/&gt;'text_extraction_accuracy' is suitable for extracting text from a document. Enables detection of all text on an image, including small text areas of low quality (pictures and tables are not detected). Full synthesis of the logical structure of a document is not performed.&lt;br/&gt;'field_level_recognition' is suitable for recognizing short text fragments.&lt;br/&gt;'fast' is deprecated. See 'default'.&lt;br/&gt;'mid_range' is deprecated. See 'document_archiving_speed'.&lt;br/&gt;'high_quality' is deprecated. See 'document_archiving_accuracy'.&lt;br/&gt;Defaults to 'document_archiving_accuracy'</summary>
        [Newtonsoft.Json.JsonProperty("quality", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OcrOptionsQuality? Quality { get; set; }

        /// <summary>Specifies whether to regenerate PDFs before they are sent to the OCR processor. Defaults to false</summary>
        [Newtonsoft.Json.JsonProperty("regeneratePdfs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RegeneratePdfs { get; set; }

        /// <summary>Specifies the page rotation to use on the images. This will rotate the images before processing.&lt;br/&gt;'left' indicates the top of the image is on the left side of the document i.e. it is rotated 90 degrees counter-clockwise.&lt;br/&gt;'right' indicates the top of the image is on the right side of the document i.e. it is rotate 90 degrees clockwise.&lt;br/&gt;'upside_down' indicates the document should be rotate 180 degrees before processing.&lt;br/&gt;Defaults to auto</summary>
        [Newtonsoft.Json.JsonProperty("rotation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OcrOptionsRotation? Rotation { get; set; }

        /// <summary>Specifies whether to append or overwrite new text to the item's existing text. Ignored if 'updateText' is set to false. Defaults to append</summary>
        [Newtonsoft.Json.JsonProperty("textModification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OcrOptionsTextModification? TextModification { get; set; }

        /// <summary>The timeout duration in minutes for processing an item. Must be greater than 1 minute. Defaults to 90</summary>
        [Newtonsoft.Json.JsonProperty("timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Timeout { get; set; }

        /// <summary>Update all duplicate items in the case. Defaults to false</summary>
        [Newtonsoft.Json.JsonProperty("updateDuplicates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UpdateDuplicates { get; set; }

        /// <summary>Specifies whether to update PDFs in the print store with the PDF created by the OCR processor. Defaults to true</summary>
        [Newtonsoft.Json.JsonProperty("updatePdf", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UpdatePdf { get; set; }

        /// <summary>Specifies whether to update the item's text with the text extrated with the OCR processor. Defaults to true</summary>
        [Newtonsoft.Json.JsonProperty("updateText", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UpdateText { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ReviewJobAddItemsOptions
    {
        /// <summary>The user to assign the items to.</summary>
        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class IngestibleSQLServer
    {
        /// <summary>The hostname or IP address of the target server.</summary>
        [Newtonsoft.Json.JsonProperty("computer", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Computer { get; set; }

        /// <summary>This optional parameter defines the Windows networking domain of the server account.</summary>
        [Newtonsoft.Json.JsonProperty("domain", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Domain { get; set; }

        /// <summary>This parameter specifies the database instance.</summary>
        [Newtonsoft.Json.JsonProperty("instance", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Instance { get; set; }

        /// <summary>The password needed to access the server account.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Password { get; set; }

        /// <summary>This optional parameter specifies the SQL query used to filter the content.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Query { get; set; }

        /// <summary>The username needed to access the server account.</summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Username { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ThumbnailUtilityRequest
    {
        /// <summary>A list of dimensions for the thumbnails to be generated. No thumnails are generated if this is not set.</summary>
        [Newtonsoft.Json.JsonProperty("dimensions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ThumbnailUtilityRequestDimension> Dimensions { get; set; }

        /// <summary>A Nuix query to filter items.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Query { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CaseHistoryEventResponse
    {
        [Newtonsoft.Json.JsonProperty("cancelled", Required = Newtonsoft.Json.Required.Always)]
        public bool Cancelled { get; set; }

        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object Details { get; set; } = new object();

        [Newtonsoft.Json.JsonProperty("endDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset EndDate { get; set; }

        [Newtonsoft.Json.JsonProperty("failed", Required = Newtonsoft.Json.Required.Always)]
        public bool Failed { get; set; }

        [Newtonsoft.Json.JsonProperty("startDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset StartDate { get; set; }

        [Newtonsoft.Json.JsonProperty("succeeded", Required = Newtonsoft.Json.Required.Always)]
        public bool Succeeded { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }

        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Username { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class CreateReviewJobOptions
    {
        /// <summary>Any words to highlight.</summary>
        [Newtonsoft.Json.JsonProperty("highlights", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Highlights { get; set; }

        /// <summary>Default sort order for items in a review job.  Default is orderAdded.</summary>
        [Newtonsoft.Json.JsonProperty("order", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CreateReviewJobOptionsOrder? Order { get; set; }

        /// <summary>Tags to be used for the review job.</summary>
        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Tags { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>Use email threads when batching out items to a reviewer.  Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("useEmailThreads", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UseEmailThreads { get; set; }

        /// <summary>Use chained near-duplicates when batching out items to a reviewer.  Default is true.</summary>
        [Newtonsoft.Json.JsonProperty("useNearDuplicates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UseNearDuplicates { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SingleContainerIngestionRequestOfIngestibleCenteraCluster
    {
        /// <summary>Deprecated in favor of processingProfile. Configuration profile to use as base set of processor, parallel processing, and mime type settings.  Values present in processorSettings, parallelProcessingSettings, and mimeTypeProcessorSettings will override anything defined by this profile.</summary>
        [Newtonsoft.Json.JsonProperty("configurationProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationProfile { get; set; }

        /// <summary>The evidence container to create for this ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("container", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EvidenceContainer Container { get; set; }

        /// <summary>Sets the settings used to apply a keystore file to the ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("keystoreKeyParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyStoreKeyParameters> KeystoreKeyParameters { get; set; }

        /// <summary>Sets the processing settings for individual mime types.</summary>
        [Newtonsoft.Json.JsonProperty("mimeTypeProcessorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MimeTypeProcessingSetting> MimeTypeProcessorSettings { get; set; }

        /// <summary>Sets the parallel processing settings to use for processing.</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>The name of the Processing Profile to use. If you use this setting then do not use any other settings from processorSettings as everything will be overridden by the loaded Processing profile.</summary>
        [Newtonsoft.Json.JsonProperty("processingProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessingProfile { get; set; }

        /// <summary>Sets the processing settings to use.</summary>
        [Newtonsoft.Json.JsonProperty("processorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProcessorSettings ProcessorSettings { get; set; }

        /// <summary>If true, the case's Evidence Repositories will be rescanned to discover new Evidence Containers within them and new files within existing Evidence Containers which are themselves within the cases's Evidence Repositories. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("rescanEvidenceRepositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RescanEvidenceRepositories { get; set; }

        /// <summary>The ingestible target to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IngestibleCenteraCluster Target { get; set; } = new IngestibleCenteraCluster();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SystemPropertyResponse
    {
        /// <summary>The name of the system property.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>The previous value of the system property, or null if there was no property with that key.</summary>
        [Newtonsoft.Json.JsonProperty("previousValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PreviousValue { get; set; }

        /// <summary>The current value of the system property, or null if there was no property with that key.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class MapOfstringAndobject : System.Collections.Generic.Dictionary<string, object>
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SingleContainerIngestionRequestOfIngestibleLoadFile
    {
        /// <summary>Deprecated in favor of processingProfile. Configuration profile to use as base set of processor, parallel processing, and mime type settings.  Values present in processorSettings, parallelProcessingSettings, and mimeTypeProcessorSettings will override anything defined by this profile.</summary>
        [Newtonsoft.Json.JsonProperty("configurationProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationProfile { get; set; }

        /// <summary>The evidence container to create for this ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("container", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EvidenceContainer Container { get; set; }

        /// <summary>Sets the settings used to apply a keystore file to the ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("keystoreKeyParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyStoreKeyParameters> KeystoreKeyParameters { get; set; }

        /// <summary>Sets the processing settings for individual mime types.</summary>
        [Newtonsoft.Json.JsonProperty("mimeTypeProcessorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MimeTypeProcessingSetting> MimeTypeProcessorSettings { get; set; }

        /// <summary>Sets the parallel processing settings to use for processing.</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>The name of the Processing Profile to use. If you use this setting then do not use any other settings from processorSettings as everything will be overridden by the loaded Processing profile.</summary>
        [Newtonsoft.Json.JsonProperty("processingProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessingProfile { get; set; }

        /// <summary>Sets the processing settings to use.</summary>
        [Newtonsoft.Json.JsonProperty("processorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProcessorSettings ProcessorSettings { get; set; }

        /// <summary>If true, the case's Evidence Repositories will be rescanned to discover new Evidence Containers within them and new files within existing Evidence Containers which are themselves within the cases's Evidence Repositories. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("rescanEvidenceRepositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RescanEvidenceRepositories { get; set; }

        /// <summary>The ingestible target to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IngestibleLoadFile Target { get; set; } = new IngestibleLoadFile();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class SingleContainerIngestionRequestOfIngestibleSplitFileList
    {
        /// <summary>Deprecated in favor of processingProfile. Configuration profile to use as base set of processor, parallel processing, and mime type settings.  Values present in processorSettings, parallelProcessingSettings, and mimeTypeProcessorSettings will override anything defined by this profile.</summary>
        [Newtonsoft.Json.JsonProperty("configurationProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigurationProfile { get; set; }

        /// <summary>The evidence container to create for this ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("container", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EvidenceContainer Container { get; set; }

        /// <summary>Sets the settings used to apply a keystore file to the ingestion.</summary>
        [Newtonsoft.Json.JsonProperty("keystoreKeyParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyStoreKeyParameters> KeystoreKeyParameters { get; set; }

        /// <summary>Sets the processing settings for individual mime types.</summary>
        [Newtonsoft.Json.JsonProperty("mimeTypeProcessorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MimeTypeProcessingSetting> MimeTypeProcessorSettings { get; set; }

        /// <summary>Sets the parallel processing settings to use for processing.</summary>
        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>The name of the Processing Profile to use. If you use this setting then do not use any other settings from processorSettings as everything will be overridden by the loaded Processing profile.</summary>
        [Newtonsoft.Json.JsonProperty("processingProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcessingProfile { get; set; }

        /// <summary>Sets the processing settings to use.</summary>
        [Newtonsoft.Json.JsonProperty("processorSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProcessorSettings ProcessorSettings { get; set; }

        /// <summary>If true, the case's Evidence Repositories will be rescanned to discover new Evidence Containers within them and new files within existing Evidence Containers which are themselves within the cases's Evidence Repositories. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("rescanEvidenceRepositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RescanEvidenceRepositories { get; set; }

        /// <summary>The ingestible target to ingest.</summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public IngestibleSplitFileList Target { get; set; } = new IngestibleSplitFileList();


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class IngestibleSharepoint
    {
        /// <summary>This optional parameter defines the Windows networking domain of the server account.</summary>
        [Newtonsoft.Json.JsonProperty("domain", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Domain { get; set; }

        /// <summary>The password needed to access the server account.</summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Password { get; set; }

        /// <summary>Protocol, host, port and path can all be specified. For SharePoint the address is the site address. For Exchange the address is the path to the Exchange Web Service (e.g., https://ex2010/ews/exchange.asmx) and it can be omitted to use auto-discovery based on the mailbox or username address.</summary>
        [Newtonsoft.Json.JsonProperty("uri", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Uri { get; set; }

        /// <summary>The username needed to access the server account.</summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Username { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class AsyncFunctionStatusesResponse
    {
        /// <summary>caseFunctionQueues</summary>
        [Newtonsoft.Json.JsonProperty("caseQueues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CaseFunctionQueue> CaseQueues { get; set; }

        /// <summary>List of AsyncFunctionStatus objects for Async functions which are queued to execute.</summary>
        [Newtonsoft.Json.JsonProperty("executeImmediate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AsyncFunctionStatusOfobject> ExecuteImmediate { get; set; }

        [Newtonsoft.Json.JsonProperty("paused", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Paused { get; set; }

        [Newtonsoft.Json.JsonProperty("pausedBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PausedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("pausedUntil", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? PausedUntil { get; set; }

        [Newtonsoft.Json.JsonProperty("singleItemQueue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<AsyncFunctionStatusOfobject> SingleItemQueue { get; set; }

        [Newtonsoft.Json.JsonProperty("totalRunningFunctions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TotalRunningFunctions { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ItemSetDuplicatesResponse
    {
        /// <summary>The list of GUIDs representing duplicate items</summary>
        [Newtonsoft.Json.JsonProperty("duplicates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Duplicates { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class NmsUser
    {
        /// <summary>The long name of the user.</summary>
        [Newtonsoft.Json.JsonProperty("longName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string LongName { get; set; }

        /// <summary>The short name of the user.</summary>
        [Newtonsoft.Json.JsonProperty("shortName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ShortName { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ParallelProcessingSettings
    {
        /// <summary>Amount of memory to allocate to the JMS broker when it is run in a separate process. The provided value must be &amp;gt;= 768. Default is 4096.</summary>
        [Newtonsoft.Json.JsonProperty("brokerMemory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? BrokerMemory { get; set; }

        /// <summary>If true, the JMS broker will be run within the current process,otherwise it will be run in a new process. Default is true.</summary>
        [Newtonsoft.Json.JsonProperty("embedBroker", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EmbedBroker { get; set; }

        /// <summary>Worker broker address in the format host:port. </summary>
        [Newtonsoft.Json.JsonProperty("workerBrokerAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkerBrokerAddress { get; set; }

        /// <summary>Number of worker processes to use. This defaults to number of CPU cores on the machine. This value is also limited by settings in the current licence / session.</summary>
        [Newtonsoft.Json.JsonProperty("workerCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? WorkerCount { get; set; }

        /// <summary>Maximum amount of memory to allocate to each worker process in megabytes. The provided value must be &amp;gt;= 768. Default is calculated based on the number of workers and available machine memory.</summary>
        [Newtonsoft.Json.JsonProperty("workerMemory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? WorkerMemory { get; set; }

        /// <summary>Base directory that workers will use to store temporary files generated during process. Can be a string file path, File, Path or URI. The default is a directory under the case directory.</summary>
        [Newtonsoft.Json.JsonProperty("workerTemp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkerTemp { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ProductionSetRequest
    {
        /// <summary>If true, applies highlights in the markup sets. Default is true.</summary>
        [Newtonsoft.Json.JsonProperty("applyHighlights", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ApplyHighlights { get; set; }

        /// <summary>If true, applies redactions in the markup sets. Default is true.</summary>
        [Newtonsoft.Json.JsonProperty("applyRedactions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ApplyRedactions { get; set; }

        /// <summary>A description for the production set.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>Generates print previews for the selected items in this production set. Default is false.</summary>
        [Newtonsoft.Json.JsonProperty("generatePdfStores", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? GeneratePdfStores { get; set; }

        /// <summary>If true, includes family items for the collection of items returned by the query. Default is false</summary>
        [Newtonsoft.Json.JsonProperty("includeFamilies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IncludeFamilies { get; set; }

        /// <summary>Sets the given markup sets to be used during the export.</summary>
        [Newtonsoft.Json.JsonProperty("markupSets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> MarkupSets { get; set; }

        /// <summary>The name of the production set.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("parallelProcessingSettings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParallelProcessingSettings ParallelProcessingSettings { get; set; }

        /// <summary>Query that identifies which production set items should have print previews generated. If a query is not supplied it defaults to an empty string, which returns all items.</summary>
        [Newtonsoft.Json.JsonProperty("pdfStoresQuery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PdfStoresQuery { get; set; }

        /// <summary>Prefix used for document numbering.</summary>
        [Newtonsoft.Json.JsonProperty("prefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Prefix { get; set; }

        /// <summary>Query items that should be included. If a query is not supplied it defaults to an empty string, which returns all items.</summary>
        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Query { get; set; }

        /// <summary>The first number used for document numbering.</summary>
        [Newtonsoft.Json.JsonProperty("startingNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StartingNumber { get; set; }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class UserScriptRequest
    {
        /// <summary>Specifies whether this script should run asynchronously.  Defaults to true.</summary>
        [Newtonsoft.Json.JsonProperty("async", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Async { get; set; }

        /// <summary>Used to map any arguments the user wants to add and reference later in the script.</summary>
        [Newtonsoft.Json.JsonProperty("customArguments", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object CustomArguments { get; set; }

        /// <summary>A brief description of what the script does.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>The path location of a script file, relative to the 'userScriptsLocation' property. If this field has a value, it will be used and has priority over the "script" field.</summary>
        [Newtonsoft.Json.JsonProperty("fileName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FileName { get; set; }

        /// <summary>Language that the script is written in.</summary>
        [Newtonsoft.Json.JsonProperty("language", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public UserScriptRequestLanguage Language { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>A script to execute as a literal string.  If the filename property has a value, this field will be ignored and the script will be run from the provided file location instead.</summary>
        [Newtonsoft.Json.JsonProperty("script", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Script { get; set; }


    }

    /// <summary>How the deduplication is applied. None returns all items matching the query including duplicates. Other options return deduplicated items based on the deduplication method used.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Deduplication
    {
        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"MD5")]
        MD5 = 1,

    }

    /// <summary>How the deduplication is applied. None returns all items matching the query including duplicates. Other options return deduplicated items based on the deduplication method used.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Deduplication2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"MD5")]
        MD5 = 1,

    }

    /// <summary>The type of contact address</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum AddressType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"internet_mail")]
        Internet_mail = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"phone")]
        Phone = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"instant_message")]
        Instant_message = 2,

    }

    /// <summary>Filters the type of history event returned.  If not specified, all events are returned.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"openSession")]
        OpenSession = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"closeSession")]
        CloseSession = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"loadData")]
        LoadData = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"search")]
        Search = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"annotation")]
        Annotation = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"export")]
        Export = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"import")]
        Import = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"delete")]
        Delete = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"script")]
        Script = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"printPreview")]
        PrintPreview = 9,

    }

    /// <summary>Type filter.  Filters metadata fields that are returned.  Fields that do not match the type are removed by the filter.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum TypeFilter
    {
        [System.Runtime.Serialization.EnumMember(Value = @"binary")]
        Binary = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"boolean")]
        Boolean = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"date-time")]
        DateTime = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"float")]
        Float = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"integer")]
        Integer = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"text")]
        Text = 5,

    }

    /// <summary>Mode filter.  Filters metadata fields that are returned.  Fields that do not match the mode are removed by the filter.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ModeFilter
    {
        [System.Runtime.Serialization.EnumMember(Value = @"api")]
        Api = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"user")]
        User = 1,

    }

    /// <summary>Deduplicate content based on the Value field selection. The default is no deduplication.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Deduplicate
    {
        [System.Runtime.Serialization.EnumMember(Value = @"MD5")]
        MD5 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Per Custodian")]
        Per_Custodian = 1,

    }

    /// <summary>Sets the sort order for the results.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum SortOrder
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ASC")]
        ASC = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"DESC")]
        DESC = 1,

    }

    /// <summary>The relation to apply to the found items.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum RelationType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"family")]
        Family = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"topTypes")]
        TopTypes = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"descendants")]
        Descendants = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Anonymous
    {
        [System.Runtime.Serialization.EnumMember(Value = @"MIGRATE")]
        MIGRATE = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ItemSizesRequestDeduplication
    {
        [System.Runtime.Serialization.EnumMember(Value = @"none")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"md5")]
        Md5 = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ItemSizesRequestSizeType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"FILE_SIZE")]
        FILE_SIZE = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"AUDIT_SIZE")]
        AUDIT_SIZE = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ItemSetRequestDeduplicateBy
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INDIVIDUAL")]
        INDIVIDUAL = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"FAMILY")]
        FAMILY = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ItemSetRequestDeduplication
    {
        [System.Runtime.Serialization.EnumMember(Value = @"MD5")]
        MD5 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Per Custodian")]
        Per_Custodian = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"MD5 Ranked Custodian")]
        MD5_Ranked_Custodian = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Scripted")]
        Scripted = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum CustomMetadataRequestMode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"api")]
        Api = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"user")]
        User = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum CustomMetadataRequestType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"binary")]
        Binary = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"boolean")]
        Boolean = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"date-time")]
        DateTime = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"float")]
        Float = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"integer")]
        Integer = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"text")]
        Text = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Languages
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Abkhaz")]
        Abkhaz = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Adyghe")]
        Adyghe = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Afrikaans")]
        Afrikaans = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Agul")]
        Agul = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"Albanian")]
        Albanian = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"Altaic")]
        Altaic = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"Arabic")]
        Arabic = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"ArmenianEastern")]
        ArmenianEastern = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"ArmenianGrabar")]
        ArmenianGrabar = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"ArmenianWestern")]
        ArmenianWestern = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"Awar")]
        Awar = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"Aymara")]
        Aymara = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"AzeriCyrillic")]
        AzeriCyrillic = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"AzeriLatin")]
        AzeriLatin = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"Bashkir")]
        Bashkir = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"Basque")]
        Basque = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"Belarusian")]
        Belarusian = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"Bemba")]
        Bemba = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"Blackfoot")]
        Blackfoot = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"Breton")]
        Breton = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"Bugotu")]
        Bugotu = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"Bulgarian")]
        Bulgarian = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"Buryat")]
        Buryat = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"Catalan")]
        Catalan = 23,

        [System.Runtime.Serialization.EnumMember(Value = @"Chamorro")]
        Chamorro = 24,

        [System.Runtime.Serialization.EnumMember(Value = @"Chechen")]
        Chechen = 25,

        [System.Runtime.Serialization.EnumMember(Value = @"ChinesePRC")]
        ChinesePRC = 26,

        [System.Runtime.Serialization.EnumMember(Value = @"ChineseTaiwan")]
        ChineseTaiwan = 27,

        [System.Runtime.Serialization.EnumMember(Value = @"Chukcha")]
        Chukcha = 28,

        [System.Runtime.Serialization.EnumMember(Value = @"Chuvash")]
        Chuvash = 29,

        [System.Runtime.Serialization.EnumMember(Value = @"Corsican")]
        Corsican = 30,

        [System.Runtime.Serialization.EnumMember(Value = @"CrimeanTatar")]
        CrimeanTatar = 31,

        [System.Runtime.Serialization.EnumMember(Value = @"Croatian")]
        Croatian = 32,

        [System.Runtime.Serialization.EnumMember(Value = @"Crow")]
        Crow = 33,

        [System.Runtime.Serialization.EnumMember(Value = @"Czech")]
        Czech = 34,

        [System.Runtime.Serialization.EnumMember(Value = @"Danish")]
        Danish = 35,

        [System.Runtime.Serialization.EnumMember(Value = @"Dargwa")]
        Dargwa = 36,

        [System.Runtime.Serialization.EnumMember(Value = @"Dungan")]
        Dungan = 37,

        [System.Runtime.Serialization.EnumMember(Value = @"Dutch")]
        Dutch = 38,

        [System.Runtime.Serialization.EnumMember(Value = @"DutchBelgian")]
        DutchBelgian = 39,

        [System.Runtime.Serialization.EnumMember(Value = @"English")]
        English = 40,

        [System.Runtime.Serialization.EnumMember(Value = @"EskimoCyrillic")]
        EskimoCyrillic = 41,

        [System.Runtime.Serialization.EnumMember(Value = @"EskimoLatin")]
        EskimoLatin = 42,

        [System.Runtime.Serialization.EnumMember(Value = @"Esperanto")]
        Esperanto = 43,

        [System.Runtime.Serialization.EnumMember(Value = @"Estonian")]
        Estonian = 44,

        [System.Runtime.Serialization.EnumMember(Value = @"Even")]
        Even = 45,

        [System.Runtime.Serialization.EnumMember(Value = @"Evenki")]
        Evenki = 46,

        [System.Runtime.Serialization.EnumMember(Value = @"Faeroese")]
        Faeroese = 47,

        [System.Runtime.Serialization.EnumMember(Value = @"Fijian")]
        Fijian = 48,

        [System.Runtime.Serialization.EnumMember(Value = @"Finnish")]
        Finnish = 49,

        [System.Runtime.Serialization.EnumMember(Value = @"French")]
        French = 50,

        [System.Runtime.Serialization.EnumMember(Value = @"Frisian")]
        Frisian = 51,

        [System.Runtime.Serialization.EnumMember(Value = @"Friulian")]
        Friulian = 52,

        [System.Runtime.Serialization.EnumMember(Value = @"GaelicScottish")]
        GaelicScottish = 53,

        [System.Runtime.Serialization.EnumMember(Value = @"Gagauz")]
        Gagauz = 54,

        [System.Runtime.Serialization.EnumMember(Value = @"Galician")]
        Galician = 55,

        [System.Runtime.Serialization.EnumMember(Value = @"Ganda")]
        Ganda = 56,

        [System.Runtime.Serialization.EnumMember(Value = @"German")]
        German = 57,

        [System.Runtime.Serialization.EnumMember(Value = @"GermanLuxembourg")]
        GermanLuxembourg = 58,

        [System.Runtime.Serialization.EnumMember(Value = @"GermanNewSpelling")]
        GermanNewSpelling = 59,

        [System.Runtime.Serialization.EnumMember(Value = @"Greek")]
        Greek = 60,

        [System.Runtime.Serialization.EnumMember(Value = @"Guarani")]
        Guarani = 61,

        [System.Runtime.Serialization.EnumMember(Value = @"Hani")]
        Hani = 62,

        [System.Runtime.Serialization.EnumMember(Value = @"Hausa")]
        Hausa = 63,

        [System.Runtime.Serialization.EnumMember(Value = @"Hawaiian")]
        Hawaiian = 64,

        [System.Runtime.Serialization.EnumMember(Value = @"Hebrew")]
        Hebrew = 65,

        [System.Runtime.Serialization.EnumMember(Value = @"Hungarian")]
        Hungarian = 66,

        [System.Runtime.Serialization.EnumMember(Value = @"Icelandic")]
        Icelandic = 67,

        [System.Runtime.Serialization.EnumMember(Value = @"Ido")]
        Ido = 68,

        [System.Runtime.Serialization.EnumMember(Value = @"Indonesian")]
        Indonesian = 69,

        [System.Runtime.Serialization.EnumMember(Value = @"Ingush")]
        Ingush = 70,

        [System.Runtime.Serialization.EnumMember(Value = @"Interlingua")]
        Interlingua = 71,

        [System.Runtime.Serialization.EnumMember(Value = @"Irish")]
        Irish = 72,

        [System.Runtime.Serialization.EnumMember(Value = @"Italian")]
        Italian = 73,

        [System.Runtime.Serialization.EnumMember(Value = @"Japanese")]
        Japanese = 74,

        [System.Runtime.Serialization.EnumMember(Value = @"Kabardian")]
        Kabardian = 75,

        [System.Runtime.Serialization.EnumMember(Value = @"Kalmyk")]
        Kalmyk = 76,

        [System.Runtime.Serialization.EnumMember(Value = @"KarachayBalkar")]
        KarachayBalkar = 77,

        [System.Runtime.Serialization.EnumMember(Value = @"Karakalpak")]
        Karakalpak = 78,

        [System.Runtime.Serialization.EnumMember(Value = @"Kasub")]
        Kasub = 79,

        [System.Runtime.Serialization.EnumMember(Value = @"Kawa")]
        Kawa = 80,

        [System.Runtime.Serialization.EnumMember(Value = @"Kazakh")]
        Kazakh = 81,

        [System.Runtime.Serialization.EnumMember(Value = @"Khakas")]
        Khakas = 82,

        [System.Runtime.Serialization.EnumMember(Value = @"Khanty")]
        Khanty = 83,

        [System.Runtime.Serialization.EnumMember(Value = @"Kikuyu")]
        Kikuyu = 84,

        [System.Runtime.Serialization.EnumMember(Value = @"Kirgiz")]
        Kirgiz = 85,

        [System.Runtime.Serialization.EnumMember(Value = @"Kongo")]
        Kongo = 86,

        [System.Runtime.Serialization.EnumMember(Value = @"Korean")]
        Korean = 87,

        [System.Runtime.Serialization.EnumMember(Value = @"Koryak")]
        Koryak = 88,

        [System.Runtime.Serialization.EnumMember(Value = @"Kpelle")]
        Kpelle = 89,

        [System.Runtime.Serialization.EnumMember(Value = @"Kumyk")]
        Kumyk = 90,

        [System.Runtime.Serialization.EnumMember(Value = @"Kurdish")]
        Kurdish = 91,

        [System.Runtime.Serialization.EnumMember(Value = @"Lak")]
        Lak = 92,

        [System.Runtime.Serialization.EnumMember(Value = @"Lappish")]
        Lappish = 93,

        [System.Runtime.Serialization.EnumMember(Value = @"Latin")]
        Latin = 94,

        [System.Runtime.Serialization.EnumMember(Value = @"Latvian")]
        Latvian = 95,

        [System.Runtime.Serialization.EnumMember(Value = @"LatvianGothic")]
        LatvianGothic = 96,

        [System.Runtime.Serialization.EnumMember(Value = @"Lezgin")]
        Lezgin = 97,

        [System.Runtime.Serialization.EnumMember(Value = @"Lithuanian")]
        Lithuanian = 98,

        [System.Runtime.Serialization.EnumMember(Value = @"Luba")]
        Luba = 99,

        [System.Runtime.Serialization.EnumMember(Value = @"Macedonian")]
        Macedonian = 100,

        [System.Runtime.Serialization.EnumMember(Value = @"Malagasy")]
        Malagasy = 101,

        [System.Runtime.Serialization.EnumMember(Value = @"Malay")]
        Malay = 102,

        [System.Runtime.Serialization.EnumMember(Value = @"Malinke")]
        Malinke = 103,

        [System.Runtime.Serialization.EnumMember(Value = @"Maltese")]
        Maltese = 104,

        [System.Runtime.Serialization.EnumMember(Value = @"Mansi")]
        Mansi = 105,

        [System.Runtime.Serialization.EnumMember(Value = @"Maori")]
        Maori = 106,

        [System.Runtime.Serialization.EnumMember(Value = @"Mari")]
        Mari = 107,

        [System.Runtime.Serialization.EnumMember(Value = @"Maya")]
        Maya = 108,

        [System.Runtime.Serialization.EnumMember(Value = @"Miao")]
        Miao = 109,

        [System.Runtime.Serialization.EnumMember(Value = @"Minankabaw")]
        Minankabaw = 110,

        [System.Runtime.Serialization.EnumMember(Value = @"Mohawk")]
        Mohawk = 111,

        [System.Runtime.Serialization.EnumMember(Value = @"Mongol")]
        Mongol = 112,

        [System.Runtime.Serialization.EnumMember(Value = @"Mordvin")]
        Mordvin = 113,

        [System.Runtime.Serialization.EnumMember(Value = @"Nahuatl")]
        Nahuatl = 114,

        [System.Runtime.Serialization.EnumMember(Value = @"Nenets")]
        Nenets = 115,

        [System.Runtime.Serialization.EnumMember(Value = @"Nivkh")]
        Nivkh = 116,

        [System.Runtime.Serialization.EnumMember(Value = @"Nogay")]
        Nogay = 117,

        [System.Runtime.Serialization.EnumMember(Value = @"Norwegian")]
        Norwegian = 118,

        [System.Runtime.Serialization.EnumMember(Value = @"NorwegianBokmal")]
        NorwegianBokmal = 119,

        [System.Runtime.Serialization.EnumMember(Value = @"NorwegianNynorsk")]
        NorwegianNynorsk = 120,

        [System.Runtime.Serialization.EnumMember(Value = @"Nyanja")]
        Nyanja = 121,

        [System.Runtime.Serialization.EnumMember(Value = @"Occidental")]
        Occidental = 122,

        [System.Runtime.Serialization.EnumMember(Value = @"Ojibway")]
        Ojibway = 123,

        [System.Runtime.Serialization.EnumMember(Value = @"Ossetic")]
        Ossetic = 124,

        [System.Runtime.Serialization.EnumMember(Value = @"Papiamento")]
        Papiamento = 125,

        [System.Runtime.Serialization.EnumMember(Value = @"PidginEnglish")]
        PidginEnglish = 126,

        [System.Runtime.Serialization.EnumMember(Value = @"Polish")]
        Polish = 127,

        [System.Runtime.Serialization.EnumMember(Value = @"PortugueseBrazilian")]
        PortugueseBrazilian = 128,

        [System.Runtime.Serialization.EnumMember(Value = @"PortugueseStandard")]
        PortugueseStandard = 129,

        [System.Runtime.Serialization.EnumMember(Value = @"Provencal")]
        Provencal = 130,

        [System.Runtime.Serialization.EnumMember(Value = @"Quechua")]
        Quechua = 131,

        [System.Runtime.Serialization.EnumMember(Value = @"RhaetoRomanic")]
        RhaetoRomanic = 132,

        [System.Runtime.Serialization.EnumMember(Value = @"Romanian")]
        Romanian = 133,

        [System.Runtime.Serialization.EnumMember(Value = @"RomanianMoldavia")]
        RomanianMoldavia = 134,

        [System.Runtime.Serialization.EnumMember(Value = @"Romany")]
        Romany = 135,

        [System.Runtime.Serialization.EnumMember(Value = @"Ruanda")]
        Ruanda = 136,

        [System.Runtime.Serialization.EnumMember(Value = @"Rundi")]
        Rundi = 137,

        [System.Runtime.Serialization.EnumMember(Value = @"Russian")]
        Russian = 138,

        [System.Runtime.Serialization.EnumMember(Value = @"RussianOldSpelling")]
        RussianOldSpelling = 139,

        [System.Runtime.Serialization.EnumMember(Value = @"Samoan")]
        Samoan = 140,

        [System.Runtime.Serialization.EnumMember(Value = @"Selkup")]
        Selkup = 141,

        [System.Runtime.Serialization.EnumMember(Value = @"SerbianCyrillic")]
        SerbianCyrillic = 142,

        [System.Runtime.Serialization.EnumMember(Value = @"SerbianLatin")]
        SerbianLatin = 143,

        [System.Runtime.Serialization.EnumMember(Value = @"Shona")]
        Shona = 144,

        [System.Runtime.Serialization.EnumMember(Value = @"Sioux")]
        Sioux = 145,

        [System.Runtime.Serialization.EnumMember(Value = @"Slovak")]
        Slovak = 146,

        [System.Runtime.Serialization.EnumMember(Value = @"Slovenian")]
        Slovenian = 147,

        [System.Runtime.Serialization.EnumMember(Value = @"Somali")]
        Somali = 148,

        [System.Runtime.Serialization.EnumMember(Value = @"Sorbian")]
        Sorbian = 149,

        [System.Runtime.Serialization.EnumMember(Value = @"Sotho")]
        Sotho = 150,

        [System.Runtime.Serialization.EnumMember(Value = @"Spanish")]
        Spanish = 151,

        [System.Runtime.Serialization.EnumMember(Value = @"Sunda")]
        Sunda = 152,

        [System.Runtime.Serialization.EnumMember(Value = @"Swahili")]
        Swahili = 153,

        [System.Runtime.Serialization.EnumMember(Value = @"Swazi")]
        Swazi = 154,

        [System.Runtime.Serialization.EnumMember(Value = @"Swedish")]
        Swedish = 155,

        [System.Runtime.Serialization.EnumMember(Value = @"Tabassaran")]
        Tabassaran = 156,

        [System.Runtime.Serialization.EnumMember(Value = @"Tagalog")]
        Tagalog = 157,

        [System.Runtime.Serialization.EnumMember(Value = @"Tahitian")]
        Tahitian = 158,

        [System.Runtime.Serialization.EnumMember(Value = @"Tajik")]
        Tajik = 159,

        [System.Runtime.Serialization.EnumMember(Value = @"Tatar")]
        Tatar = 160,

        [System.Runtime.Serialization.EnumMember(Value = @"Thai")]
        Thai = 161,

        [System.Runtime.Serialization.EnumMember(Value = @"Tinpo")]
        Tinpo = 162,

        [System.Runtime.Serialization.EnumMember(Value = @"Tongan")]
        Tongan = 163,

        [System.Runtime.Serialization.EnumMember(Value = @"Tswana")]
        Tswana = 164,

        [System.Runtime.Serialization.EnumMember(Value = @"Tun")]
        Tun = 165,

        [System.Runtime.Serialization.EnumMember(Value = @"Turkish")]
        Turkish = 166,

        [System.Runtime.Serialization.EnumMember(Value = @"Turkmen")]
        Turkmen = 167,

        [System.Runtime.Serialization.EnumMember(Value = @"TurkmenLatin")]
        TurkmenLatin = 168,

        [System.Runtime.Serialization.EnumMember(Value = @"Tuvin")]
        Tuvin = 169,

        [System.Runtime.Serialization.EnumMember(Value = @"Udmurt")]
        Udmurt = 170,

        [System.Runtime.Serialization.EnumMember(Value = @"UighurCyrillic")]
        UighurCyrillic = 171,

        [System.Runtime.Serialization.EnumMember(Value = @"UighurLatin")]
        UighurLatin = 172,

        [System.Runtime.Serialization.EnumMember(Value = @"Ukrainian")]
        Ukrainian = 173,

        [System.Runtime.Serialization.EnumMember(Value = @"UzbekCyrillic")]
        UzbekCyrillic = 174,

        [System.Runtime.Serialization.EnumMember(Value = @"UzbekLatin")]
        UzbekLatin = 175,

        [System.Runtime.Serialization.EnumMember(Value = @"Vietnamese")]
        Vietnamese = 176,

        [System.Runtime.Serialization.EnumMember(Value = @"Visayan")]
        Visayan = 177,

        [System.Runtime.Serialization.EnumMember(Value = @"Welsh")]
        Welsh = 178,

        [System.Runtime.Serialization.EnumMember(Value = @"Wolof")]
        Wolof = 179,

        [System.Runtime.Serialization.EnumMember(Value = @"Xhosa")]
        Xhosa = 180,

        [System.Runtime.Serialization.EnumMember(Value = @"Yakut")]
        Yakut = 181,

        [System.Runtime.Serialization.EnumMember(Value = @"Yiddish")]
        Yiddish = 182,

        [System.Runtime.Serialization.EnumMember(Value = @"Zapotec")]
        Zapotec = 183,

        [System.Runtime.Serialization.EnumMember(Value = @"Zulu")]
        Zulu = 184,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum OcrOptionsV2Quality
    {
        [System.Runtime.Serialization.EnumMember(Value = @"default")]
        Default = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"document_archiving_accuracy")]
        Document_archiving_accuracy = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"document_archiving_speed")]
        Document_archiving_speed = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"book_archiving_accuracy")]
        Book_archiving_accuracy = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"book_archiving_speed")]
        Book_archiving_speed = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"document_conversion_accuracy")]
        Document_conversion_accuracy = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"document_conversion_speed")]
        Document_conversion_speed = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"text_extraction_accuracy")]
        Text_extraction_accuracy = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"text_extraction_speed")]
        Text_extraction_speed = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"field_level_recognition")]
        Field_level_recognition = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"fast")]
        Fast = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"mid_range")]
        Mid_range = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"high_quality")]
        High_quality = 12,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum OcrOptionsV2Rotation
    {
        [System.Runtime.Serialization.EnumMember(Value = @"auto")]
        Auto = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"no_rotation")]
        No_rotation = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"left")]
        Left = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"right")]
        Right = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"upside_down")]
        Upside_down = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum OcrOptionsV2TextModification
    {
        [System.Runtime.Serialization.EnumMember(Value = @"append")]
        Append = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"overwrite")]
        Overwrite = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ItemsShinglesRequestDeduplication
    {
        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"MD5")]
        MD5 = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum BulkSearcherRequestMatchingItemsAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ADD_TAGS")]
        ADD_TAGS = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"REMOVE_TAGS")]
        REMOVE_TAGS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"NONE")]
        NONE = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum BulkSearcherRequestMissingTagsAction
    {
        [System.Runtime.Serialization.EnumMember(Value = @"FILL_WITH_QUERY")]
        FILL_WITH_QUERY = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"FILL_WITH_ROW_NUMBER")]
        FILL_WITH_ROW_NUMBER = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"SHOW_VALIDATION_ERROR")]
        SHOW_VALIDATION_ERROR = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum SearchFields
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CONTENT")]
        CONTENT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"PEROPERTIES")]
        PEROPERTIES = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"NAME")]
        NAME = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"PATH_NAME")]
        PATH_NAME = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"EVIDENCE_METADATADefaults to an empty list.")]
        EVIDENCE_METADATADefaults_to_an_empty_list_ = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum SearchNativeRequestDeduplicate
    {
        [System.Runtime.Serialization.EnumMember(Value = @"MD5")]
        MD5 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Per Custodian")]
        Per_Custodian = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum SearchNativeRequestRelationType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"family")]
        Family = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"topTypes")]
        TopTypes = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"descendants")]
        Descendants = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum SearchNativeRequestSortOrder
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ASC")]
        ASC = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"DESC")]
        DESC = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum Digests
    {
        [System.Runtime.Serialization.EnumMember(Value = @"MD5")]
        MD5 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SHA-1")]
        SHA1 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"SHA-256")]
        SHA256 = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ProcessorSettingsReportProcessingStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"physical_files")]
        Physical_files = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"none")]
        None = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ImagingOptionsExcelExportingEngine
    {
        [System.Runtime.Serialization.EnumMember(Value = @"MS_OFFICE")]
        MS_OFFICE = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"INTERNAL")]
        INTERNAL = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ImagingOptionsExcelPageOrientation
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PORTRAIT")]
        PORTRAIT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"LANDSCAPE")]
        LANDSCAPE = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ImagingOptionsExcelPageZoom
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PERCENT_25")]
        PERCENT_25 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"PERCENT_50")]
        PERCENT_50 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"PERCENT_75")]
        PERCENT_75 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"PERCENT_100")]
        PERCENT_100 = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"PERCENT_125")]
        PERCENT_125 = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"PERCENT_150")]
        PERCENT_150 = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"PERCENT_200")]
        PERCENT_200 = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"PERCENT_400")]
        PERCENT_400 = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ImagingOptionsExcelPaperSize
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_10x14")]
        PAPER_10x14 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_11x17")]
        PAPER_11x17 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_A3")]
        PAPER_A3 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_A4")]
        PAPER_A4 = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_A4Small")]
        PAPER_A4Small = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_A5")]
        PAPER_A5 = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_B4")]
        PAPER_B4 = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_B5")]
        PAPER_B5 = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_Csheet")]
        PAPER_Csheet = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_Dsheet")]
        PAPER_Dsheet = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_Envelope10")]
        PAPER_Envelope10 = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_Envelope11")]
        PAPER_Envelope11 = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_Envelope12")]
        PAPER_Envelope12 = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_Envelope14")]
        PAPER_Envelope14 = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_Envelope9")]
        PAPER_Envelope9 = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_EnvelopeB4")]
        PAPER_EnvelopeB4 = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_EnvelopeB5")]
        PAPER_EnvelopeB5 = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_EnvelopeB6")]
        PAPER_EnvelopeB6 = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_EnvelopeC3")]
        PAPER_EnvelopeC3 = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_EnvelopeC4")]
        PAPER_EnvelopeC4 = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_EnvelopeC5")]
        PAPER_EnvelopeC5 = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_EnvelopeC6")]
        PAPER_EnvelopeC6 = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_EnvelopeC65")]
        PAPER_EnvelopeC65 = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_EnvelopeDL")]
        PAPER_EnvelopeDL = 23,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_EnvelopeItaly")]
        PAPER_EnvelopeItaly = 24,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_EnvelopeMonarch")]
        PAPER_EnvelopeMonarch = 25,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_EnvelopePersonal")]
        PAPER_EnvelopePersonal = 26,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_Esheet")]
        PAPER_Esheet = 27,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_Executive")]
        PAPER_Executive = 28,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_FanfoldLegalGerman")]
        PAPER_FanfoldLegalGerman = 29,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_FanfoldStdGerman")]
        PAPER_FanfoldStdGerman = 30,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_FanfoldUS")]
        PAPER_FanfoldUS = 31,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_Folio")]
        PAPER_Folio = 32,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_Ledger")]
        PAPER_Ledger = 33,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_Legal")]
        PAPER_Legal = 34,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_Letter")]
        PAPER_Letter = 35,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_LetterSmall")]
        PAPER_LetterSmall = 36,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_Note")]
        PAPER_Note = 37,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_Quarto")]
        PAPER_Quarto = 38,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_Statement")]
        PAPER_Statement = 39,

        [System.Runtime.Serialization.EnumMember(Value = @"PAPER_Tabloid")]
        PAPER_Tabloid = 40,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ImagingOptionsExcelPrintComments
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PRINT_IN_PLACE")]
        PRINT_IN_PLACE = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"PRINT_NO_COMMENTS")]
        PRINT_NO_COMMENTS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"PRINT_SHEETEND")]
        PRINT_SHEETEND = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ImagingOptionsExcelPrintHiddenWorksheets
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SHEET_HIDDEN")]
        SHEET_HIDDEN = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"SHEET_VERY_HIDDEN")]
        SHEET_VERY_HIDDEN = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ImagingOptionsPowerPointPrintOutputType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PRINT_OUTPUT_BUILD_SLIDES")]
        PRINT_OUTPUT_BUILD_SLIDES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"PRINT_OUTPUT_FOUR_SLIDE_HANDOUTS")]
        PRINT_OUTPUT_FOUR_SLIDE_HANDOUTS = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"PRINT_OUTPUT_NINE_SLIDE_HANDOUTS")]
        PRINT_OUTPUT_NINE_SLIDE_HANDOUTS = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"PRINT_OUTPUT_NOTES_PAGES")]
        PRINT_OUTPUT_NOTES_PAGES = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"PRINT_OUTPUT_ONE_SLIDE_HANDOUTS")]
        PRINT_OUTPUT_ONE_SLIDE_HANDOUTS = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"PRINT_OUTPUT_OUTLINE")]
        PRINT_OUTPUT_OUTLINE = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"PRINT_OUTPUT_SIX_SLIDE_HANDOUTS")]
        PRINT_OUTPUT_SIX_SLIDE_HANDOUTS = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"PRINT_OUTPUT_SLIDES")]
        PRINT_OUTPUT_SLIDES = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"PRINT_OUTPUT_THREE_SLIDE_HANDOUTS")]
        PRINT_OUTPUT_THREE_SLIDE_HANDOUTS = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"PRINT_OUTPUT_TWO_SLIDE_HANDOUTS")]
        PRINT_OUTPUT_TWO_SLIDE_HANDOUTS = 9,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ImagingOptionsPowerpointExportEngine
    {
        [System.Runtime.Serialization.EnumMember(Value = @"MS_OFFICE")]
        MS_OFFICE = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"INTERNAL")]
        INTERNAL = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ImagingOptionsWordExportingEngine
    {
        [System.Runtime.Serialization.EnumMember(Value = @"MS_OFFICE")]
        MS_OFFICE = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"INTERNAL")]
        INTERNAL = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum BulkItemCustomMetadataRequestMode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"api")]
        Api = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"user")]
        User = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum BulkItemCustomMetadataRequestType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"binary")]
        Binary = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"boolean")]
        Boolean = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"date-time")]
        DateTime = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"float")]
        Float = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"integer")]
        Integer = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"text")]
        Text = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum CustomMetadataResponseMode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"api")]
        Api = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"user")]
        User = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum CustomMetadataResponseType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"binary")]
        Binary = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"boolean")]
        Boolean = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"date-time")]
        DateTime = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"float")]
        Float = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"integer")]
        Integer = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"text")]
        Text = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ExportRequestExportType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ITEM")]
        ITEM = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"LEGAL")]
        LEGAL = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum LoadFileTypes
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CONCORDANCE")]
        CONCORDANCE = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"DISCOVERY_RADAR")]
        DISCOVERY_RADAR = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DOCUMATRIX")]
        DOCUMATRIX = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"EDRM_XML")]
        EDRM_XML = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"IPRO")]
        IPRO = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"RINGTAIL")]
        RINGTAIL = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"SUMMATION")]
        SUMMATION = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"XHTML_SUMMARY_REPORT")]
        XHTML_SUMMARY_REPORT = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"CSV_SUMMARY_REPORT")]
        CSV_SUMMARY_REPORT = 8,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ProductTypes
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NATIVE")]
        NATIVE = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"PDF")]
        PDF = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"TEXT")]
        TEXT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"THUMBNAIL")]
        THUMBNAIL = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"TIFF")]
        TIFF = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"XHTML_REPORT")]
        XHTML_REPORT = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum WordcountRequestDeduplication
    {
        [System.Runtime.Serialization.EnumMember(Value = @"none")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"md5")]
        Md5 = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum WordcountRequestField
    {
        [System.Runtime.Serialization.EnumMember(Value = @"all")]
        All = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"content")]
        Content = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"properties")]
        Properties = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum WordcountRequestFilter
    {
        [System.Runtime.Serialization.EnumMember(Value = @"all")]
        All = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"numeric")]
        Numeric = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"aToZ")]
        AToZ = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"foreign")]
        Foreign = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"atypicalLength")]
        AtypicalLength = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum WordcountRequestSort
    {
        [System.Runtime.Serialization.EnumMember(Value = @"on")]
        On = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"off")]
        Off = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum CaseModificationMethod
    {
        [System.Runtime.Serialization.EnumMember(Value = @"MIGRATE")]
        MIGRATE = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum DeduplicationQueryListRequestDeduplication
    {
        [System.Runtime.Serialization.EnumMember(Value = @"none")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"md5")]
        Md5 = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum WordCountsRequestDeduplication
    {
        [System.Runtime.Serialization.EnumMember(Value = @"none")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"md5")]
        Md5 = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum WordCountsRequestField
    {
        [System.Runtime.Serialization.EnumMember(Value = @"all")]
        All = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"content")]
        Content = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"properties")]
        Properties = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum WordCountsRequestFilter
    {
        [System.Runtime.Serialization.EnumMember(Value = @"all")]
        All = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"numeric")]
        Numeric = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"aToZ")]
        AToZ = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"foreign")]
        Foreign = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"atypicalLength")]
        AtypicalLength = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum WordCountsRequestSort
    {
        [System.Runtime.Serialization.EnumMember(Value = @"on")]
        On = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"off")]
        Off = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ApplyTagListRequestDeduplicate
    {
        [System.Runtime.Serialization.EnumMember(Value = @"MD5")]
        MD5 = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Per Custodian")]
        Per_Custodian = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum OcrOptionsLanguages
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Abkhaz")]
        Abkhaz = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Adyghe")]
        Adyghe = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Afrikaans")]
        Afrikaans = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Agul")]
        Agul = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"Albanian")]
        Albanian = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"Altaic")]
        Altaic = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"Arabic")]
        Arabic = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"ArmenianEastern")]
        ArmenianEastern = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"ArmenianGrabar")]
        ArmenianGrabar = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"ArmenianWestern")]
        ArmenianWestern = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"Awar")]
        Awar = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"Aymara")]
        Aymara = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"AzeriCyrillic")]
        AzeriCyrillic = 12,

        [System.Runtime.Serialization.EnumMember(Value = @"AzeriLatin")]
        AzeriLatin = 13,

        [System.Runtime.Serialization.EnumMember(Value = @"Bashkir")]
        Bashkir = 14,

        [System.Runtime.Serialization.EnumMember(Value = @"Basque")]
        Basque = 15,

        [System.Runtime.Serialization.EnumMember(Value = @"Belarusian")]
        Belarusian = 16,

        [System.Runtime.Serialization.EnumMember(Value = @"Bemba")]
        Bemba = 17,

        [System.Runtime.Serialization.EnumMember(Value = @"Blackfoot")]
        Blackfoot = 18,

        [System.Runtime.Serialization.EnumMember(Value = @"Breton")]
        Breton = 19,

        [System.Runtime.Serialization.EnumMember(Value = @"Bugotu")]
        Bugotu = 20,

        [System.Runtime.Serialization.EnumMember(Value = @"Bulgarian")]
        Bulgarian = 21,

        [System.Runtime.Serialization.EnumMember(Value = @"Buryat")]
        Buryat = 22,

        [System.Runtime.Serialization.EnumMember(Value = @"Catalan")]
        Catalan = 23,

        [System.Runtime.Serialization.EnumMember(Value = @"Chamorro")]
        Chamorro = 24,

        [System.Runtime.Serialization.EnumMember(Value = @"Chechen")]
        Chechen = 25,

        [System.Runtime.Serialization.EnumMember(Value = @"ChinesePRC")]
        ChinesePRC = 26,

        [System.Runtime.Serialization.EnumMember(Value = @"ChineseTaiwan")]
        ChineseTaiwan = 27,

        [System.Runtime.Serialization.EnumMember(Value = @"Chukcha")]
        Chukcha = 28,

        [System.Runtime.Serialization.EnumMember(Value = @"Chuvash")]
        Chuvash = 29,

        [System.Runtime.Serialization.EnumMember(Value = @"Corsican")]
        Corsican = 30,

        [System.Runtime.Serialization.EnumMember(Value = @"CrimeanTatar")]
        CrimeanTatar = 31,

        [System.Runtime.Serialization.EnumMember(Value = @"Croatian")]
        Croatian = 32,

        [System.Runtime.Serialization.EnumMember(Value = @"Crow")]
        Crow = 33,

        [System.Runtime.Serialization.EnumMember(Value = @"Czech")]
        Czech = 34,

        [System.Runtime.Serialization.EnumMember(Value = @"Danish")]
        Danish = 35,

        [System.Runtime.Serialization.EnumMember(Value = @"Dargwa")]
        Dargwa = 36,

        [System.Runtime.Serialization.EnumMember(Value = @"Dungan")]
        Dungan = 37,

        [System.Runtime.Serialization.EnumMember(Value = @"Dutch")]
        Dutch = 38,

        [System.Runtime.Serialization.EnumMember(Value = @"DutchBelgian")]
        DutchBelgian = 39,

        [System.Runtime.Serialization.EnumMember(Value = @"English")]
        English = 40,

        [System.Runtime.Serialization.EnumMember(Value = @"EskimoCyrillic")]
        EskimoCyrillic = 41,

        [System.Runtime.Serialization.EnumMember(Value = @"EskimoLatin")]
        EskimoLatin = 42,

        [System.Runtime.Serialization.EnumMember(Value = @"Esperanto")]
        Esperanto = 43,

        [System.Runtime.Serialization.EnumMember(Value = @"Estonian")]
        Estonian = 44,

        [System.Runtime.Serialization.EnumMember(Value = @"Even")]
        Even = 45,

        [System.Runtime.Serialization.EnumMember(Value = @"Evenki")]
        Evenki = 46,

        [System.Runtime.Serialization.EnumMember(Value = @"Faeroese")]
        Faeroese = 47,

        [System.Runtime.Serialization.EnumMember(Value = @"Fijian")]
        Fijian = 48,

        [System.Runtime.Serialization.EnumMember(Value = @"Finnish")]
        Finnish = 49,

        [System.Runtime.Serialization.EnumMember(Value = @"French")]
        French = 50,

        [System.Runtime.Serialization.EnumMember(Value = @"Frisian")]
        Frisian = 51,

        [System.Runtime.Serialization.EnumMember(Value = @"Friulian")]
        Friulian = 52,

        [System.Runtime.Serialization.EnumMember(Value = @"GaelicScottish")]
        GaelicScottish = 53,

        [System.Runtime.Serialization.EnumMember(Value = @"Gagauz")]
        Gagauz = 54,

        [System.Runtime.Serialization.EnumMember(Value = @"Galician")]
        Galician = 55,

        [System.Runtime.Serialization.EnumMember(Value = @"Ganda")]
        Ganda = 56,

        [System.Runtime.Serialization.EnumMember(Value = @"German")]
        German = 57,

        [System.Runtime.Serialization.EnumMember(Value = @"GermanLuxembourg")]
        GermanLuxembourg = 58,

        [System.Runtime.Serialization.EnumMember(Value = @"GermanNewSpelling")]
        GermanNewSpelling = 59,

        [System.Runtime.Serialization.EnumMember(Value = @"Greek")]
        Greek = 60,

        [System.Runtime.Serialization.EnumMember(Value = @"Guarani")]
        Guarani = 61,

        [System.Runtime.Serialization.EnumMember(Value = @"Hani")]
        Hani = 62,

        [System.Runtime.Serialization.EnumMember(Value = @"Hausa")]
        Hausa = 63,

        [System.Runtime.Serialization.EnumMember(Value = @"Hawaiian")]
        Hawaiian = 64,

        [System.Runtime.Serialization.EnumMember(Value = @"Hebrew")]
        Hebrew = 65,

        [System.Runtime.Serialization.EnumMember(Value = @"Hungarian")]
        Hungarian = 66,

        [System.Runtime.Serialization.EnumMember(Value = @"Icelandic")]
        Icelandic = 67,

        [System.Runtime.Serialization.EnumMember(Value = @"Ido")]
        Ido = 68,

        [System.Runtime.Serialization.EnumMember(Value = @"Indonesian")]
        Indonesian = 69,

        [System.Runtime.Serialization.EnumMember(Value = @"Ingush")]
        Ingush = 70,

        [System.Runtime.Serialization.EnumMember(Value = @"Interlingua")]
        Interlingua = 71,

        [System.Runtime.Serialization.EnumMember(Value = @"Irish")]
        Irish = 72,

        [System.Runtime.Serialization.EnumMember(Value = @"Italian")]
        Italian = 73,

        [System.Runtime.Serialization.EnumMember(Value = @"Japanese")]
        Japanese = 74,

        [System.Runtime.Serialization.EnumMember(Value = @"Kabardian")]
        Kabardian = 75,

        [System.Runtime.Serialization.EnumMember(Value = @"Kalmyk")]
        Kalmyk = 76,

        [System.Runtime.Serialization.EnumMember(Value = @"KarachayBalkar")]
        KarachayBalkar = 77,

        [System.Runtime.Serialization.EnumMember(Value = @"Karakalpak")]
        Karakalpak = 78,

        [System.Runtime.Serialization.EnumMember(Value = @"Kasub")]
        Kasub = 79,

        [System.Runtime.Serialization.EnumMember(Value = @"Kawa")]
        Kawa = 80,

        [System.Runtime.Serialization.EnumMember(Value = @"Kazakh")]
        Kazakh = 81,

        [System.Runtime.Serialization.EnumMember(Value = @"Khakas")]
        Khakas = 82,

        [System.Runtime.Serialization.EnumMember(Value = @"Khanty")]
        Khanty = 83,

        [System.Runtime.Serialization.EnumMember(Value = @"Kikuyu")]
        Kikuyu = 84,

        [System.Runtime.Serialization.EnumMember(Value = @"Kirgiz")]
        Kirgiz = 85,

        [System.Runtime.Serialization.EnumMember(Value = @"Kongo")]
        Kongo = 86,

        [System.Runtime.Serialization.EnumMember(Value = @"Korean")]
        Korean = 87,

        [System.Runtime.Serialization.EnumMember(Value = @"Koryak")]
        Koryak = 88,

        [System.Runtime.Serialization.EnumMember(Value = @"Kpelle")]
        Kpelle = 89,

        [System.Runtime.Serialization.EnumMember(Value = @"Kumyk")]
        Kumyk = 90,

        [System.Runtime.Serialization.EnumMember(Value = @"Kurdish")]
        Kurdish = 91,

        [System.Runtime.Serialization.EnumMember(Value = @"Lak")]
        Lak = 92,

        [System.Runtime.Serialization.EnumMember(Value = @"Lappish")]
        Lappish = 93,

        [System.Runtime.Serialization.EnumMember(Value = @"Latin")]
        Latin = 94,

        [System.Runtime.Serialization.EnumMember(Value = @"Latvian")]
        Latvian = 95,

        [System.Runtime.Serialization.EnumMember(Value = @"LatvianGothic")]
        LatvianGothic = 96,

        [System.Runtime.Serialization.EnumMember(Value = @"Lezgin")]
        Lezgin = 97,

        [System.Runtime.Serialization.EnumMember(Value = @"Lithuanian")]
        Lithuanian = 98,

        [System.Runtime.Serialization.EnumMember(Value = @"Luba")]
        Luba = 99,

        [System.Runtime.Serialization.EnumMember(Value = @"Macedonian")]
        Macedonian = 100,

        [System.Runtime.Serialization.EnumMember(Value = @"Malagasy")]
        Malagasy = 101,

        [System.Runtime.Serialization.EnumMember(Value = @"Malay")]
        Malay = 102,

        [System.Runtime.Serialization.EnumMember(Value = @"Malinke")]
        Malinke = 103,

        [System.Runtime.Serialization.EnumMember(Value = @"Maltese")]
        Maltese = 104,

        [System.Runtime.Serialization.EnumMember(Value = @"Mansi")]
        Mansi = 105,

        [System.Runtime.Serialization.EnumMember(Value = @"Maori")]
        Maori = 106,

        [System.Runtime.Serialization.EnumMember(Value = @"Mari")]
        Mari = 107,

        [System.Runtime.Serialization.EnumMember(Value = @"Maya")]
        Maya = 108,

        [System.Runtime.Serialization.EnumMember(Value = @"Miao")]
        Miao = 109,

        [System.Runtime.Serialization.EnumMember(Value = @"Minankabaw")]
        Minankabaw = 110,

        [System.Runtime.Serialization.EnumMember(Value = @"Mohawk")]
        Mohawk = 111,

        [System.Runtime.Serialization.EnumMember(Value = @"Mongol")]
        Mongol = 112,

        [System.Runtime.Serialization.EnumMember(Value = @"Mordvin")]
        Mordvin = 113,

        [System.Runtime.Serialization.EnumMember(Value = @"Nahuatl")]
        Nahuatl = 114,

        [System.Runtime.Serialization.EnumMember(Value = @"Nenets")]
        Nenets = 115,

        [System.Runtime.Serialization.EnumMember(Value = @"Nivkh")]
        Nivkh = 116,

        [System.Runtime.Serialization.EnumMember(Value = @"Nogay")]
        Nogay = 117,

        [System.Runtime.Serialization.EnumMember(Value = @"Norwegian")]
        Norwegian = 118,

        [System.Runtime.Serialization.EnumMember(Value = @"NorwegianBokmal")]
        NorwegianBokmal = 119,

        [System.Runtime.Serialization.EnumMember(Value = @"NorwegianNynorsk")]
        NorwegianNynorsk = 120,

        [System.Runtime.Serialization.EnumMember(Value = @"Nyanja")]
        Nyanja = 121,

        [System.Runtime.Serialization.EnumMember(Value = @"Occidental")]
        Occidental = 122,

        [System.Runtime.Serialization.EnumMember(Value = @"Ojibway")]
        Ojibway = 123,

        [System.Runtime.Serialization.EnumMember(Value = @"Ossetic")]
        Ossetic = 124,

        [System.Runtime.Serialization.EnumMember(Value = @"Papiamento")]
        Papiamento = 125,

        [System.Runtime.Serialization.EnumMember(Value = @"PidginEnglish")]
        PidginEnglish = 126,

        [System.Runtime.Serialization.EnumMember(Value = @"Polish")]
        Polish = 127,

        [System.Runtime.Serialization.EnumMember(Value = @"PortugueseBrazilian")]
        PortugueseBrazilian = 128,

        [System.Runtime.Serialization.EnumMember(Value = @"PortugueseStandard")]
        PortugueseStandard = 129,

        [System.Runtime.Serialization.EnumMember(Value = @"Provencal")]
        Provencal = 130,

        [System.Runtime.Serialization.EnumMember(Value = @"Quechua")]
        Quechua = 131,

        [System.Runtime.Serialization.EnumMember(Value = @"RhaetoRomanic")]
        RhaetoRomanic = 132,

        [System.Runtime.Serialization.EnumMember(Value = @"Romanian")]
        Romanian = 133,

        [System.Runtime.Serialization.EnumMember(Value = @"RomanianMoldavia")]
        RomanianMoldavia = 134,

        [System.Runtime.Serialization.EnumMember(Value = @"Romany")]
        Romany = 135,

        [System.Runtime.Serialization.EnumMember(Value = @"Ruanda")]
        Ruanda = 136,

        [System.Runtime.Serialization.EnumMember(Value = @"Rundi")]
        Rundi = 137,

        [System.Runtime.Serialization.EnumMember(Value = @"Russian")]
        Russian = 138,

        [System.Runtime.Serialization.EnumMember(Value = @"RussianOldSpelling")]
        RussianOldSpelling = 139,

        [System.Runtime.Serialization.EnumMember(Value = @"Samoan")]
        Samoan = 140,

        [System.Runtime.Serialization.EnumMember(Value = @"Selkup")]
        Selkup = 141,

        [System.Runtime.Serialization.EnumMember(Value = @"SerbianCyrillic")]
        SerbianCyrillic = 142,

        [System.Runtime.Serialization.EnumMember(Value = @"SerbianLatin")]
        SerbianLatin = 143,

        [System.Runtime.Serialization.EnumMember(Value = @"Shona")]
        Shona = 144,

        [System.Runtime.Serialization.EnumMember(Value = @"Sioux")]
        Sioux = 145,

        [System.Runtime.Serialization.EnumMember(Value = @"Slovak")]
        Slovak = 146,

        [System.Runtime.Serialization.EnumMember(Value = @"Slovenian")]
        Slovenian = 147,

        [System.Runtime.Serialization.EnumMember(Value = @"Somali")]
        Somali = 148,

        [System.Runtime.Serialization.EnumMember(Value = @"Sorbian")]
        Sorbian = 149,

        [System.Runtime.Serialization.EnumMember(Value = @"Sotho")]
        Sotho = 150,

        [System.Runtime.Serialization.EnumMember(Value = @"Spanish")]
        Spanish = 151,

        [System.Runtime.Serialization.EnumMember(Value = @"Sunda")]
        Sunda = 152,

        [System.Runtime.Serialization.EnumMember(Value = @"Swahili")]
        Swahili = 153,

        [System.Runtime.Serialization.EnumMember(Value = @"Swazi")]
        Swazi = 154,

        [System.Runtime.Serialization.EnumMember(Value = @"Swedish")]
        Swedish = 155,

        [System.Runtime.Serialization.EnumMember(Value = @"Tabassaran")]
        Tabassaran = 156,

        [System.Runtime.Serialization.EnumMember(Value = @"Tagalog")]
        Tagalog = 157,

        [System.Runtime.Serialization.EnumMember(Value = @"Tahitian")]
        Tahitian = 158,

        [System.Runtime.Serialization.EnumMember(Value = @"Tajik")]
        Tajik = 159,

        [System.Runtime.Serialization.EnumMember(Value = @"Tatar")]
        Tatar = 160,

        [System.Runtime.Serialization.EnumMember(Value = @"Thai")]
        Thai = 161,

        [System.Runtime.Serialization.EnumMember(Value = @"Tinpo")]
        Tinpo = 162,

        [System.Runtime.Serialization.EnumMember(Value = @"Tongan")]
        Tongan = 163,

        [System.Runtime.Serialization.EnumMember(Value = @"Tswana")]
        Tswana = 164,

        [System.Runtime.Serialization.EnumMember(Value = @"Tun")]
        Tun = 165,

        [System.Runtime.Serialization.EnumMember(Value = @"Turkish")]
        Turkish = 166,

        [System.Runtime.Serialization.EnumMember(Value = @"Turkmen")]
        Turkmen = 167,

        [System.Runtime.Serialization.EnumMember(Value = @"TurkmenLatin")]
        TurkmenLatin = 168,

        [System.Runtime.Serialization.EnumMember(Value = @"Tuvin")]
        Tuvin = 169,

        [System.Runtime.Serialization.EnumMember(Value = @"Udmurt")]
        Udmurt = 170,

        [System.Runtime.Serialization.EnumMember(Value = @"UighurCyrillic")]
        UighurCyrillic = 171,

        [System.Runtime.Serialization.EnumMember(Value = @"UighurLatin")]
        UighurLatin = 172,

        [System.Runtime.Serialization.EnumMember(Value = @"Ukrainian")]
        Ukrainian = 173,

        [System.Runtime.Serialization.EnumMember(Value = @"UzbekCyrillic")]
        UzbekCyrillic = 174,

        [System.Runtime.Serialization.EnumMember(Value = @"UzbekLatin")]
        UzbekLatin = 175,

        [System.Runtime.Serialization.EnumMember(Value = @"Vietnamese")]
        Vietnamese = 176,

        [System.Runtime.Serialization.EnumMember(Value = @"Visayan")]
        Visayan = 177,

        [System.Runtime.Serialization.EnumMember(Value = @"Welsh")]
        Welsh = 178,

        [System.Runtime.Serialization.EnumMember(Value = @"Wolof")]
        Wolof = 179,

        [System.Runtime.Serialization.EnumMember(Value = @"Xhosa")]
        Xhosa = 180,

        [System.Runtime.Serialization.EnumMember(Value = @"Yakut")]
        Yakut = 181,

        [System.Runtime.Serialization.EnumMember(Value = @"Yiddish")]
        Yiddish = 182,

        [System.Runtime.Serialization.EnumMember(Value = @"Zapotec")]
        Zapotec = 183,

        [System.Runtime.Serialization.EnumMember(Value = @"Zulu")]
        Zulu = 184,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum OcrOptionsQuality
    {
        [System.Runtime.Serialization.EnumMember(Value = @"default")]
        Default = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"document_archiving_accuracy")]
        Document_archiving_accuracy = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"document_archiving_speed")]
        Document_archiving_speed = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"book_archiving_accuracy")]
        Book_archiving_accuracy = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"book_archiving_speed")]
        Book_archiving_speed = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"document_conversion_accuracy")]
        Document_conversion_accuracy = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"document_conversion_speed")]
        Document_conversion_speed = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"text_extraction_accuracy")]
        Text_extraction_accuracy = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"text_extraction_speed")]
        Text_extraction_speed = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"field_level_recognition")]
        Field_level_recognition = 9,

        [System.Runtime.Serialization.EnumMember(Value = @"fast")]
        Fast = 10,

        [System.Runtime.Serialization.EnumMember(Value = @"mid_range")]
        Mid_range = 11,

        [System.Runtime.Serialization.EnumMember(Value = @"high_quality")]
        High_quality = 12,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum OcrOptionsRotation
    {
        [System.Runtime.Serialization.EnumMember(Value = @"auto")]
        Auto = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"no_rotation")]
        No_rotation = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"left")]
        Left = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"right")]
        Right = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"upside_down")]
        Upside_down = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum OcrOptionsTextModification
    {
        [System.Runtime.Serialization.EnumMember(Value = @"append")]
        Append = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"overwrite")]
        Overwrite = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum CreateReviewJobOptionsOrder
    {
        [System.Runtime.Serialization.EnumMember(Value = @"orderAdded")]
        OrderAdded = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"ascendingItemDate")]
        AscendingItemDate = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"descendingItemDate")]
        DescendingItemDate = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"ascendingTopLevelItemDate")]
        AscendingTopLevelItemDate = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"descendingTopLevelItemDate")]
        DescendingTopLevelItemDate = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.4.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum UserScriptRequestLanguage
    {
        [System.Runtime.Serialization.EnumMember(Value = @"RUBY")]
        RUBY = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"JAVASCRIPT")]
        JAVASCRIPT = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"PYTHON")]
        PYTHON = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class FileParameter
    {
        public FileParameter(System.IO.Stream data)
            : this(data, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName)
            : this(data, fileName, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName, string contentType)
        {
            Data = data;
            FileName = fileName;
            ContentType = contentType;
        }

        public System.IO.Stream Data { get; private set; }

        public string FileName { get; private set; }

        public string ContentType { get; private set; }
    }

    public partial class FileResponse : System.IDisposable
    {
        private System.IDisposable _client;
        private System.IDisposable _response;

        public int StatusCode { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public System.IO.Stream Stream { get; private set; }

        public bool IsPartial
        {
            get { return StatusCode == 206; }
        }

        public FileResponse(int statusCode, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.IO.Stream stream, System.IDisposable client, System.IDisposable response)
        {
            StatusCode = statusCode;
            Headers = headers;
            Stream = stream;
            _client = client;
            _response = response;
        }

        public void Dispose()
        {
            if (Stream != null)
                Stream.Dispose();
            if (_response != null)
                _response.Dispose();
            if (_client != null)
                _client.Dispose();
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + response.Substring(0, response.Length >= 512 ? 512 : response.Length), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore 472
#pragma warning restore 114
#pragma warning restore 108